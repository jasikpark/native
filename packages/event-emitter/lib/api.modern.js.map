{"version":3,"file":"api.modern.js","sources":["../src/api.ts"],"sourcesContent":["import Manager from \"managerjs\";\r\n\r\nexport type ListenerCallback = (...args: any) => void;\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Listener\r\n */\r\nexport class Listener {\r\n\t/**\r\n\t * The current listener data\r\n\t *\r\n\t * @private\r\n\t * @type IListener\r\n\t * @memberof Listener\r\n\t */\r\n    private listener: IListener;\r\n\r\n\t/**\r\n\t * Creates an instance of Listener.\r\n\t *\r\n\t * @param {IListener} { callback = () => { }, scope = null, name = \"event\" }\r\n\t * @memberof Listener\r\n\t */\r\n    constructor({\r\n        callback = () => { },\r\n        scope = null,\r\n        name = \"event\",\r\n    }: IListener) {\r\n        this.listener = { callback, scope, name };\r\n    }\r\n\r\n\t/**\r\n\t * Returns the callback Function of the Listener\r\n\t *\r\n\t * @returns ListenerCallback\r\n\t * @memberof Listener\r\n\t */\r\n    public getCallback(): ListenerCallback {\r\n        return this.listener.callback;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the scope as an Object, from the Listener\r\n\t *\r\n\t * @returns object\r\n\t * @memberof Listener\r\n\t */\r\n    public getScope(): object {\r\n        return this.listener.scope;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the event as a String, from the Listener\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Listener\r\n\t */\r\n    public getEventName(): string {\r\n        return this.listener.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the listener as an Object\r\n\t *\r\n\t * @returns IListener\r\n\t * @memberof Listener\r\n\t */\r\n    public toJSON(): IListener {\r\n        return this.listener;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, Listener> {\r\n\t/**\r\n\t * The name of the event\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Event\r\n\t */\r\n    private name: string;\r\n\r\n\t/**\r\n\t * Creates an instance of Event.\r\n\t *\r\n\t * @param {string} [name=\"event\"]\r\n\t * @memberof Event\r\n\t */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n\t/**\r\n\t * Creates an instance of EventEmitter.\r\n\t *\r\n\t * @memberof EventEmitter\r\n\t */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n\t * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\t/**\r\n\t * Creates a new listener and adds it to the event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(new Listener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a listener for a given event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from an event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.getEvent(name);\r\n\r\n        if (callback) {\r\n            let i = 0,\r\n                len: number = event.size,\r\n                value: Listener;\r\n            let listener = new Listener({ name, callback, scope });\r\n            for (; i < len; i++) {\r\n                value = event.get(i);\r\n                console.log(value);\r\n                if (\r\n                    value.getCallback() === listener.getCallback() &&\r\n                    value.getScope() === listener.getScope()\r\n                )\r\n                    break;\r\n            }\r\n\r\n            event.delete(i);\r\n        }\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from a given event, or it just completely removes an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach((key) => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            if (_callback) {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a one time event listener for an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public once(\r\n        events: EventInput,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let onceFn: ListenerCallback = (...args) => {\r\n            this.off(events, onceFn, scope);\r\n            callback.apply(scope, args);\r\n        };\r\n\r\n        this.on(events, onceFn, scope);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call all listeners within an event\r\n\t *\r\n\t * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let listeners: Event = this.getEvent(event);\r\n\r\n            const customEvent: CustomEvent<any> = new CustomEvent(event, { detail: args })\r\n            window.dispatchEvent(customEvent);\r\n\r\n            listeners.forEach((listener: Listener) => {\r\n                let { callback, scope }: IListener = listener.toJSON();\r\n                callback.apply(scope, args);\r\n            });\r\n        }, this);\r\n        return this;\r\n    }\r\n}"],"names":["Listener","constructor","callback","scope","name","this","listener","getCallback","getScope","getEventName","toJSON","Event","Manager","super","EventEmitter","getEvent","event","get","set","newListener","add","on","events","_name","_callback","_scope","split","Object","keys","forEach","key","Array","isArray","removeListener","value","i","len","size","console","log","delete","off","once","onceFn","args","apply","emit","listeners","customEvent","CustomEvent","detail","window","dispatchEvent"],"mappings":"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"}