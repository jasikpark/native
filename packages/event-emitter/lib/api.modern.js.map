{"version":3,"file":"api.modern.js","sources":["../node_modules/.pnpm/managerjs@1.1.8/node_modules/managerjs/src/api.ts","../src/api.ts"],"sourcesContent":["\r\n/**\r\n * Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data.\r\n *\r\n * @export\r\n * @class Manager\r\n * @template K\r\n * @template V\r\n */\r\nexport class Manager<K, V> {\r\n\t/**\r\n\t * The complex list of named data, to which the Manager controls\r\n\t *\r\n\t * @protected\r\n\t * @type Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tprotected map: Map<K, V>;\r\n\r\n    /**\r\n     * Creates an instance of Manager.\r\n     * \r\n     * @param {Array<[K, V]>} [value]\r\n     * @memberof Manager\r\n     */\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Manager class's list\r\n\t *\r\n\t * @returns Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key to find in the Manager's list\r\n\t * @returns V\r\n\t */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the keys of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<K>\r\n     * @memberof Manager\r\n     */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn [...this.map.keys()];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the values of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<V>\r\n     * @memberof Manager\r\n\t */\r\n\tpublic values(): Array<V> {\r\n\t\treturn [...this.map.values()];\r\n\t}\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers\r\n     *\r\n     * @public\r\n     * @param  {V} value\r\n     * @returns Manager<K, V>\r\n     */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\t// @ts-ignore\r\n\t\tthis.set(this.size as K, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total number of items stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns Number\r\n\t */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n    /**\r\n\t * Returns the last item in the Manager who's index is a certain distance from the last item in the Manager\r\n     *\r\n     * @param {number} [distance=1]\r\n     * @returns V | undefined\r\n     * @memberof Manager\r\n     */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the second last item in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns V | undefined\r\n\t */\r\n\tpublic prev(): V | undefined {\r\n\t\treturn this.last(2);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic delete(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the Manager of all its contents\r\n\t *\r\n\t * @public\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the Manager contains a certain key\r\n\t *\r\n\t * @public\r\n\t * @param {K} key\r\n\t * @returns boolean\r\n\t */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.\r\n\t *\r\n\t * @public\r\n\t * @returns IterableIterator<[K, V]>\r\n\t */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates through the Managers contents, calling a callback function every iteration\r\n\t *\r\n\t * @param {*} [callback=(...args: any): void => { }]\r\n\t * @param {object} context\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic forEach(\r\n\t\tcallback: any = (...args: any): void => { },\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Allows iteration via the for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators]\r\n     *\r\n     * @returns\r\n     * @memberof Manager\r\n     */\r\n\tpublic [Symbol.iterator]() {\r\n\t\treturn this.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the method of a certain name for all items that are currently installed\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic methodCall(method: string, ...args: any): Manager<K, V> {\r\n\t\tthis.forEach((item: V) => {\r\n\t\t\titem[method](...args);\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Promise<Manager<K, V>>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic async asyncMethodCall(method: string, ...args: any): Promise<Manager<K, V>> {\r\n\t\tfor await (let [, item] of this.map) {\r\n\t\t\tawait item[method](...args);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Manager } from \"managerjs/src/api\";\r\n\r\nexport type ListenerCallback = (...args: any) => void;\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Listener\r\n */\r\nexport class Listener {\r\n\t/**\r\n\t * The current listener data\r\n\t *\r\n\t * @private\r\n\t * @type IListener\r\n\t * @memberof Listener\r\n\t */\r\n    private listener: IListener;\r\n\r\n\t/**\r\n\t * Creates an instance of Listener.\r\n\t *\r\n\t * @param {IListener} { callback = () => { }, scope = null, name = \"event\" }\r\n\t * @memberof Listener\r\n\t */\r\n    constructor({\r\n        callback = () => { },\r\n        scope = null,\r\n        name = \"event\",\r\n    }: IListener) {\r\n        this.listener = { callback, scope, name };\r\n    }\r\n\r\n\t/**\r\n\t * Returns the callback Function of the Listener\r\n\t *\r\n\t * @returns ListenerCallback\r\n\t * @memberof Listener\r\n\t */\r\n    public getCallback(): ListenerCallback {\r\n        return this.listener.callback;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the scope as an Object, from the Listener\r\n\t *\r\n\t * @returns object\r\n\t * @memberof Listener\r\n\t */\r\n    public getScope(): object {\r\n        return this.listener.scope;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the event as a String, from the Listener\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Listener\r\n\t */\r\n    public getEventName(): string {\r\n        return this.listener.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the listener as an Object\r\n\t *\r\n\t * @returns IListener\r\n\t * @memberof Listener\r\n\t */\r\n    public toJSON(): IListener {\r\n        return this.listener;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, Listener> {\r\n\t/**\r\n\t * The name of the event\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Event\r\n\t */\r\n    private name: string;\r\n\r\n\t/**\r\n\t * Creates an instance of Event.\r\n\t *\r\n\t * @param {string} [name=\"event\"]\r\n\t * @memberof Event\r\n\t */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n\t/**\r\n\t * Creates an instance of EventEmitter.\r\n\t *\r\n\t * @memberof EventEmitter\r\n\t */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n\t * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\t/**\r\n\t * Creates a new listener and adds it to the event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(new Listener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a listener for a given event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from an event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.getEvent(name);\r\n\r\n        if (callback) {\r\n            let i = 0,\r\n                len: number = event.size,\r\n                value: Listener;\r\n            let listener = new Listener({ name, callback, scope });\r\n            for (; i < len; i++) {\r\n                value = event.get(i);\r\n                console.log(value);\r\n                if (\r\n                    value.getCallback() === listener.getCallback() &&\r\n                    value.getScope() === listener.getScope()\r\n                )\r\n                    break;\r\n            }\r\n\r\n            event.delete(i);\r\n        }\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from a given event, or it just completely removes an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach((key) => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            if (_callback) {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a one time event listener for an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public once(\r\n        events: EventInput,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let onceFn: ListenerCallback = (...args) => {\r\n            this.off(events, onceFn, scope);\r\n            callback.apply(scope, args);\r\n        };\r\n\r\n        this.on(events, onceFn, scope);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call all listeners within an event\r\n\t *\r\n\t * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let listeners: Event = this.getEvent(event);\r\n\r\n            const customEvent: CustomEvent<any> = new CustomEvent(event, { detail: args })\r\n            window.dispatchEvent(customEvent);\r\n\r\n            listeners.forEach((listener: Listener) => {\r\n                let { callback, scope }: IListener = listener.toJSON();\r\n                callback.apply(scope, args);\r\n            });\r\n        }, this);\r\n        return this;\r\n    }\r\n}"],"names":["Manager","[object Object]","value","this","map","Map","key","get","keys","values","set","size","distance","last","delete","clear","has","entries","callback","args","context","forEach","Symbol","iterator","method","item","Listener","constructor","scope","name","listener","getCallback","getScope","getEventName","toJSON","Event","super","EventEmitter","getEvent","event","newListener","add","on","events","_name","_callback","_scope","split","Object","Array","isArray","removeListener","i","len","console","log","off","once","onceFn","apply","emit","listeners","customEvent","CustomEvent","detail","window","dispatchEvent"],"mappings":"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"}