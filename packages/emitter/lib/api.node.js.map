{
  "version": 3,
  "sources": ["../src/api.ts", "../../manager/src/api.ts", "../src/api.ts"],
  "sourcesContent": ["import { Manager } from \"@okikio/manager\";\r\n\r\nexport type ListenerCallback = ((...args: any) => void);\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n */\r\nexport const newListener = ({\r\n    callback = () => { },\r\n    scope = null,\r\n    name = \"event\",\r\n}: IListener): IListener => ({ callback, scope, name });\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, IListener> {\r\n    /**\r\n     * The name of the event\r\n     *\r\n     * @public\r\n     * @type string\r\n     * @memberof Event\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Creates an instance of Event.\r\n     *\r\n     * @param {string} [name=\"event\"]\r\n     * @memberof Event\r\n     */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n    /**\r\n     * Creates an instance of EventEmitter.\r\n     *\r\n     * @memberof EventEmitter\r\n     */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n    /**\r\n     * Creates a new listener and adds it to the event\r\n     *\r\n     * @param {string} name\r\n     * @param {ListenerCallback} callback\r\n     * @param {object} scope\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(newListener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback | object} callback\r\n     * @param {object} scope\r\n     * @returns EventEmitter\r\n     * @memberof EventEmitter\r\n     */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     *\r\n     * @param {string} name\r\n     * @param {ListenerCallback} [callback]\r\n     * @param {object} [scope]\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let listener = newListener({ name, callback, scope });\r\n\r\n            event.forEach((value: IListener, i: number) => {\r\n                if (\r\n                    value.callback === listener.callback &&\r\n                    value.scope === listener.scope\r\n                ) {\r\n                    return event.delete(i);\r\n                }\r\n            });\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from a given event, or it just completely removes an event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback | object} [callback]\r\n     * @param {object} [scope]\r\n     * @returns EventEmitter\r\n     * @memberof EventEmitter\r\n     */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            if (typeof _callback === \"function\") {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     *\r\n     * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n     * @returns EventEmitter\r\n     * @memberof EventEmitter\r\n     */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: IListener) => {\r\n                    let { callback, scope } = listener;\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default EventEmitter;\r\n", "/**\r\n * Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data.\r\n *\r\n * @export\r\n * @class Manager\r\n * @template K\r\n * @template V\r\n */\r\nexport class Manager<K, V> {\r\n\t/**\r\n\t * The complex list of named data, to which the Manager controls\r\n\t *\r\n\t * @public\r\n\t * @type Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic map: Map<K, V>;\r\n\r\n\t/**\r\n\t * Creates an instance of Manager.\r\n\t *\r\n\t * @param {Array<[K, V]>} [value]\r\n\t * @memberof Manager\r\n\t */\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Manager class's list\r\n\t *\r\n\t * @returns Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key to find in the Manager's list\r\n\t * @returns V\r\n\t */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the keys of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<K>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the values of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic values(): Array<V> {\r\n\t\treturn Array.from(this.map.values());\r\n\t}\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers\r\n\t *\r\n\t * @public\r\n\t * @param  {V} value\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\tlet size = this.size;\r\n\t\t// @ts-ignore\r\n\t\tlet num: K = size as K;\r\n\t\tthis.set(num, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total number of items stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns Number\r\n\t */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\tpublic get length(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the last item in the Manager who's index is a certain distance from the last item in the Manager\r\n\t *\r\n\t * @param {number} [distance=1]\r\n\t * @returns V | undefined\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key, returns true if an element in the Map object existed and has been removed, or false if the element does not exist.\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns boolean\r\n\t */\r\n\tpublic delete(key: K): boolean {\r\n\t\treturn this.map.delete(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key, returns the Manager class, allowing for chains\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic remove(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the Manager of all its contents\r\n\t *\r\n\t * @public\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the Manager contains a certain key\r\n\t *\r\n\t * @public\r\n\t * @param {K} key\r\n\t * @returns boolean\r\n\t */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.\r\n\t *\r\n\t * @public\r\n\t * @returns IterableIterator<[K, V]>\r\n\t */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates through the Managers contents, calling a callback function every iteration\r\n\t *\r\n\t * @param {*} [callback=(...args: any): void => { }]\r\n\t * @param {object} context\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic forEach(\r\n\t\tcallback: any = (...args: any): void => { },\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Allows iteration via the for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators]\r\n\t *\r\n\t * @returns IterableIterator<[K, V]>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\r\n\t\treturn this.entries();\r\n\t}\r\n}\r\n\r\n/**\r\n * Calls the method of a certain name for all items that are currently installed\r\n *\r\n * @param {Manager<any, any>} manager\r\n * @param {string} method\r\n * @param {Array<any>} [args=[]]\r\n */\r\nexport const methodCall = (manager: Manager<any, any>, method: string, ...args: any): void => {\r\n\tmanager.forEach((item) => {\r\n\t\t// @ts-ignore\r\n\t\titem[method](...args);\r\n\t});\r\n};\r\n\r\n/**\r\n * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n *\r\n * @param {Manager<any, any>} manager\r\n * @param {string} method\r\n * @param {Array<any>} [args=[]]\r\n */\r\nexport const asyncMethodCall = async (manager: Manager<any, any>, method: string, ...args: any): Promise<void> => {\r\n\tfor (let [, item] of manager) {\r\n\t\t// @ts-ignore\r\n\t\tawait item[method](...args);\r\n\t}\r\n};\r\n\r\nexport default Manager;\r\n", "import { Manager } from \"@okikio/manager\";\r\n\r\nexport type ListenerCallback = ((...args: any) => void);\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n */\r\nexport const newListener = ({\r\n    callback = () => { },\r\n    scope = null,\r\n    name = \"event\",\r\n}: IListener): IListener => ({ callback, scope, name });\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, IListener> {\r\n    /**\r\n     * The name of the event\r\n     *\r\n     * @public\r\n     * @type string\r\n     * @memberof Event\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Creates an instance of Event.\r\n     *\r\n     * @param {string} [name=\"event\"]\r\n     * @memberof Event\r\n     */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n    /**\r\n     * Creates an instance of EventEmitter.\r\n     *\r\n     * @memberof EventEmitter\r\n     */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n    /**\r\n     * Creates a new listener and adds it to the event\r\n     *\r\n     * @param {string} name\r\n     * @param {ListenerCallback} callback\r\n     * @param {object} scope\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(newListener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback | object} callback\r\n     * @param {object} scope\r\n     * @returns EventEmitter\r\n     * @memberof EventEmitter\r\n     */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     *\r\n     * @param {string} name\r\n     * @param {ListenerCallback} [callback]\r\n     * @param {object} [scope]\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let listener = newListener({ name, callback, scope });\r\n\r\n            event.forEach((value: IListener, i: number) => {\r\n                if (\r\n                    value.callback === listener.callback &&\r\n                    value.scope === listener.scope\r\n                ) {\r\n                    return event.delete(i);\r\n                }\r\n            });\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from a given event, or it just completely removes an event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback | object} [callback]\r\n     * @param {object} [scope]\r\n     * @returns EventEmitter\r\n     * @memberof EventEmitter\r\n     */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            if (typeof _callback === \"function\") {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     *\r\n     * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n     * @returns EventEmitter\r\n     * @memberof EventEmitter\r\n     */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: IListener) => {\r\n                    let { callback, scope } = listener;\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default EventEmitter;\r\n"],
  "mappings": "6HAAA,4ECAA,IAAA,QAwBC,eACC,KAAK,IAAM,GAAI,KAAI,GASb,SACN,MAAO,MAAK,IAUN,OACN,MAAO,MAAK,IAAI,IAAI,GASd,OACN,MAAO,OAAM,KAAK,KAAK,IAAI,QASrB,SACN,MAAO,OAAM,KAAK,KAAK,IAAI,UAWrB,SACN,YAAK,IAAI,IAAI,EAAK,GACX,KAUD,OACN,MAAW,KAAK,OAEH,EACb,YAAK,IAAI,EAAK,GACP,QASG,QACV,MAAO,MAAK,IAAI,QAGN,UACV,MAAO,MAAK,IAAI,KAUV,OAAwB,GAC9B,MAAU,KAAK,OAAO,KAAK,KAAO,GAClC,MAAO,MAAK,IAAI,GAUV,UACN,MAAO,MAAK,IAAI,OAAO,GAUjB,UACN,YAAK,IAAI,OAAO,GACT,KASD,QACN,YAAK,IAAI,QACF,KAUD,OACN,MAAO,MAAK,IAAI,IAAI,GASd,UACN,MAAO,MAAK,IAAI,UAWV,UACU,cAGhB,YAAK,IAAI,QAAQ,EAAU,GACpB,MASA,OAAO,YACd,MAAO,MAAK,YC3LD,EAAc,EACvB,WAAW,OACX,QAAQ,KACR,OAAO,WACkB,EAAE,WAAU,QAAO,WAlBhD,aA2B2B,GAgBvB,cAA2B,SACvB,QACA,KAAK,KAAO,MA7CpB,aA0DkC,GAM9B,cACI,QAUG,YACH,MAAY,KAAK,IAAI,GACrB,MAAM,aAAiB,GAKhB,EAJH,MAAK,IAAI,EAAM,GAAI,GAAM,IAClB,KAAK,IAAI,IAcjB,mBAKH,MAAY,KAAK,SAAS,GAC1B,SAAM,IAAI,EAAY,CAAE,OAAM,WAAU,WACjC,EAYJ,UAMH,GAAI,MAAO,IAAU,YAAa,MAAO,MAGzC,AAAI,MAAO,IAAU,UAAU,GAAS,EAAO,OAAO,MAAM,QAE5D,UAEe,MAAO,IAAU,UAAY,CAAC,MAAM,QAAQ,KAEtC,EAAW,EAAW,EAC3C,MAAK,IAAU,GAAa,GAG5B,OAAO,KAAK,GAAQ,QAAQ,IAKxB,AAAI,EACA,GAAQ,EACR,EAAY,EAAO,IAEnB,EAAQ,EAAO,GAGnB,KAAK,YAAY,EAAO,EAAW,IACpC,MACI,KAYJ,sBAKH,MAAmB,KAAK,IAAI,GAC5B,GAAI,YAAiB,IAAS,GAC1B,MAAe,EAAY,CAAE,OAAM,WAAU,UAE7C,EAAM,QAAQ,QACV,GACI,EAAM,WAAa,EAAS,UAC5B,EAAM,QAAU,EAAS,MAEzB,MAAO,GAAM,OAAO,KAKhC,MAAO,GAYJ,WAMH,GAAI,MAAO,IAAU,YAAa,MAAO,MAGzC,AAAI,MAAO,IAAU,UAAU,GAAS,EAAO,OAAO,MAAM,QAE5D,UAEe,MAAO,IAAU,UAAY,CAAC,MAAM,QAAQ,KAEtC,EAAW,EAAW,EAC3C,MAAK,IAAU,GAAa,GAG5B,OAAO,KAAK,GAAQ,QAAQ,IAKxB,AAAI,EACA,GAAQ,EACR,EAAY,EAAO,IAEnB,EAAQ,EAAO,GAGnB,AAAI,MAAO,IAAc,WACrB,KAAK,eAAe,EAAO,EAAW,GACnC,KAAK,OAAO,IACpB,MACI,KAWJ,aAKH,MAAI,OAAO,IAAU,YAAoB,KAGzC,CAAI,MAAO,IAAU,UAAU,GAAS,EAAO,OAAO,MAAM,QAG5D,EAAO,QAAQ,IACX,MAAoB,KAAK,IAAI,GAE7B,AAAI,YAAkB,IAClB,EAAO,QAAQ,IACX,IAAM,WAAU,SAAU,EAC1B,EAAS,MAAM,EAAO,MAG/B,MACI,UAIA",
  "names": []
}
