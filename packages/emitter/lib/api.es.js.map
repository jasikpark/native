{
  "version": 3,
  "sources": ["../../manager/src/api.ts", "../src/api.ts"],
  "sourcesContent": ["/** Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data */\nexport class Manager<K, V> {\n\t/** The complex list of named data, to which the Manager controls */\n\tpublic map: Map<K, V>;\n\tconstructor(value?: Array<[K, V]>) {\n\t\tthis.map = new Map(value);\n\t}\n\n\t/** Returns the Manager classes base Map */\n\tpublic getMap(): Map<K, V> {\n\t\treturn this.map;\n\t}\n\n\t/** Get a value stored in the Manager */\n\tpublic get(key: K): V {\n\t\treturn this.map.get(key);\n\t}\n\n\t/** Returns the keys of all items stored in the Manager as an Array */\n\tpublic keys(): Array<K> {\n\t\treturn Array.from(this.map.keys());\n\t}\n\n\t/** Returns the values of all items stored in the Manager as an Array */\n\tpublic values(): Array<V> {\n\t\treturn Array.from(this.map.values());\n\t}\n\n\t/** Set a value to the Manager using a key */\n\tpublic set(key: K, value: V): Manager<K, V> {\n\t\tthis.map.set(key, value);\n\t\treturn this;\n\t}\n\n\t/** Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers */\n\tpublic add(value: V): Manager<K, V> {\n\t\tlet size = this.size;\n\t\t// @ts-ignore\n\t\tlet num: K = size as K;\n\t\tthis.set(num, value);\n\t\treturn this;\n\t}\n\n\t/** Returns the total number of items stored in the Manager */\n\tpublic get size(): number {\n\t\treturn this.map.size;\n\t}\n\n\t/** An alias for size */\n\tpublic get length(): number {\n\t\treturn this.map.size;\n\t}\n\n\t/** Returns the last item in the Manager who's index is a certain distance from the last item in the Manager */\n\tpublic last(distance: number = 1): V | undefined {\n\t\tlet key = this.keys()[this.size - distance];\n\t\treturn this.get(key);\n\t}\n\n\t/** Removes a value stored in the Manager via a key, returns true if an element in the Map object existed and has been removed, or false if the element does not exist */\n\tpublic delete(key: K): boolean {\n\t\treturn this.map.delete(key);\n\t}\n\n\t/** Removes a value stored in the Manager via a key, returns the Manager class, allowing for chains */\n\tpublic remove(key: K): Manager<K, V> {\n\t\tthis.map.delete(key);\n\t\treturn this;\n\t}\n\n\t/** Clear the Manager of all its contents */\n\tpublic clear(): Manager<K, V> {\n\t\tthis.map.clear();\n\t\treturn this;\n\t}\n\n\t/** Checks if the Manager contains a certain key */\n\tpublic has(key: K): boolean {\n\t\treturn this.map.has(key);\n\t}\n\n\t/** Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order. */\n\tpublic entries(): IterableIterator<[K, V]> {\n\t\treturn this.map.entries();\n\t}\n\n\t/** Iterates through the Managers contents, calling a callback function every iteration */\n\tpublic forEach(\n\t\tcallback: (value?: V, key?: K, map?: Map<K, V>) => void,\n\t\tcontext?: object\n\t): Manager<K, V> {\n\t\tthis.map.forEach(callback, context);\n\t\treturn this;\n\t}\n\n\t/** Allows for iteration via for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators] */\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n}\n\n/**\n * Calls the method of a certain name for all items that are currently installed\n */\nexport const methodCall = (manager: Manager<any, any>, method: string, ...args: any): void => {\n\tmanager.forEach((item) => {\n\t\t// @ts-ignore\n\t\titem[method](...args);\n\t});\n};\n\n/**\n * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\n */\nexport const asyncMethodCall = async (manager: Manager<any, any>, method: string, ...args: any): Promise<void> => {\n\tfor (let [, item] of manager) {\n\t\t// @ts-ignore\n\t\tawait item[method](...args);\n\t}\n};\n\nexport default Manager;\n", "import { Manager, methodCall } from \"@okikio/manager\";\n\nexport type ListenerCallback = ((...args: any) => void);\nexport interface IListener {\n    readonly callback: ListenerCallback;\n    readonly scope: object;\n    readonly name: string;\n}\n\n/** Represents a new event listener consisting of properties like: callback, scope, name */\nexport const newListener = ({\n    callback = () => { },\n    scope = null,\n    name = \"event\",\n}: IListener): IListener => ({ callback, scope, name });\n\n/** Represents a new event  */\nexport class Event extends Manager<number, IListener> {\n    /** The name of the event */\n    public name: string;\n    constructor(name: string = \"event\") {\n        super();\n        this.name = name;\n    }\n}\n\nexport type EventInput = string | object | Array<string>;\n\n/**\n * An Event Emitter\n * */\nexport class EventEmitter extends Manager<string, Event> {\n    constructor() {\n        super();\n    }\n\n    /** Gets event, if event doesn't exist create a new one */\n    public getEvent(name: string): Event {\n        let event = this.get(name);\n        if (!(event instanceof Event)) {\n            this.set(name, new Event(name));\n            return this.get(name);\n        }\n\n        return event;\n    }\n\n    /** Creates a listener and adds it to an event */\n    public newListener(\n        name: string,\n        callback: ListenerCallback,\n        scope: object\n    ): Event {\n        let event = this.getEvent(name);\n        event.add(newListener({ name, callback, scope }));\n        return event;\n    }\n\n    /** Adds a listener to a given event */\n    public on(\n        events: EventInput,\n        callback?: ListenerCallback | object,\n        scope?: object\n    ): EventEmitter {\n        // If there is no event break\n        if (typeof events == \"undefined\") return this;\n\n        // Create a new event every space\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\n\n        let _name: string;\n        let _callback: ListenerCallback;\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\n\n        let _scope: object = isObject ? callback : scope;\n        if (!isObject) _callback = (callback as ListenerCallback);\n\n        // Loop through the list of events\n        Object.keys(events).forEach(key => {\n            // Select the name of the event from the list\n            // Remember events can be {String | Object | Array<string>}\n\n            // Check If events is an Object (JSON like Object, and not an Array)\n            if (isObject) {\n                _name = key;\n                _callback = events[key];\n            } else {\n                _name = events[key];\n            }\n\n            this.newListener(_name, _callback, _scope);\n        }, this);\n        return this;\n    }\n\n    /** Removes a listener from an event */\n    public removeListener(\n        name: string,\n        callback: ListenerCallback,\n        scope: object\n    ): Event {\n        let event: Event = this.get(name);\n        if (event instanceof Event && callback) {\n            let listener = newListener({ name, callback, scope });\n\n            event.forEach((value: IListener, i: number) => {\n                if (\n                    value.callback === listener.callback &&\n                    value.scope === listener.scope\n                ) {\n                    return event.remove(i);\n                }\n            });\n        }\n\n        return event;\n    }\n\n    /** Remove a listener from a given event, or just completely remove an event */\n    public off(\n        events: EventInput,\n        callback?: ListenerCallback | object,\n        scope?: object\n    ): EventEmitter {\n        // If there is no event break\n        if (typeof events == \"undefined\") return this;\n\n        // Create a new event every space\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\n\n        let _name: string;\n        let _callback: ListenerCallback;\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\n\n        let _scope: object = isObject ? callback : scope;\n        if (!isObject) _callback = (callback as ListenerCallback);\n\n        // Loop through the list of events\n        Object.keys(events).forEach(key => {\n            // Select the name of the event from the list\n            // Remember events can be {String | Object | Array<any>}\n\n            // Check If events is an Object (JSON like Object, and not an Array)\n            if (isObject) {\n                _name = key;\n                _callback = events[key];\n            } else {\n                _name = events[key];\n            }\n\n            if (typeof _callback === \"function\") {\n                this.removeListener(_name, _callback, _scope);\n            } else this.remove(_name);\n        }, this);\n        return this;\n    }\n\n    /** Call all listeners within an event */\n    public emit(\n        events: string | Array<any>,\n        ...args: any\n    ): EventEmitter {\n        // If there is no event break\n        if (typeof events == \"undefined\") return this;\n\n        // Create a new event every space\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\n\n        // Loop through the list of events\n        events.forEach((event: string) => {\n            let _event: Event = this.get(event);\n\n            if (_event instanceof Event) {\n                _event.forEach((listener: IListener) => {\n                    let { callback, scope } = listener;\n                    callback.apply(scope, args);\n                });\n            }\n        }, this);\n        return this;\n    }\n\n    /** Clears events and event listeners */\n    public clear() {\n        methodCall(this, \"clear\");\n        super.clear();\n        return this;\n    }\n}\n\nexport default EventEmitter;\n"],
  "mappings": "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",
  "names": []
}
