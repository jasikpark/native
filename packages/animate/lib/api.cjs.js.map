{
  "version": 3,
  "sources": ["../src/api.ts", "../../manager/src/api.ts", "../../emitter/src/api.ts"],
  "sourcesContent": ["import { EventEmitter, EventInput, ListenerCallback } from \"@okikio/emitter\";\r\nimport { Manager } from \"@okikio/manager\";\r\n\r\n// DOM\r\nexport type AnimationTarget = string | Node | NodeList | HTMLCollection | HTMLElement[] | AnimationTarget[];\r\nexport const getElements = (selector: string | Node): Node[] => {\r\n    return typeof selector === \"string\" ? Array.from(document.querySelectorAll(selector as string)) : [selector];\r\n};\r\n\r\nconst flatten = (arr: AnimationTarget[]) => [].concat(...arr);\r\nexport const getTargets = (targets: AnimationTarget): Node[] => {\r\n    if (Array.isArray(targets)) {\r\n        return flatten((targets as AnimationTarget[]).map(getTargets));\r\n    }\r\n    if (typeof targets == \"string\" || targets instanceof Node)\r\n        return getElements(targets);\r\n    if (targets instanceof NodeList || targets instanceof HTMLCollection)\r\n        return Array.from(targets);\r\n    return [];\r\n};\r\n\r\n// VALUES\r\nexport type closureArgs = [number, number, HTMLElement];\r\nexport type closure = ((index?: number, total?: number, element?: HTMLElement) => any) | any;\r\nexport const computeValue = (value: closure, args: closureArgs, context: AnimationOptions) => {\r\n    if (typeof value === \"function\") {\r\n        return value.apply(context, args);\r\n    } else { return value; }\r\n};\r\n\r\nexport const mapObject = (obj: object, args: closureArgs, options: AnimationOptions): any => {\r\n    let key: string, value: any, result = {};\r\n    let keys = Object.keys(obj);\r\n    for (let i = 0, len = keys.length; i < len; i++) {\r\n        key = keys[i];\r\n        value = obj[key];\r\n        result[key] = computeValue(value, args, options);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/** From: [https://easings.net] */\r\nexport const easings = {\r\n    \"in\": \"ease-in\",\r\n    \"out\": \"ease-out\",\r\n    \"in-out\": \"ease-in-out\",\r\n\r\n    // Sine\r\n    \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n    \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n    \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n\r\n    // Quad\r\n    \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n    \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n    \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n\r\n    // Cubic\r\n    \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n    \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n    \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n\r\n    // Quart\r\n    \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n    \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n    \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n\r\n    // Quint\r\n    \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n    \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n    \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n\r\n    // Expo\r\n    \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n    \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n    \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n\r\n    // Circ\r\n    \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n    \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n    \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n\r\n    // Back\r\n    \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n    \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n    \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n};\r\n\r\nexport const getEase = (ease: string) => {\r\n    return /^(in|out)/.test(ease) ? easings[ease] : ease;\r\n};\r\n\r\nexport interface AnimationOptions {\r\n    target?: AnimationTarget,\r\n\r\n    speed?: number,\r\n    autoplay?: boolean,\r\n    options?: AnimationOptions,\r\n    delay?: number | closure,\r\n    easing?: string | closure,\r\n    endDelay?: number | closure,\r\n    duration?: number | closure,\r\n    keyframes?: object[] | closure,\r\n    loop?: number | boolean | closure, // iterations: number,\r\n    onfinish?: (element?: HTMLElement, index?: number, total?: number, animation?: Animation) => any,\r\n    fillMode?: \"none\" | \"forwards\" | \"backwards\" | \"both\" | \"auto\" | closure,\r\n    direction?: \"normal\" | \"reverse\" | \"alternate\" | \"alternate-reverse\" | closure,\r\n    extend?: EffectTiming,\r\n    [property: string]: closure | boolean | object | string | string[] | number | null | (number | null)[] | undefined;\r\n};\r\n\r\nexport const DefaultAnimationOptions: AnimationOptions = {\r\n    keyframes: [],\r\n\r\n    loop: 1, // iterations: number,\r\n    delay: 0,\r\n    speed: 1,\r\n    endDelay: 0,\r\n    easing: \"ease\",\r\n    autoplay: true,\r\n    duration: 1000,\r\n    fillMode: \"auto\",\r\n    direction: \"normal\",\r\n    extend: {}\r\n};\r\n\r\nexport type AnimationEvents = \"update\" | \"play\" | \"pause\" | \"start\" | \"begin\" | \"complete\" | \"finish\" | \"error\" | \"stop\";\r\n\r\n/** You can check it out here: https://codepen.io/okikio/pen/qBbdGaW?editors=0011 */\r\nexport class Animate {\r\n    /**\r\n     * Stores the options for the current animation\r\n     */\r\n    public options: AnimationOptions = {};\r\n\r\n    /**\r\n     * The Array of Elements to Animate\r\n     */\r\n    public targets: Node[] = [];\r\n\r\n    /**\r\n     * The properties to animate\r\n     */\r\n    public properties: object = {};\r\n\r\n    /**\r\n     * A Manager of Animations\r\n     */\r\n    public animations: Manager<HTMLElement, Animation> = new Manager();\r\n\r\n    /**\r\n     * The total duration of all Animation's\r\n     */\r\n    public totalDuration: number = 0;\r\n\r\n    /**\r\n     * The smallest delay out of all Animation's\r\n     */\r\n    public minDelay: number = 0;\r\n\r\n    /**\r\n     * The options for individual animations\r\n     */\r\n    public computedOptions: Manager<Animation, AnimationOptions> = new Manager();\r\n\r\n    /**\r\n     * The Element the main animation uses\r\n     */\r\n    public mainElement: HTMLElement;\r\n\r\n    /**\r\n     * Stores an animation that runs on the total duration of the all other Animations, and as such it's the main Animation\r\n     */\r\n    public mainAnimation: Animation;\r\n\r\n    /**\r\n     * Stores request frame calls\r\n     */\r\n    public animationFrame: number;\r\n\r\n    /**\r\n     * An event emitter\r\n     */\r\n    public emitter: EventEmitter = new EventEmitter();\r\n\r\n    /**\r\n     * Returns a promise that is fulfilled when the mainAnimation is finished\r\n     */\r\n    public promise: Promise<AnimationOptions>;\r\n    constructor(options: AnimationOptions = {}) {\r\n        try {\r\n            let { options: animation, ...rest } = options;\r\n            let oldOptions = animation instanceof Animate ? animation.getOptions() : (Array.isArray(animation) ? animation?.[0]?.getOptions() : animation);\r\n            this.options = Object.assign({}, DefaultAnimationOptions, oldOptions, rest);\r\n            this.loop = this.loop.bind(this);\r\n\r\n            let {\r\n                loop,\r\n                delay,\r\n                speed,\r\n                easing,\r\n                endDelay,\r\n                duration,\r\n                direction,\r\n                fillMode,\r\n                onfinish,\r\n                target,\r\n                keyframes,\r\n                autoplay,\r\n                extend,\r\n                ...properties\r\n            } = this.options;\r\n\r\n            this.mainElement = document.createElement(\"div\");\r\n            this.targets = getTargets(target);\r\n            this.properties = properties;\r\n\r\n            let delays = [];\r\n            let len = this.targets.length;\r\n            let animationKeyframe: Keyframe[] | PropertyIndexedKeyframes;\r\n            for (let i = 0; i < len; i++) {\r\n                let target = this.targets[i] as HTMLElement;\r\n                let animationOptions: AnimationOptions = {\r\n                    easing: typeof easing == \"string\" ? getEase(easing) : easing,\r\n                    iterations: loop === true ? Infinity : (loop as number),\r\n                    direction,\r\n                    endDelay,\r\n                    duration,\r\n                    delay,\r\n                    fill: fillMode,\r\n                    ...extend\r\n                };\r\n\r\n                // Accept keyframes as a keyframes Object, or a method,\r\n                // if there are no animations in the keyframes array,\r\n                // uses css properties from the options object\r\n                let arrKeyframes = computeValue((keyframes as Keyframe[]), [i, len, target], animationOptions);\r\n                animationKeyframe = arrKeyframes.length ? arrKeyframes :\r\n                    (this.properties as PropertyIndexedKeyframes);\r\n\r\n                // Allows the use of functions as the values, for both the keyframes and the animation object\r\n                // It adds the capability of advanced stagger animation, similar to the anime js stagger functions\r\n                animationOptions = mapObject(animationOptions, [i, len, target], animationOptions);\r\n                if (!(arrKeyframes.length > 0))\r\n                    animationKeyframe = mapObject(animationKeyframe, [i, len, target], animationOptions);\r\n\r\n                // Set the Animate classes duration to be the Animation with the largest totalDuration\r\n                let tempDurations = animationOptions.delay +\r\n                    (animationOptions.duration * animationOptions.iterations) +\r\n                    animationOptions.endDelay;\r\n                if (this.totalDuration < tempDurations) this.totalDuration = tempDurations;\r\n\r\n                // Add animation to the Animations Set\r\n                let animation = target.animate(animationKeyframe, animationOptions);\r\n\r\n                // Support for on finish\r\n                animation.onfinish = () => {\r\n                    typeof onfinish == \"function\" && onfinish.call(this, target, i, len, animation);\r\n                    this.emit(\"finish\", target, i, len, animation);\r\n                };\r\n\r\n                // The calculated options for each individual option\r\n                this.computedOptions.set(animation, animationOptions);\r\n                this.animations.set(target, animation);\r\n                delays.push(animationOptions.delay);\r\n            }\r\n\r\n            this.mainAnimation = this.mainElement.animate([\r\n                { opacity: \"0\" },\r\n                { opacity: \"1\" }\r\n            ], {\r\n                // Why waste performance on an animation no one can see?\r\n                duration: this.totalDuration,\r\n                easing: \"linear\"\r\n            });\r\n\r\n            this.minDelay = Math.min(...delays);\r\n            this.setSpeed(speed);\r\n            if (autoplay) this.play();\r\n            else this.pause();\r\n\r\n            this.promise = this.newPromise();\r\n            this.mainAnimation.onfinish = () => {\r\n                this.emit(\"complete\", this);\r\n                window.cancelAnimationFrame(this.animationFrame);\r\n            };\r\n        } catch (err) {\r\n            this.emit(\"error\", err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new Promise that is resolve when this.finish is called\r\n     */\r\n    public newPromise(): Promise<AnimationOptions> {\r\n        return new Promise((resolve, reject) => {\r\n            /*\r\n                Note that the `this` keyword is in an Array when it is resolved,\r\n                this is due to Promises not wanting to resolve references,\r\n                so, you can't resolve `this` directly, so, I chose to resolve `this` in an\r\n                Array\r\n            */\r\n            this.on(\"complete\", () => resolve([this]));\r\n            this.on(\"error\", err => reject(err));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fulfills the this.promise Promise\r\n     */\r\n    public then(\r\n        onFulfilled?: (value?: any) => any,\r\n        onRejected?: (reason?: any) => any\r\n    ): Animate {\r\n        onFulfilled = onFulfilled?.bind(this);\r\n        onRejected = onRejected?.bind(this);\r\n        this.promise.then(onFulfilled, onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Catches error that occur in the this.promise Promise\r\n     */\r\n    public catch(onRejected: (reason?: any) => any): Animate {\r\n        onRejected = onRejected?.bind(this);\r\n        this.promise.catch(onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * If you don't care if the this.promise Promise has either been rejected or resolved\r\n     */\r\n    public finally(onFinally: () => any): Animate {\r\n        onFinally = onFinally?.bind(this);\r\n        this.promise.finally(onFinally);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Represents an Animation Frame Loop\r\n     */\r\n    public loop(): void {\r\n        this.animationFrame = window.requestAnimationFrame(this.loop);\r\n        this.emit(\"update\", this.getProgress(), this);\r\n    }\r\n\r\n    /**\r\n     * Calls a method that affects all animations including the mainAnimation; the method only allows the animation parameter\r\n    */\r\n    public all(method: (animation: Animation) => void) {\r\n        method(this.mainAnimation);\r\n        this.animations.forEach(animation => method(animation));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register the begin event\r\n     */\r\n    protected beginEvent() {\r\n        if (this.getProgress() == 0) {\r\n            let timer: number | void = window.setTimeout(() => {\r\n                this.emit(\"begin\", this);\r\n                timer = window.clearTimeout(timer as number);\r\n            }, this.minDelay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Play Animation\r\n     */\r\n    public play(): Animate {\r\n        let playstate = this.getPlayState();\r\n        if (playstate !== \"finished\") {\r\n            this.beginEvent();\r\n            this.animationFrame = requestAnimationFrame(this.loop);\r\n            this.all(anim => anim.playState == \"paused\" && anim.play());\r\n            this.emit(\"play\", playstate, this);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause Animation\r\n     */\r\n    public pause(): Animate {\r\n        let playstate = this.getPlayState();\r\n        if (playstate !== \"finished\") {\r\n            this.all(anim => anim.playState == \"running\" && anim.pause());\r\n            window.cancelAnimationFrame(this.animationFrame);\r\n            this.emit(\"pause\", playstate, this);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all Animations\r\n     */\r\n    public reset() {\r\n        this.setProgress(0);\r\n        this.beginEvent();\r\n\r\n        if (this.options.autoplay) this.play();\r\n        else this.pause();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels all Animations\r\n     */\r\n    public cancel() {\r\n        this.all(anim => anim.cancel());\r\n        window.cancelAnimationFrame(this.animationFrame);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force complete all Animations\r\n     */\r\n    public finish() {\r\n        this.all(anim => anim.finish());\r\n        window.cancelAnimationFrame(this.animationFrame);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels & Clears all Animations\r\n     */\r\n    public stop() {\r\n        this.cancel();\r\n        this.animations.clear();\r\n        while (this.targets.length) this.targets.pop();\r\n        this.mainElement = undefined;\r\n        this.emit(\"stop\");\r\n    }\r\n\r\n    /**\r\n     * Returns an Array of targets\r\n     */\r\n    public getTargets(): Node[] {\r\n        return this.targets;\r\n    }\r\n\r\n    /**\r\n     * Get a specific Animation from an Animate instance\r\n     */\r\n    public getAnimation(element: HTMLElement): Animation {\r\n        return this.animations.get(element);\r\n    }\r\n\r\n    /**\r\n     * Returns the timings of an Animation, given a target\r\n     * E.g. { duration, endDelay, delay, iterations, iterationStart, direction, easing, fill, etc... }\r\n     */\r\n    public getTiming(target: HTMLElement | Animation): AnimationOptions & EffectTiming {\r\n        let animation = target instanceof Animation ? target : this.getAnimation(target);\r\n        let keyframeOptions = this.computedOptions.get(animation) ?? {};\r\n        let timings = animation.effect?.getTiming() ?? {};\r\n        let options = this.getOptions();\r\n\r\n        return { ...DefaultAnimationOptions, ...options, ...timings, ...keyframeOptions };\r\n    }\r\n\r\n    /**\r\n     * Returns the total duration of Animation\r\n     */\r\n    public getTotalDuration(): number {\r\n        return this.totalDuration;\r\n    }\r\n\r\n    /**\r\n     * Returns the current time of the Main Animation\r\n     */\r\n    public getCurrentTime(): number {\r\n        return this.mainAnimation.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Returns the Animation progress as a fraction of the current time / duration * 100\r\n     */\r\n    public getProgress() {\r\n        return (this.getCurrentTime() / this.totalDuration) * 100;\r\n    }\r\n\r\n    /**\r\n     * Return the playback speed of the animation\r\n     */\r\n    public getSpeed(): number {\r\n        return this.mainAnimation.playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Returns the current playing state\r\n     */\r\n    public getPlayState(): \"idle\" | \"running\" | \"paused\" | \"finished\" {\r\n        return this.mainAnimation.playState;\r\n    }\r\n\r\n    /**\r\n     * Get the options of an Animate instance\r\n     */\r\n    public getOptions(): AnimationOptions {\r\n        return this.options;\r\n    }\r\n\r\n    /**\r\n     * Set the current time of the Main Animation\r\n     */\r\n    public setCurrentTime(time: number): Animate {\r\n        this.all(anim => { anim.currentTime = time; });\r\n        this.emit(\"update\", this.getProgress());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the Animation progress as a value from 0 to 100\r\n     */\r\n    public setProgress(percent: number): Animate {\r\n        let time = (percent / 100) * this.totalDuration;\r\n        this.setCurrentTime(time);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the playback speed of an Animation\r\n     */\r\n    public setSpeed(speed: number = 1): Animate {\r\n        this.all(anim => { anim.playbackRate = speed; });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     */\r\n    public on(events: AnimationEvents | EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.on(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     */\r\n    public off(events: AnimationEvents | EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.off(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     */\r\n    public emit(events: AnimationEvents | string | any[], ...args: any): Animate {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n\r\n\r\n    /** Returns the Animate options, as JSON  */\r\n    public toJSON(): AnimationOptions {\r\n        return this.getOptions();\r\n    }\r\n\r\n    /**\r\n     * The Symbol.toStringTag well-known symbol is a string valued property that is used\r\n     * in the creation of the default string description of an object.\r\n     * It is accessed internally by the Object.prototype.toString() method.\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return `Animate`;\r\n    }\r\n}\r\n\r\n/** Creates a new Animate instance */\r\nexport const animate = (options: AnimationOptions = {}): Animate => {\r\n    return new Animate(options);\r\n};\r\n\r\nexport default animate;\r\n", "/** Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data */\r\nexport class Manager<K, V> {\r\n\t/** The complex list of named data, to which the Manager controls */\r\n\tpublic map: Map<K, V>;\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/** Returns the Manager classes base Map */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/** Get a value stored in the Manager */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/** Returns the keys of all items stored in the Manager as an Array */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\t/** Returns the values of all items stored in the Manager as an Array */\r\n\tpublic values(): Array<V> {\r\n\t\treturn Array.from(this.map.values());\r\n\t}\r\n\r\n\t/** Set a value to the Manager using a key */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\tlet size = this.size;\r\n\t\t// @ts-ignore\r\n\t\tlet num: K = size as K;\r\n\t\tthis.set(num, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Returns the total number of items stored in the Manager */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** An alias for size */\r\n\tpublic get length(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** Returns the last item in the Manager who's index is a certain distance from the last item in the Manager */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns true if an element in the Map object existed and has been removed, or false if the element does not exist */\r\n\tpublic delete(key: K): boolean {\r\n\t\treturn this.map.delete(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns the Manager class, allowing for chains */\r\n\tpublic remove(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Clear the Manager of all its contents */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Checks if the Manager contains a certain key */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/** Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order. */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/** Iterates through the Managers contents, calling a callback function every iteration */\r\n\tpublic forEach(\r\n\t\tcallback: (value?: V, key?: K, map?: Map<K, V>) => void,\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Allows for iteration via for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators] */\r\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\r\n\t\treturn this.entries();\r\n\t}\r\n}\r\n\r\n/**\r\n * Calls the method of a certain name for all items that are currently installed\r\n */\r\nexport const methodCall = (manager: Manager<any, any>, method: string, ...args: any): void => {\r\n\tmanager.forEach((item) => {\r\n\t\t// @ts-ignore\r\n\t\titem[method](...args);\r\n\t});\r\n};\r\n\r\n/**\r\n * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n */\r\nexport const asyncMethodCall = async (manager: Manager<any, any>, method: string, ...args: any): Promise<void> => {\r\n\tfor (let [, item] of manager) {\r\n\t\t// @ts-ignore\r\n\t\tawait item[method](...args);\r\n\t}\r\n};\r\n\r\nexport default Manager;\r\n", "import { Manager, methodCall } from \"@okikio/manager\";\r\n\r\nexport type ListenerCallback = ((...args: any) => void);\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/** Represents a new event listener consisting of properties like: callback, scope, name */\r\nexport const newListener = ({\r\n    callback = () => { },\r\n    scope = null,\r\n    name = \"event\",\r\n}: IListener): IListener => ({ callback, scope, name });\r\n\r\n/** Represents a new event  */\r\nexport class Event extends Manager<number, IListener> {\r\n    /** The name of the event */\r\n    public name: string;\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An Event Emitter\r\n * */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /** Gets event, if event doesn't exist create a new one */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Creates a listener and adds it to an event */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(newListener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n    /** Adds a listener to a given event */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Removes a listener from an event */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let listener = newListener({ name, callback, scope });\r\n\r\n            event.forEach((value: IListener, i: number) => {\r\n                if (\r\n                    value.callback === listener.callback &&\r\n                    value.scope === listener.scope\r\n                ) {\r\n                    return event.remove(i);\r\n                }\r\n            });\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Remove a listener from a given event, or just completely remove an event */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            if (typeof _callback === \"function\") {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.remove(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Call all listeners within an event */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: IListener) => {\r\n                    let { callback, scope } = listener;\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Clears events and event listeners */\r\n    public clear() {\r\n        methodCall(this, \"clear\");\r\n        super.clear();\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default EventEmitter;\r\n"],
  "mappings": "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",
  "names": []
}
