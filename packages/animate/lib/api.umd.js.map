{"version":3,"file":"api.umd.js","sources":["../../manager/src/api.ts","../../emitter/src/api.ts","../src/api.ts"],"sourcesContent":["/**\r\n * Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data.\r\n *\r\n * @export\r\n * @class Manager\r\n * @template K\r\n * @template V\r\n */\r\nexport class Manager<K, V> {\r\n\t/**\r\n\t * The complex list of named data, to which the Manager controls\r\n\t *\r\n\t * @protected\r\n\t * @type Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tprotected map: Map<K, V>;\r\n\r\n    /**\r\n     * Creates an instance of Manager.\r\n     * \r\n     * @param {Array<[K, V]>} [value]\r\n     * @memberof Manager\r\n     */\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Manager class's list\r\n\t *\r\n\t * @returns Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key to find in the Manager's list\r\n\t * @returns V\r\n\t */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the keys of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<K>\r\n     * @memberof Manager\r\n     */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the values of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<V>\r\n     * @memberof Manager\r\n\t */\r\n\tpublic values(): Array<V> {\r\n\t\treturn Array.from(this.map.values());\r\n\t}\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers\r\n     *\r\n     * @public\r\n     * @param  {V} value\r\n     * @returns Manager<K, V>\r\n     */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\tlet size = this.size;\r\n\t\t// @ts-ignore\r\n\t\tlet num: K = size as K;\r\n\t\tthis.set(num, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total number of items stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns Number\r\n\t */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n    /**\r\n\t * Returns the last item in the Manager who's index is a certain distance from the last item in the Manager\r\n     *\r\n     * @param {number} [distance=1]\r\n     * @returns V | undefined\r\n     * @memberof Manager\r\n     */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the second last item in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns V\r\n\t */\r\n\tpublic prev(): V {\r\n\t\treturn this.last(2);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic delete(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the Manager of all its contents\r\n\t *\r\n\t * @public\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the Manager contains a certain key\r\n\t *\r\n\t * @public\r\n\t * @param {K} key\r\n\t * @returns boolean\r\n\t */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.\r\n\t *\r\n\t * @public\r\n\t * @returns IterableIterator<[K, V]>\r\n\t */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates through the Managers contents, calling a callback function every iteration\r\n\t *\r\n\t * @param {*} [callback=(...args: any): void => { }]\r\n\t * @param {object} context\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic forEach(\r\n\t\tcallback: any = (...args: any): void => { },\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Allows iteration via the for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators]\r\n     *\r\n     * @returns IterableIterator<[K, V]>\r\n     * @memberof Manager\r\n     */\r\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\r\n\t\treturn this.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the method of a certain name for all items that are currently installed\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic methodCall(method: string, ...args: any): Manager<K, V> {\r\n\t\tthis.forEach((item: V) => {\r\n\t\t\t// @ts-ignore\r\n\t\t\titem[method](...args);\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Promise<Manager<K, V>>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic async asyncMethodCall(method: string, ...args: any): Promise<Manager<K, V>> {\r\n\t\tfor (let [, item] of this.map) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tawait item[method](...args);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nexport default Manager;","import { Manager } from \"@okikio/manager\";\r\n\r\nexport type ListenerCallback = ((...args: any) => void);\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Listener\r\n */\r\nexport class Listener {\r\n\t/**\r\n\t * The current listener data\r\n\t *\r\n\t * @private\r\n\t * @type IListener\r\n\t * @memberof Listener\r\n\t */\r\n    private listener: IListener;\r\n\r\n\t/**\r\n\t * Creates an instance of Listener.\r\n\t *\r\n\t * @param {IListener} { callback = () => { }, scope = null, name = \"event\" }\r\n\t * @memberof Listener\r\n\t */\r\n    constructor({\r\n        callback = () => { },\r\n        scope = null,\r\n        name = \"event\",\r\n    }: IListener) {\r\n        this.listener = { callback, scope, name };\r\n    }\r\n\r\n\t/**\r\n\t * Returns the callback Function of the Listener\r\n\t *\r\n\t * @returns ListenerCallback\r\n\t * @memberof Listener\r\n\t */\r\n    public getCallback(): ListenerCallback {\r\n        return this.listener.callback;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the scope as an Object, from the Listener\r\n\t *\r\n\t * @returns object\r\n\t * @memberof Listener\r\n\t */\r\n    public getScope(): object {\r\n        return this.listener.scope;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the event as a String, from the Listener\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Listener\r\n\t */\r\n    public getEventName(): string {\r\n        return this.listener.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the listener as an Object\r\n\t *\r\n\t * @returns IListener\r\n\t * @memberof Listener\r\n\t */\r\n    public toJSON(): IListener {\r\n        return this.listener;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, Listener> {\r\n\t/**\r\n\t * The name of the event\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Event\r\n\t */\r\n    private name: string;\r\n\r\n\t/**\r\n\t * Creates an instance of Event.\r\n\t *\r\n\t * @param {string} [name=\"event\"]\r\n\t * @memberof Event\r\n\t */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n\t/**\r\n\t * Creates an instance of EventEmitter.\r\n\t *\r\n\t * @memberof EventEmitter\r\n\t */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n\t * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\t/**\r\n\t * Creates a new listener and adds it to the event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(new Listener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a listener for a given event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback | object} callback\r\n\t * @param {object} scope\r\n\t * @returns\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from an event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let listener = new Listener({ name, callback, scope });\r\n\r\n            event.forEach((value: Listener, i: number) => {\r\n                if (\r\n                    value.getCallback() === listener.getCallback() &&\r\n                    value.getScope() === listener.getScope()\r\n                ) {\r\n                    return event.delete(i);\r\n                }\r\n            });\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from a given event, or it just completely removes an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback | object} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            if (typeof _callback === \"function\") {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a one time event listener for an event,\r\n     * do note, you can't use .off to remove events listeners for the kind of event, \r\n     * however, you can still remove the entire event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback | object} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public once(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events === \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            let onceFn: ListenerCallback = (...args) => {\r\n                if (isObject) {\r\n                    _name = key;\r\n                    _callback = events[key];\r\n                } else {\r\n                    _name = events[key];\r\n                }\r\n\r\n                this.off(_name, onceFn, _scope);\r\n                _callback.apply(_scope, args);\r\n            };\r\n\r\n            this.on(_name, onceFn, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call all listeners within an event\r\n\t *\r\n\t * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: Listener) => {\r\n                    let { callback, scope }: IListener = listener.toJSON();\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default EventEmitter;","import { EventEmitter, EventInput, ListenerCallback } from \"@okikio/emitter\";\r\n\r\n// DOM\r\nexport type AnimationTarget = string | Node | NodeList | HTMLCollection | HTMLElement[] | any[];\r\nexport const getElements = (selector: string | Node): Node[] => {\r\n    return typeof selector === \"string\" ? Array.from(document.querySelectorAll(selector as string)) : [selector];\r\n};\r\n\r\nexport const getTargets = (targets: AnimationTarget): Node[] => {\r\n    if (Array.isArray(targets)) return targets;\r\n    if (typeof targets == \"string\" || targets instanceof Node)\r\n        return getElements(targets);\r\n    if (targets instanceof NodeList || targets instanceof HTMLCollection)\r\n        return Array.from(targets);\r\n    return [];\r\n};\r\n\r\n// VALUES\r\nexport type closureArgs = [number, number, HTMLElement];\r\nexport type closure = ((index?: number, total?: number, element?: HTMLElement) => any) | any;\r\nexport const computeValue = (value: closure, args: closureArgs) => {\r\n    if (typeof value === \"function\") {\r\n        return value(...args);\r\n    } else { return value; }\r\n};\r\n\r\nexport const mapObject = (obj: object, args: closureArgs): any => {\r\n    let key, value, result = {};\r\n    let keys = Object.keys(obj);\r\n    for (let i = 0, len = keys.length; i < len; i++) {\r\n        key = keys[i];\r\n        value = obj[key];\r\n        result[key] = computeValue(value, args);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n// From: [https://easings.net]\r\nexport const easings = {\r\n    \"ease\": \"ease\",\r\n    \"in\": \"ease-in\",\r\n    \"out\": \"ease-out\",\r\n    \"in-out\": \"ease-in-out\",\r\n\r\n    // Sine\r\n    \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n    \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n    \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n\r\n    // Quad\r\n    \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n    \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n    \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n\r\n    // Cubic\r\n    \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n    \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n    \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n\r\n    // Quart\r\n    \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n    \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n    \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n\r\n    // Quint\r\n    \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n    \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n    \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n\r\n    // Expo\r\n    \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n    \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n    \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n\r\n    // Circ\r\n    \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n    \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n    \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n\r\n    // Back\r\n    \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n    \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n    \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n};\r\nexport const getEase = (ease: string) => {\r\n    return /^(ease|in|out)/.test(ease) ? easings[ease] : ease;\r\n};\r\n\r\nexport interface AnimationOptions {\r\n    target?: AnimationTarget,\r\n\r\n    speed?: number | closure,\r\n    delay?: number | closure,\r\n    easing?: string | closure,\r\n    endDelay?: number | closure,\r\n    duration?: number | closure,\r\n    autoplay?: boolean | closure,\r\n    keyframes?: object[] | closure,\r\n    loop?: number | boolean | closure, // iterations: number,\r\n    options?: AnimationOptions | closure,\r\n    onfinish?: (element?: HTMLElement, index?: number, total?: number) => any,\r\n    fillMode?: \"none\" | \"forwards\" | \"backwards\" | \"both\" | \"auto\" | closure,\r\n    direction?: \"normal\" | \"reverse\" | \"alternate\" | \"alternate-reverse\" | closure,\r\n    [property: string]: closure | boolean | object | string | string[] | number | null | (number | null)[] | undefined;\r\n};\r\n\r\nexport const DefaultAnimationOptions: AnimationOptions = {\r\n    keyframes: [],\r\n\r\n    loop: 1, // iterations: number,\r\n    delay: 0,\r\n    speed: 1,\r\n    endDelay: 0,\r\n    easing: \"ease\",\r\n    autoplay: true,\r\n    duration: 1000,\r\n    onfinish() { },\r\n    fillMode: \"auto\",\r\n    direction: \"normal\",\r\n};\r\n\r\n// You can check it out here: https://codepen.io/okikio/pen/qBbdGaW?editors=0011\r\nexport class Animate {\r\n    /**\r\n     * Stores the options for the current animation\r\n     *\r\n     * @protected\r\n     * @type AnimationOptions\r\n     * @memberof Animate\r\n     */\r\n    protected options: AnimationOptions = {};\r\n\r\n    /**\r\n     * The Array of Elements to Animate\r\n     *\r\n     * @protected\r\n     * @type {Node[]}\r\n     * @memberof Animate\r\n     */\r\n    protected targets: Node[] = [];\r\n\r\n    /**\r\n     * The properties to animate\r\n     *\r\n     * @protected\r\n     * @type {object}\r\n     * @memberof Animate\r\n     */\r\n    protected properties: object = {};\r\n\r\n    /**\r\n     * A Set of Animations\r\n     *\r\n     * @protected\r\n     * @type {Map<HTMLElement, Animation>}\r\n     * @memberof Animate\r\n     */\r\n    protected animations: Map<HTMLElement, Animation> = new Map();\r\n\r\n    /**\r\n     * The total duration of all Animation's\r\n     *\r\n     * @protected\r\n     * @type {number}\r\n     * @memberof Animate\r\n     */\r\n    protected duration: number = 0;\r\n\r\n    /**\r\n     * The Element the main animation uses\r\n     *\r\n     * @protected\r\n     * @type {HTMLElement}\r\n     * @memberof Animate\r\n     */\r\n    protected mainElement: HTMLElement;\r\n\r\n    /**\r\n     * Stores an animation that runs on the total duration of the all other Animations, and as such it's the main Animation\r\n     *\r\n     * @protected\r\n     * @type {Animation}\r\n     * @memberof Animate\r\n     */\r\n    protected mainAnimation: Animation;\r\n\r\n    /**\r\n     * Stores request frame calls\r\n     *\r\n     * @protected\r\n     * @type {number}\r\n     * @memberof Animate\r\n     */\r\n    protected animationFrame: number;\r\n\r\n    /**\r\n     * An event emitter\r\n     *\r\n     * @protected\r\n     * @type {EventEmitter}\r\n     * @memberof Animate\r\n     */\r\n    protected emitter: EventEmitter = new EventEmitter();\r\n\r\n    /**\r\n     * The finish method, is called when the main animation has finished\r\n     *\r\n     * @protected\r\n     * @type {*}\r\n     * @memberof Animate\r\n     */\r\n    protected finish: any;\r\n\r\n    /**\r\n     * Returns a promise that is fulfilled when the mainAnimation is finished\r\n     *\r\n     * @protected\r\n     * @type {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    protected promise: Promise<AnimationOptions>;\r\n\r\n    /**\r\n     * Creates an instance of Animate.\r\n     * \r\n     * @param {AnimationOptions} options\r\n     * @memberof Animate\r\n     */\r\n    constructor(options: AnimationOptions = {}) {\r\n        let { options: animation, ...rest } = options;\r\n        this.options = Object.assign({}, DefaultAnimationOptions, animation, rest);\r\n        this.loop = this.loop.bind(this);\r\n\r\n        let {\r\n            loop,\r\n            delay,\r\n            speed,\r\n            easing,\r\n            endDelay,\r\n            duration,\r\n            direction,\r\n            fillMode,\r\n            onfinish,\r\n            target,\r\n            keyframes,\r\n            autoplay,\r\n            ...properties\r\n        } = this.options;\r\n\r\n        this.mainElement = document.createElement(\"span\");\r\n        this.targets = getTargets(target);\r\n        this.properties = properties;\r\n\r\n        let animationKeyframe: Keyframe[] | PropertyIndexedKeyframes;\r\n        for (let i = 0, len = this.targets.length; i < len; i++) {\r\n            let target = this.targets[i] as HTMLElement;\r\n            let animationOptions = {\r\n                easing: getEase(easing),\r\n                iterations: loop === true ? Infinity : (loop as number),\r\n                direction,\r\n                endDelay,\r\n                duration,\r\n                delay,\r\n                fill: fillMode,\r\n            };\r\n\r\n            // Accept keyframes as a keyframes Object, or a method, \r\n            // if there are no animations in the keyframes array,\r\n            // uses css properties from the options object\r\n            let arrKeyframes = computeValue((keyframes as Keyframe[]), [i, len, target]);\r\n            animationKeyframe = arrKeyframes.length ? arrKeyframes :\r\n                (this.properties as PropertyIndexedKeyframes);\r\n\r\n            // Allows the use of functions as the values, for both the keyframes and the animation object\r\n            // It adds the capability of advanced stagger animation, similar to the anime js stagger functions\r\n            animationOptions = mapObject(animationOptions, [i, len, target]);\r\n            if (!(arrKeyframes.length > 0))\r\n                animationKeyframe = mapObject(animationKeyframe, [i, len, target]);\r\n\r\n            // Set the Animate classes duration to be the Animation with the largest totalDuration\r\n            let tempDuration: number =\r\n                animationOptions.delay +\r\n                (animationOptions.duration * animationOptions.iterations) +\r\n                animationOptions.endDelay;\r\n            if (this.duration < tempDuration) this.duration = tempDuration;\r\n\r\n            // Add animation to the Animations Set\r\n            let animation = target.animate(animationKeyframe, animationOptions);\r\n            animation.onfinish = () => {\r\n                onfinish(target, i, len);\r\n            };\r\n            this.animations.set(target, animation);\r\n        }\r\n\r\n        this.mainAnimation = this.mainElement.animate([\r\n            { opacity: \"0\" },\r\n            { opacity: \"1\" }\r\n        ], {\r\n            duration: this.duration,\r\n            easing: \"linear\"\r\n        });\r\n\r\n        this.setSpeed(speed);\r\n        if (autoplay) this.play();\r\n        else this.pause();\r\n\r\n        this.promise = this.newPromise();\r\n        this.mainAnimation.onfinish = () => {\r\n            this.finish(this.options);\r\n            window.cancelAnimationFrame(this.animationFrame);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the Array of targets\r\n     *\r\n     * @returns {Node[]}\r\n     * @memberof Animate\r\n     */\r\n    public getTargets(): Node[] {\r\n        return this.targets;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Promise that is resolve when this.finish is called\r\n     *\r\n     * @protected\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    protected newPromise(): Promise<AnimationOptions> {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                this.finish = (options: AnimationOptions) => {\r\n                    this.emit(\"finish\", options);\r\n                    return resolve(options);\r\n                };\r\n            } catch (err) { reject(err); }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fulfills the this.promise Promise\r\n     *\r\n     * @param {(value?: any) => any} [onFulfilled]\r\n     * @param {(reason?: any) => any} [onRejected]\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public then(\r\n        onFulfilled?: (value?: any) => any,\r\n        onRejected?: (reason?: any) => any\r\n    ): Promise<AnimationOptions> {\r\n        return this.promise.then(onFulfilled, onRejected);\r\n    }\r\n\r\n    /**\r\n     * Catches error that occur in the this.promise Promise\r\n     *\r\n     * @param {(reason?: any) => any} onRejected\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public catch(onRejected: (reason?: any) => any): Promise<AnimationOptions> {\r\n        return this.promise.catch(onRejected);\r\n    }\r\n\r\n    /**\r\n     * If you don't care if the this.promise Promise has either been rejected or resolved  \r\n     *\r\n     * @param {() => any} onFinally\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public finally(onFinally: () => any): Promise<AnimationOptions> {\r\n        return this.promise.finally(onFinally);\r\n    }\r\n\r\n    /**\r\n     * Represents an Animation Frame Loop\r\n     *\r\n     * @private\r\n     * @memberof Animate\r\n     */\r\n    protected loop(): void {\r\n        this.animationFrame = window.requestAnimationFrame(this.loop);\r\n        this.emit(\"tick change\", this.getCurrentTime());\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} [callback]\r\n     * @param {object} [scope]\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public on(events: EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.on(events, callback, scope);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} [callback]\r\n     * @param {object} [scope]\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public off(events: EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.off(events, callback, scope);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     *\r\n     * @param {(string | any[])} events\r\n     * @param {...any} args\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public emit(events: string | any[], ...args: any): Animate {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get a specific Animation from an Animate instance\r\n     *\r\n     * @param {HTMLElement} element\r\n     * @returns {Animation}\r\n     * @memberof Animate\r\n     */\r\n    public getAnimation(element: HTMLElement): Animation {\r\n        return this.animations.get(element);\r\n    }\r\n\r\n    /**\r\n     * Play Animation's\r\n     *\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public play(): Animate {\r\n        // Once the animation is done, it's done, it can only be paused by the reset method\r\n        if (this.mainAnimation.playState !== \"finished\") {\r\n            this.mainAnimation.play();\r\n            this.animationFrame = requestAnimationFrame(this.loop);\r\n            this.animations.forEach(animation => {\r\n                if (animation.playState !== \"finished\") animation.play();\r\n            });\r\n            this.emit(\"play\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause Animation's\r\n     *\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public pause(): Animate {\r\n        // Once the animation is done, it's done, it can only be reset by the reset method\r\n        if (this.mainAnimation.playState !== \"finished\") {\r\n            this.mainAnimation.pause();\r\n            window.cancelAnimationFrame(this.animationFrame);\r\n            this.animations.forEach(animation => {\r\n                if (animation.playState !== \"finished\") animation.pause();\r\n            });\r\n            this.emit(\"pause\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the total duration of all Animations\r\n     *\r\n     * @returns {number}\r\n     * @memberof Animate\r\n     */\r\n    public getDuration(): number {\r\n        return this.duration;\r\n    }\r\n\r\n    /**\r\n     * Returns the current time of the Main Animation\r\n     *\r\n     * @returns {number}\r\n     * @memberof Animate\r\n     */\r\n    public getCurrentTime(): number {\r\n        return this.mainAnimation.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Set the current time of the Main Animation\r\n     *\r\n     * @param {number} time\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public setCurrentTime(time: number): Animate {\r\n        this.mainAnimation.currentTime = time;\r\n        this.animations.forEach(animation => {\r\n            animation.currentTime = time;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the Animation progress as a fraction of the current time / duration\r\n     *\r\n     * @returns\r\n     * @memberof Animate\r\n     */\r\n    public getProgress() {\r\n        return this.getCurrentTime() / this.duration;\r\n    }\r\n\r\n    /**\r\n     * Set the Animation progress as a fraction of the current time / duration\r\n     *\r\n     * @param {number} percent\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public setProgress(percent: number): Animate {\r\n        this.mainAnimation.currentTime = percent * this.duration;\r\n        this.animations.forEach(animation => {\r\n            animation.currentTime = percent * this.duration;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the playback speed of the animation\r\n     *\r\n     * @returns {number}\r\n     * @memberof Animate\r\n     */\r\n    public getSpeed(): number {\r\n        return this.mainAnimation.playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Set the playback speed of an Animation\r\n     *\r\n     * @param {number} [speed=1]\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public setSpeed(speed: number = 1): Animate {\r\n        this.mainAnimation.playbackRate = speed;\r\n        this.animations.forEach(animation => {\r\n            animation.playbackRate = speed;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all Animations\r\n     *\r\n     * @memberof Animate\r\n     */\r\n    public reset() {\r\n        this.setCurrentTime(0);\r\n        this.promise = this.newPromise();\r\n\r\n        if (this.options.autoplay) this.play();\r\n        else this.pause();\r\n    }\r\n\r\n    /**\r\n     * Returns the current playing state\r\n     *\r\n     * @returns {(\"idle\" | \"running\" | \"paused\" | \"finished\")}\r\n     * @memberof Animate\r\n     */\r\n    public getPlayState(): \"idle\" | \"running\" | \"paused\" | \"finished\" {\r\n        return this.mainAnimation.playState;\r\n    }\r\n\r\n    /**\r\n     * Get the options of an Animate instance\r\n     *\r\n     * @returns {AnimationOptions}\r\n     * @memberof Animate\r\n     */\r\n    public getOptions(): AnimationOptions {\r\n        return this.options;\r\n    }\r\n\r\n    // Returns the Animate options, as JSON\r\n    public toJSON(): AnimationOptions {\r\n        return this.getOptions();\r\n    }\r\n}\r\n\r\n// Creates a new Animate instance\r\nexport const animate = (options: AnimationOptions = {}): Animate => {\r\n    return new Animate(options);\r\n};\r\n\r\nexport default animate;"],"names":[],"mappings":"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"}