{"version":3,"file":"api.modern.js","sources":["../node_modules/.pnpm/managerjs@1.1.8/node_modules/managerjs/src/api.ts","../node_modules/.pnpm/@okikio/event-emitter@1.1.3/node_modules/@okikio/event-emitter/src/api.ts","../src/api.ts"],"sourcesContent":["\r\n/**\r\n * Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data.\r\n *\r\n * @export\r\n * @class Manager\r\n * @template K\r\n * @template V\r\n */\r\nexport class Manager<K, V> {\r\n\t/**\r\n\t * The complex list of named data, to which the Manager controls\r\n\t *\r\n\t * @protected\r\n\t * @type Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tprotected map: Map<K, V>;\r\n\r\n    /**\r\n     * Creates an instance of Manager.\r\n     * \r\n     * @param {Array<[K, V]>} [value]\r\n     * @memberof Manager\r\n     */\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Manager class's list\r\n\t *\r\n\t * @returns Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key to find in the Manager's list\r\n\t * @returns V\r\n\t */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the keys of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<K>\r\n     * @memberof Manager\r\n     */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn [...this.map.keys()];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the values of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<V>\r\n     * @memberof Manager\r\n\t */\r\n\tpublic values(): Array<V> {\r\n\t\treturn [...this.map.values()];\r\n\t}\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers\r\n     *\r\n     * @public\r\n     * @param  {V} value\r\n     * @returns Manager<K, V>\r\n     */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\t// @ts-ignore\r\n\t\tthis.set(this.size as K, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total number of items stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns Number\r\n\t */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n    /**\r\n\t * Returns the last item in the Manager who's index is a certain distance from the last item in the Manager\r\n     *\r\n     * @param {number} [distance=1]\r\n     * @returns V | undefined\r\n     * @memberof Manager\r\n     */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the second last item in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns V | undefined\r\n\t */\r\n\tpublic prev(): V | undefined {\r\n\t\treturn this.last(2);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic delete(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the Manager of all its contents\r\n\t *\r\n\t * @public\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the Manager contains a certain key\r\n\t *\r\n\t * @public\r\n\t * @param {K} key\r\n\t * @returns boolean\r\n\t */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.\r\n\t *\r\n\t * @public\r\n\t * @returns IterableIterator<[K, V]>\r\n\t */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates through the Managers contents, calling a callback function every iteration\r\n\t *\r\n\t * @param {*} [callback=(...args: any): void => { }]\r\n\t * @param {object} context\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic forEach(\r\n\t\tcallback: any = (...args: any): void => { },\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Allows iteration via the for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators]\r\n     *\r\n     * @returns\r\n     * @memberof Manager\r\n     */\r\n\tpublic [Symbol.iterator]() {\r\n\t\treturn this.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the method of a certain name for all items that are currently installed\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic methodCall(method: string, ...args: any): Manager<K, V> {\r\n\t\tthis.forEach((item: V) => {\r\n\t\t\titem[method](...args);\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Promise<Manager<K, V>>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic async asyncMethodCall(method: string, ...args: any): Promise<Manager<K, V>> {\r\n\t\tfor await (let [, item] of this.map) {\r\n\t\t\tawait item[method](...args);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Manager } from \"managerjs/src/api\";\r\n\r\nexport type ListenerCallback = (...args: any) => void;\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Listener\r\n */\r\nexport class Listener {\r\n\t/**\r\n\t * The current listener data\r\n\t *\r\n\t * @private\r\n\t * @type IListener\r\n\t * @memberof Listener\r\n\t */\r\n    private listener: IListener;\r\n\r\n\t/**\r\n\t * Creates an instance of Listener.\r\n\t *\r\n\t * @param {IListener} { callback = () => { }, scope = null, name = \"event\" }\r\n\t * @memberof Listener\r\n\t */\r\n    constructor({\r\n        callback = () => { },\r\n        scope = null,\r\n        name = \"event\",\r\n    }: IListener) {\r\n        this.listener = { callback, scope, name };\r\n    }\r\n\r\n\t/**\r\n\t * Returns the callback Function of the Listener\r\n\t *\r\n\t * @returns ListenerCallback\r\n\t * @memberof Listener\r\n\t */\r\n    public getCallback(): ListenerCallback {\r\n        return this.listener.callback;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the scope as an Object, from the Listener\r\n\t *\r\n\t * @returns object\r\n\t * @memberof Listener\r\n\t */\r\n    public getScope(): object {\r\n        return this.listener.scope;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the event as a String, from the Listener\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Listener\r\n\t */\r\n    public getEventName(): string {\r\n        return this.listener.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the listener as an Object\r\n\t *\r\n\t * @returns IListener\r\n\t * @memberof Listener\r\n\t */\r\n    public toJSON(): IListener {\r\n        return this.listener;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, Listener> {\r\n\t/**\r\n\t * The name of the event\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Event\r\n\t */\r\n    private name: string;\r\n\r\n\t/**\r\n\t * Creates an instance of Event.\r\n\t *\r\n\t * @param {string} [name=\"event\"]\r\n\t * @memberof Event\r\n\t */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n\t/**\r\n\t * Creates an instance of EventEmitter.\r\n\t *\r\n\t * @memberof EventEmitter\r\n\t */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n\t * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\t/**\r\n\t * Creates a new listener and adds it to the event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(new Listener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a listener for a given event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from an event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.getEvent(name);\r\n\r\n        if (callback) {\r\n            let i = 0,\r\n                len: number = event.size,\r\n                value: Listener;\r\n            let listener = new Listener({ name, callback, scope });\r\n            for (; i < len; i++) {\r\n                value = event.get(i);\r\n                console.log(value);\r\n                if (\r\n                    value.getCallback() === listener.getCallback() &&\r\n                    value.getScope() === listener.getScope()\r\n                )\r\n                    break;\r\n            }\r\n\r\n            event.delete(i);\r\n        }\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from a given event, or it just completely removes an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach((key) => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            if (_callback) {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a one time event listener for an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public once(\r\n        events: EventInput,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let onceFn: ListenerCallback = (...args) => {\r\n            this.off(events, onceFn, scope);\r\n            callback.apply(scope, args);\r\n        };\r\n\r\n        this.on(events, onceFn, scope);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call all listeners within an event\r\n\t *\r\n\t * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let listeners: Event = this.getEvent(event);\r\n\r\n            const customEvent: CustomEvent<any> = new CustomEvent(event, { detail: args })\r\n            window.dispatchEvent(customEvent);\r\n\r\n            listeners.forEach((listener: Listener) => {\r\n                let { callback, scope }: IListener = listener.toJSON();\r\n                callback.apply(scope, args);\r\n            });\r\n        }, this);\r\n        return this;\r\n    }\r\n}","import { EventEmitter, EventInput, ListenerCallback } from \"@okikio/event-emitter/src/api\";\r\n\r\n// DOM\r\nexport type AnimationTarget = string | Node | NodeList | HTMLCollection | HTMLElement[] | any[];\r\nexport const getElements = (selector: string | Node): Node[] => {\r\n    return typeof selector === \"string\" ? Array.from(document.querySelectorAll(selector as string)) : [selector];\r\n};\r\n\r\nexport const getTargets = (targets: AnimationTarget): Node[] => {\r\n    if (Array.isArray(targets)) return targets;\r\n    if (typeof targets == \"string\" || targets instanceof Node)\r\n        return getElements(targets);\r\n    if (targets instanceof NodeList || targets instanceof HTMLCollection)\r\n        return Array.from(targets);\r\n    return [];\r\n};\r\n\r\n// VALUES\r\nexport type closureArgs = [number, number, HTMLElement];\r\nexport type closure = ((index?: number, total?: number, element?: HTMLElement) => any) | any;\r\nexport const computeValue = (value: closure, args: closureArgs) => {\r\n    if (typeof value === \"function\") {\r\n        return value(...args);\r\n    } else { return value; }\r\n};\r\n\r\nexport const mapObject = (obj: object, args: closureArgs): any => {\r\n    let key, value, result = {};\r\n    let keys = Object.keys(obj);\r\n    for (let i = 0, len = keys.length; i < len; i++) {\r\n        key = keys[i];\r\n        value = obj[key];\r\n        result[key] = computeValue(value, args);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n// From: [https://easings.net]\r\nexport const easings = {\r\n    \"ease\": \"ease\",\r\n    \"in\": \"ease-in\",\r\n    \"out\": \"ease-out\",\r\n    \"in-out\": \"ease-in-out\",\r\n\r\n    // Sine\r\n    \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n    \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n    \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n\r\n    // Quad\r\n    \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n    \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n    \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n\r\n    // Cubic\r\n    \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n    \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n    \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n\r\n    // Quart\r\n    \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n    \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n    \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n\r\n    // Quint\r\n    \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n    \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n    \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n\r\n    // Expo\r\n    \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n    \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n    \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n\r\n    // Circ\r\n    \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n    \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n    \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n\r\n    // Back\r\n    \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n    \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n    \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n};\r\nexport const getEase = (ease: string) => {\r\n    return /^(ease|in|out)/.test(ease) ? easings[ease] : ease;\r\n};\r\n\r\nexport interface AnimationOptions {\r\n    target?: AnimationTarget,\r\n\r\n    speed?: number | closure,\r\n    delay?: number | closure,\r\n    easing?: string | closure,\r\n    endDelay?: number | closure,\r\n    duration?: number | closure,\r\n    autoplay?: boolean | closure,\r\n    keyframes?: object[] | closure,\r\n    loop?: number | boolean | closure, // iterations: number,\r\n    options?: AnimationOptions | closure,\r\n    onfinish?: (element?: HTMLElement, index?: number, total?: number) => any,\r\n    fillMode?: \"none\" | \"forwards\" | \"backwards\" | \"both\" | \"auto\" | closure,\r\n    direction?: \"normal\" | \"reverse\" | \"alternate\" | \"alternate-reverse\" | closure,\r\n    [property: string]: boolean | object | string | string[] | number | null | (number | null)[] | closure | undefined;\r\n};\r\n\r\nexport const DefaultAnimationOptions: AnimationOptions = {\r\n    keyframes: [],\r\n\r\n    loop: 1, // iterations: number,\r\n    delay: 0,\r\n    speed: 1,\r\n    endDelay: 0,\r\n    easing: \"ease\",\r\n    autoplay: true,\r\n    duration: 1000,\r\n    onfinish() { },\r\n    fillMode: \"auto\",\r\n    direction: \"normal\",\r\n};\r\n\r\n// You can check it out here: https://codepen.io/okikio/pen/qBbdGaW?editors=0011\r\nexport class Animate {\r\n    /**\r\n     * Stores the options for the current animation\r\n     *\r\n     * @protected\r\n     * @type AnimationOptions\r\n     * @memberof Animate\r\n     */\r\n    protected options: AnimationOptions = {};\r\n\r\n    /**\r\n     * The Array of Elements to Animate\r\n     *\r\n     * @protected\r\n     * @type {Node[]}\r\n     * @memberof Animate\r\n     */\r\n    protected targets: Node[] = [];\r\n\r\n    /**\r\n     * The properties to animate\r\n     *\r\n     * @protected\r\n     * @type {object}\r\n     * @memberof Animate\r\n     */\r\n    protected properties: object = {};\r\n\r\n    /**\r\n     * A Set of Animations\r\n     *\r\n     * @protected\r\n     * @type {Map<HTMLElement, Animation>}\r\n     * @memberof Animate\r\n     */\r\n    protected animations: Map<HTMLElement, Animation> = new Map();\r\n\r\n    /**\r\n     * The total duration of all Animation's\r\n     *\r\n     * @protected\r\n     * @type {number}\r\n     * @memberof Animate\r\n     */\r\n    protected duration: number = 0;\r\n\r\n    /**\r\n     * The Element the main animation uses\r\n     *\r\n     * @protected\r\n     * @type {HTMLElement}\r\n     * @memberof Animate\r\n     */\r\n    protected mainElement: HTMLElement;\r\n\r\n    /**\r\n     * Stores an animation that runs on the total duration of the all other Animations, and as such it's the main Animation\r\n     *\r\n     * @protected\r\n     * @type {Animation}\r\n     * @memberof Animate\r\n     */\r\n    protected mainAnimation: Animation;\r\n\r\n    /**\r\n     * Stores request frame calls\r\n     *\r\n     * @protected\r\n     * @type {number}\r\n     * @memberof Animate\r\n     */\r\n    protected animationFrame: number;\r\n\r\n    /**\r\n     * An event emitter\r\n     *\r\n     * @protected\r\n     * @type {EventEmitter}\r\n     * @memberof Animate\r\n     */\r\n    protected emitter: EventEmitter = new EventEmitter();\r\n\r\n    /**\r\n     * The finish method, is called when the main animation has finished\r\n     *\r\n     * @protected\r\n     * @type {*}\r\n     * @memberof Animate\r\n     */\r\n    protected finish: any;\r\n\r\n    /**\r\n     * Returns a promise that is fulfilled when the mainAnimation is finished\r\n     *\r\n     * @protected\r\n     * @type {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    protected promise: Promise<AnimationOptions>;\r\n\r\n    /**\r\n     * Creates an instance of Animate.\r\n     * \r\n     * @param {AnimationOptions} options\r\n     * @memberof Animate\r\n     */\r\n    constructor(options: AnimationOptions = {}) {\r\n        let { options: animation, ...rest } = options;\r\n        this.options = Object.assign({}, DefaultAnimationOptions, animation, rest);\r\n\r\n        let {\r\n            loop,\r\n            delay,\r\n            speed,\r\n            easing,\r\n            endDelay,\r\n            duration,\r\n            direction,\r\n            fillMode,\r\n            onfinish,\r\n            target,\r\n            keyframes,\r\n            autoplay,\r\n            ...properties\r\n        } = this.options;\r\n\r\n        this.mainElement = document.createElement(\"span\");\r\n        this.targets = getTargets(target);\r\n        this.properties = properties;\r\n\r\n        let animationKeyframe: Keyframe[] | PropertyIndexedKeyframes;\r\n        for (let i = 0, len = this.targets.length; i < len; i++) {\r\n            let target = this.targets[i] as HTMLElement;\r\n            let animationOptions = {\r\n                easing: getEase(easing),\r\n                iterations: loop === true ? Infinity : (loop as number),\r\n                direction,\r\n                endDelay,\r\n                duration,\r\n                delay,\r\n                fill: fillMode,\r\n            };\r\n\r\n            // Accept keyframes as a keyframes Object, or a method, \r\n            // if there are no animations in the keyframes array,\r\n            // uses css properties from the options object\r\n            let arrKeyframes = computeValue((keyframes as Keyframe[]), [i, len, target]);\r\n            animationKeyframe = arrKeyframes.length ? arrKeyframes :\r\n                (this.properties as PropertyIndexedKeyframes);\r\n\r\n            // Allows the use of functions as the values, for both the keyframes and the animation object\r\n            // It adds the capability of advanced stagger animation, similar to the anime js stagger functions\r\n            animationOptions = mapObject(animationOptions, [i, len, target]);\r\n            if (!(arrKeyframes.length > 0))\r\n                animationKeyframe = mapObject(animationKeyframe, [i, len, target]);\r\n\r\n            // Set the Animate classes duration to be the Animation with the largest totalDuration\r\n            let tempDuration: number =\r\n                animationOptions.delay +\r\n                (animationOptions.duration * animationOptions.iterations) +\r\n                animationOptions.endDelay;\r\n            if (this.duration < tempDuration) this.duration = tempDuration;\r\n\r\n            // Add animation to the Animations Set\r\n            let animation = target.animate(animationKeyframe, animationOptions);\r\n            animation.onfinish = () => {\r\n                onfinish(target, i, len);\r\n            };\r\n            this.animations.set(target, animation);\r\n        }\r\n\r\n        this.mainAnimation = this.mainElement.animate([\r\n            { opacity: \"0\" },\r\n            { opacity: \"1\" }\r\n        ], {\r\n            duration: this.duration,\r\n            easing: \"linear\"\r\n        });\r\n\r\n        this.setSpeed(speed);\r\n        if (autoplay) this.play();\r\n        else this.pause();\r\n\r\n        this.promise = this.newPromise();\r\n        this.mainAnimation.onfinish = () => {\r\n            this.finish(this.options);\r\n            window.cancelAnimationFrame(this.animationFrame);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns a new Promise that is resolve when this.finish is called\r\n     *\r\n     * @protected\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    protected newPromise(): Promise<AnimationOptions> {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                this.finish = (options: AnimationOptions) => {\r\n                    this.emit(\"finish\", options);\r\n                    return resolve(options);\r\n                };\r\n            } catch (err) { reject(err); }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fulfills the this.promise Promise\r\n     *\r\n     * @param {(value?: any) => any} [onFulfilled]\r\n     * @param {(reason?: any) => any} [onRejected]\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public then(\r\n        onFulfilled?: (value?: any) => any,\r\n        onRejected?: (reason?: any) => any\r\n    ): Promise<AnimationOptions> {\r\n        return this.promise.then(onFulfilled, onRejected);\r\n    }\r\n\r\n    /**\r\n     * Catches error that occur in the this.promise Promise\r\n     *\r\n     * @param {(reason?: any) => any} onRejected\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public catch(onRejected: (reason?: any) => any): Promise<AnimationOptions> {\r\n        return this.promise.catch(onRejected);\r\n    }\r\n\r\n    /**\r\n     * If you don't care if the this.promise Promise has either been rejected or resolved  \r\n     *\r\n     * @param {() => any} onFinally\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public finally(onFinally: () => any): Promise<AnimationOptions> {\r\n        return this.promise.finally(onFinally);\r\n    }\r\n\r\n    /**\r\n     * Represents an Animation Frame Loop\r\n     *\r\n     * @private\r\n     * @memberof Animate\r\n     */\r\n    protected loop(): void {\r\n        this.animationFrame = window.requestAnimationFrame(this.loop.bind(this));\r\n        this.emit(\"tick change\", this.getCurrentTime());\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} [callback]\r\n     * @param {object} [scope]\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public on(events: EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.on(events, callback, scope);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} [callback]\r\n     * @param {object} [scope]\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public off(events: EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.off(events, callback, scope);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     *\r\n     * @param {(string | any[])} events\r\n     * @param {...any} args\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public emit(events: string | any[], ...args: any): Animate {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get a specific Animation from an Animate instance\r\n     *\r\n     * @param {HTMLElement} element\r\n     * @returns {Animation}\r\n     * @memberof Animate\r\n     */\r\n    public getAnimation(element: HTMLElement): Animation {\r\n        return this.animations.get(element);\r\n    }\r\n\r\n    /**\r\n     * Play Animation's\r\n     *\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public play(): Animate {\r\n        // Once the animation is done, it's done, it can only be paused by the reset method\r\n        if (this.mainAnimation.playState !== \"finished\") {\r\n            this.mainAnimation.play();\r\n            this.animationFrame = requestAnimationFrame(this.loop.bind(this));\r\n            this.animations.forEach(animation => {\r\n                if (animation.playState !== \"finished\") animation.play();\r\n            });\r\n            this.emit(\"play\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause Animation's\r\n     *\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public pause(): Animate {\r\n        // Once the animation is done, it's done, it can only be reset by the reset method\r\n        if (this.mainAnimation.playState !== \"finished\") {\r\n            this.mainAnimation.pause();\r\n            window.cancelAnimationFrame(this.animationFrame);\r\n            this.animations.forEach(animation => {\r\n                if (animation.playState !== \"finished\") animation.pause();\r\n            });\r\n            this.emit(\"pause\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the total duration of all Animations\r\n     *\r\n     * @returns {number}\r\n     * @memberof Animate\r\n     */\r\n    public getDuration(): number {\r\n        return this.duration;\r\n    }\r\n\r\n    /**\r\n     * Returns the current time of the Main Animation\r\n     *\r\n     * @returns {number}\r\n     * @memberof Animate\r\n     */\r\n    public getCurrentTime(): number {\r\n        return this.mainAnimation.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Set the current time of the Main Animation\r\n     *\r\n     * @param {number} time\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public setCurrentTime(time: number): Animate {\r\n        this.mainAnimation.currentTime = time;\r\n        this.animations.forEach(animation => {\r\n            animation.currentTime = time;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the Animation progress as a fraction of the current time / duration\r\n     *\r\n     * @returns\r\n     * @memberof Animate\r\n     */\r\n    public getProgress() {\r\n        return this.getCurrentTime() / this.duration;\r\n    }\r\n\r\n    /**\r\n     * Set the Animation progress as a fraction of the current time / duration\r\n     *\r\n     * @param {number} percent\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public setProgress(percent: number): Animate {\r\n        this.mainAnimation.currentTime = percent * this.duration;\r\n        this.animations.forEach(animation => {\r\n            animation.currentTime = percent * this.duration;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the playback speed of the animation\r\n     *\r\n     * @returns {number}\r\n     * @memberof Animate\r\n     */\r\n    public getSpeed(): number {\r\n        return this.mainAnimation.playbackRate;\r\n    }\r\n    /**\r\n     * Set the playback speed of an Animation\r\n     *\r\n     * @param {number} [speed=1]\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public setSpeed(speed: number = 1): Animate {\r\n        this.mainAnimation.playbackRate = speed;\r\n        this.animations.forEach(animation => {\r\n            animation.playbackRate = speed;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all Animations\r\n     *\r\n     * @memberof Animate\r\n     */\r\n    public reset() {\r\n        this.setCurrentTime(0);\r\n        this.promise = this.newPromise();\r\n\r\n        if (this.options.autoplay) this.play();\r\n        else this.pause();\r\n    }\r\n\r\n    /**\r\n     * Returns the current playing state\r\n     *\r\n     * @returns {(\"idle\" | \"running\" | \"paused\" | \"finished\")}\r\n     * @memberof Animate\r\n     */\r\n    public getPlayState(): \"idle\" | \"running\" | \"paused\" | \"finished\" {\r\n        return this.mainAnimation.playState;\r\n    }\r\n\r\n    /**\r\n     * Get the options of an Animate instance\r\n     *\r\n     * @returns {AnimationOptions}\r\n     * @memberof Animate\r\n     */\r\n    public getOptions(): AnimationOptions {\r\n        return this.options;\r\n    }\r\n\r\n    // Returns the Animate options, as JSON\r\n    public toJSON(): AnimationOptions {\r\n        return this.getOptions();\r\n    }\r\n}\r\n\r\n// Creates a new Animate instance\r\nexport const animate = (options: AnimationOptions = {}): Animate => {\r\n    return new Animate(options);\r\n};"],"names":["Manager","[object Object]","value","this","map","Map","key","get","keys","values","set","size","distance","last","delete","clear","has","entries","callback","args","context","forEach","Symbol","iterator","method","item","Listener","scope","name","listener","Event","super","EventEmitter","event","getEvent","add","events","_name","_callback","_scope","split","Object","Array","isArray","newListener","i","len","console","log","getCallback","getScope","removeListener","onceFn","off","apply","on","listeners","customEvent","CustomEvent","detail","window","dispatchEvent","toJSON","getElements","selector","from","document","querySelectorAll","getTargets","targets","Node","NodeList","HTMLCollection","computeValue","mapObject","obj","result","length","easings","ease","in","out","in-out","in-sine","out-sine","in-out-sine","in-quad","out-quad","in-out-quad","in-cubic","out-cubic","in-out-cubic","in-quart","out-quart","in-out-quart","in-quint","out-quint","in-out-quint","in-expo","out-expo","in-out-expo","in-circ","out-circ","in-out-circ","in-back","out-back","in-out-back","getEase","test","DefaultAnimationOptions","keyframes","loop","delay","speed","endDelay","easing","autoplay","duration","onfinish","fillMode","direction","Animate","constructor","options","animation","rest","assign","animationKeyframe","target","properties","mainElement","createElement","animationOptions","iterations","Infinity","fill","arrKeyframes","tempDuration","animate","animations","mainAnimation","opacity","setSpeed","play","pause","promise","newPromise","finish","cancelAnimationFrame","animationFrame","Promise","resolve","reject","emit","err","then","onFulfilled","onRejected","catch","finally","onFinally","requestAnimationFrame","bind","getCurrentTime","emitter","getAnimation","element","playState","getDuration","currentTime","setCurrentTime","time","getProgress","setProgress","percent","getSpeed","playbackRate","reset","getPlayState","getOptions"],"mappings":"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"}