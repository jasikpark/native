{"version":3,"file":"api.modern.js","sources":["../src/config.ts","../node_modules/.pnpm/managerjs@1.1.8/node_modules/managerjs/src/api.ts","../src/manager.ts","../src/url.ts","../src/history.ts","../src/page.ts","../node_modules/.pnpm/@okikio/event-emitter@1.1.3/node_modules/@okikio/event-emitter/src/api.ts","../src/service.ts","../src/transition.ts","../src/block.ts","../src/app.ts","../src/pjax.ts","../src/router.ts"],"sourcesContent":["// The config variables\r\nexport interface ICONFIG {\r\n    prefix?: string;\r\n    wrapperAttr?: string;\r\n    noAjaxLinkAttr?: string;\r\n    noPrefetchAttr?: \"no-prefetch\";\r\n    headers?: string[][];\r\n    preventSelfAttr?: string;\r\n    preventAllAttr?: string;\r\n    transitionAttr?: string;\r\n    blockAttr?: string;\r\n    timeout?: number\r\n}\r\n\r\nexport const CONFIG_DEFAULTS: ICONFIG = {\r\n    wrapperAttr: \"wrapper\",\r\n    noAjaxLinkAttr: \"no-ajax-link\",\r\n    noPrefetchAttr: \"no-prefetch\",\r\n    headers: [\r\n        [\"x-partial\", \"true\"]\r\n    ],\r\n    preventSelfAttr: `prevent=\"self\"`,\r\n    preventAllAttr: `prevent=\"all\"`,\r\n    transitionAttr: \"transition\",\r\n    blockAttr: `block`,\r\n    timeout: 30000\r\n};\r\n\r\nexport type ConfigKeys = keyof ICONFIG;\r\n\r\n/**\r\n * The Config class\r\n *\r\n * @export\r\n * @class CONFIG\r\n */\r\nexport class CONFIG {\r\n    /**\r\n     * The current Configuration\r\n     *\r\n     * @protected\r\n     * @type ICONFIG\r\n     * @memberof CONFIG\r\n     */\r\n    protected config: ICONFIG;\r\n\r\n    /**\r\n     * Creates an instance of CONFIG.\r\n     *\r\n     * @param {ICONFIG} config\r\n     * @memberof CONFIG\r\n     */\r\n    constructor(config: ICONFIG) {\r\n        this.config = Object.assign({ ...CONFIG_DEFAULTS }, config);\r\n    }\r\n\r\n    /**\r\n     * Converts string into data attributes\r\n     *\r\n     * @param {string} value\r\n     * @param {boolean} brackets [brackets=true]\r\n     * @returns string\r\n     * @memberof CONFIG\r\n     */\r\n    public toAttr(value: string, brackets: boolean = true): string {\r\n        let { prefix } = this.config;\r\n        let attr = `data${prefix ? \"-\" + prefix : \"\"}-${value}`;\r\n        return brackets ? `[${attr}]` : attr;\r\n    }\r\n\r\n    /**\r\n     * Selects config vars, and formats them for use, or simply returns the current configurations for the framework\r\n     *\r\n     * @param {ConfigKeys} value\r\n     * @param {boolean} [brackets=true]\r\n     * @returns any\r\n     * @memberof CONFIG\r\n     */\r\n    public getConfig(value?: ConfigKeys, brackets: boolean = true): any {\r\n        if (typeof value !== \"string\")\r\n            return this.config;\r\n\r\n        let config = this.config[value];\r\n        if (typeof config === \"string\")\r\n            return this.toAttr(config, brackets);\r\n        return config;\r\n    }\r\n}","\r\n/**\r\n * Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data.\r\n *\r\n * @export\r\n * @class Manager\r\n * @template K\r\n * @template V\r\n */\r\nexport class Manager<K, V> {\r\n\t/**\r\n\t * The complex list of named data, to which the Manager controls\r\n\t *\r\n\t * @protected\r\n\t * @type Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tprotected map: Map<K, V>;\r\n\r\n    /**\r\n     * Creates an instance of Manager.\r\n     * \r\n     * @param {Array<[K, V]>} [value]\r\n     * @memberof Manager\r\n     */\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Manager class's list\r\n\t *\r\n\t * @returns Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key to find in the Manager's list\r\n\t * @returns V\r\n\t */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the keys of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<K>\r\n     * @memberof Manager\r\n     */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn [...this.map.keys()];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the values of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<V>\r\n     * @memberof Manager\r\n\t */\r\n\tpublic values(): Array<V> {\r\n\t\treturn [...this.map.values()];\r\n\t}\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers\r\n     *\r\n     * @public\r\n     * @param  {V} value\r\n     * @returns Manager<K, V>\r\n     */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\t// @ts-ignore\r\n\t\tthis.set(this.size as K, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total number of items stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns Number\r\n\t */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n    /**\r\n\t * Returns the last item in the Manager who's index is a certain distance from the last item in the Manager\r\n     *\r\n     * @param {number} [distance=1]\r\n     * @returns V | undefined\r\n     * @memberof Manager\r\n     */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the second last item in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns V | undefined\r\n\t */\r\n\tpublic prev(): V | undefined {\r\n\t\treturn this.last(2);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic delete(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the Manager of all its contents\r\n\t *\r\n\t * @public\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the Manager contains a certain key\r\n\t *\r\n\t * @public\r\n\t * @param {K} key\r\n\t * @returns boolean\r\n\t */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.\r\n\t *\r\n\t * @public\r\n\t * @returns IterableIterator<[K, V]>\r\n\t */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates through the Managers contents, calling a callback function every iteration\r\n\t *\r\n\t * @param {*} [callback=(...args: any): void => { }]\r\n\t * @param {object} context\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic forEach(\r\n\t\tcallback: any = (...args: any): void => { },\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Allows iteration via the for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators]\r\n     *\r\n     * @returns\r\n     * @memberof Manager\r\n     */\r\n\tpublic [Symbol.iterator]() {\r\n\t\treturn this.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the method of a certain name for all items that are currently installed\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic methodCall(method: string, ...args: any): Manager<K, V> {\r\n\t\tthis.forEach((item: V) => {\r\n\t\t\titem[method](...args);\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Promise<Manager<K, V>>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic async asyncMethodCall(method: string, ...args: any): Promise<Manager<K, V>> {\r\n\t\tfor await (let [, item] of this.map) {\r\n\t\t\tawait item[method](...args);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Manager } from \"managerjs/src/api\";\r\nimport { ConfigKeys } from \"./config\";\r\nimport { App } from \"./app\";\r\n\r\nexport type IAdvancedManager = AdvancedManager<any, ManagerItem>;\r\n\r\n/**\r\n * The base class for all AdvancedManager and AdvancedStorage items\r\n *\r\n * @export\r\n * @class ManagerItem\r\n */\r\nexport class ManagerItem {\r\n    /**\r\n     * The AdvancedManager or AdvancedStorage the ManagerItem is attached to\r\n     *\r\n     * @protected\r\n     * @type IAdvancedManager\r\n     * @memberof ManagerItem\r\n     */\r\n    protected manager: IAdvancedManager;\r\n\r\n    /**\r\n     * Creates an instance of ManagerItem.\r\n     * \r\n     * @memberof ManagerItem\r\n     */\r\n    constructor() { }\r\n\r\n    /**\r\n     * The getConfig method for accessing the Configuration of the current App\r\n     *\r\n     * @param {ConfigKeys} [value]\r\n     * @param {boolean} [brackets]\r\n     * @returns any\r\n     * @memberof ManagerItem\r\n     */\r\n    protected getConfig(value?: ConfigKeys, brackets?: boolean): any {\r\n        return this.manager.getConfig(value, brackets);\r\n    };\r\n\r\n    /**\r\n     * Run after the Manager Item has been registered\r\n     *\r\n     * @returns any\r\n     * @memberof ManagerItem\r\n     */\r\n    public install(): any { }\r\n\r\n    /**\r\n     * Register the current Manager Item's manager\r\n     *\r\n     * @param {IAdvancedManager} manager\r\n     * @returns ManagerItem\r\n     * @memberof ManagerItem\r\n     */\r\n    public register(manager: IAdvancedManager): ManagerItem {\r\n        this.manager = manager;\r\n        this.install();\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * A tweak to the Manager class that makes it self aware of the App class it's instantiated in\r\n *\r\n * @export\r\n * @class AdvancedManager\r\n * @extends {Manager<K, V>}\r\n * @template K\r\n * @template V\r\n */\r\nexport class AdvancedManager<K, V extends ManagerItem> extends Manager<K, V> {\r\n\t/**\r\n\t * The instance of the App class, the Manager is instantiated in\r\n\t *\r\n\t * @private\r\n\t * @type App\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    private app: App;\r\n\r\n\t/**\r\n\t * Creates an instance of AdvancedManager.\r\n\t *\r\n\t * @param {App} app - The instance of the App class, the Manager is instantiated in\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    constructor(app: App) {\r\n        super();\r\n        this.app = app;\r\n    }\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns AdvancedManager<K, V>\r\n\t */\r\n    public set(key: K, value: V) {\r\n        super.set(key, value);\r\n        typeof value.register === \"function\" && value.register(this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the instance the App class\r\n\t *\r\n\t * @returns App\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    public getApp(): App {\r\n        return this.app;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the App config\r\n\t *\r\n     * @param {...any} args\r\n     * @returns any\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    public getConfig(...args: any): any {\r\n        return this.app.getConfig(...args);\r\n    }\r\n}\r\n\r\nexport { Manager };","/**\r\n * Adds new methods to the native URL Object; it seemed cleaner than using a custom method or editing the prototype.\r\n *\r\n * This doesn't extend the **Class** object because it's meant to be a small extension of the native URL class.\r\n *\r\n * @export\r\n * @class _URL\r\n * @extends {URL}\r\n */\r\nexport class _URL extends URL {\r\n    // Read up on the native URL class [devdocs.io/dom/url]\r\n\t/**\r\n\t * Creates an instance of _URL.\r\n\t *\r\n     * @param {(string | _URL | URL | Location)} [url=window.location.pathname]\r\n\t * @memberof _URL\r\n\t */\r\n    constructor(url: any = window.location.href) {\r\n        super(url instanceof URL ? url.href : url, window.location.origin);\r\n    }\r\n\r\n    /**\r\n     * Returns the pathname with the hash\r\n     *\r\n     * @returns string\r\n     * @memberof _URL\r\n     */\r\n    public getFullPath(): string {\r\n        return `${this.pathname}${this.hash}`;\r\n    }\r\n\r\n    /**\r\n     * Returns the actual hash without the hashtag\r\n     *\r\n     * @returns string\r\n     * @memberof _URL\r\n     */\r\n    public getHash(): string {\r\n        return this.hash.slice(1);\r\n    }\r\n\r\n    /**\r\n\t * Removes the hash from the full URL for a clean URL string\r\n\t *\r\n\t * @returns string\r\n\t * @memberof _URL\r\n\t */\r\n    public clean(): string {\r\n        return this.toString().replace(/(\\/#.*|\\/|#.*)$/, '');\r\n    }\r\n\r\n\t/**\r\n\t * Returns the pathname of a URL\r\n\t *\r\n\t * @returns string\r\n\t * @memberof _URL\r\n\t */\r\n    public getPathname(): string {\r\n        return this.pathname;\r\n    }\r\n\r\n\t/**\r\n\t * Compares this **_URL** to another **_URL**\r\n\t *\r\n\t * @param {_URL} url\r\n\t * @returns boolean\r\n\t * @memberof _URL\r\n\t */\r\n    public equalTo(url: _URL): boolean {\r\n        return this.clean() == url.clean();\r\n    }\r\n\r\n\t/**\r\n\t * Compares the pathname of two URLs to each other\r\n\t *\r\n\t * @static\r\n\t * @param {_URL} a\r\n\t * @param {_URL} b\r\n\t * @returns boolean\r\n\t * @memberof _URL\r\n\t */\r\n    static equal(a: _URL | string, b: _URL | string): boolean {\r\n        let urlA = a instanceof _URL ? a : new _URL(a);\r\n        let urlB = b instanceof _URL ? b : new _URL(b);\r\n        return urlA.equalTo(urlB);\r\n    }\r\n}\r\n\r\n/**\r\n * This is the default starting URL, to avoid needless instances of the same class that produce the same value, I defined the default value\r\n */\r\nexport const newURL = new _URL();\r\nexport const URLString = newURL.getPathname();","import { Manager } from \"./manager\";\r\nimport { _URL } from \"./url\";\r\n\r\nexport type Trigger = HTMLAnchorElement | \"HistoryManager\" | \"popstate\" | \"back\" | \"forward\";\r\n\r\nexport interface ICoords {\r\n\treadonly x: number;\r\n\treadonly y: number;\r\n}\r\n\r\nexport interface IStateData {\r\n\tscroll: ICoords;\r\n\t[key: string]: any;\r\n}\r\n\r\nexport interface IState {\r\n\turl: _URL;\r\n\tindex?: number;\r\n\ttransition: string;\r\n\tdata: IStateData;\r\n}\r\n\r\n/**\r\n * A quick snapshot of page coordinates, e.g. scroll positions\r\n *\r\n * @export\r\n * @class Coords\r\n * @implements {ICoords}\r\n */\r\nexport class Coords implements ICoords {\r\n\tpublic x: number;\r\n\tpublic y: number;\r\n\r\n\t/**\r\n\t * Creates an instance of Coords.\r\n\t *\r\n\t * @param {number} [x=window.scrollX]\r\n\t * @param {number} [y=window.scrollY]\r\n\t * @memberof Coords\r\n\t */\r\n\tconstructor(x: number = window.scrollX, y: number = window.scrollY) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n}\r\n\r\n/**\r\n * Represents the current status of the page consisting of properties like: url, transition, and data\r\n *\r\n * @export\r\n * @class State\r\n */\r\nexport class State {\r\n\t/**\r\n\t * The current state data\r\n\t *\r\n\t * @private\r\n\t * @type IState\r\n\t * @memberof State\r\n\t */\r\n\tprivate state: IState;\r\n\r\n\t/**\r\n\t * Creates an instance of State.\r\n\t * @param {IState} {\r\n     *         url = new _URL(),\r\n\t *         index = 0,\r\n\t *         transition = \"default\",\r\n\t *         data = {\r\n\t *             scroll: new StateCoords(),\r\n\t *             trigger: \"HistoryManager\"\r\n\t *         }\r\n\t *     }\r\n\t * @memberof State\r\n\t */\r\n\tconstructor(state: IState = {\r\n\t\turl: new _URL(),\r\n\t\tindex: 0,\r\n\t\ttransition: \"default\",\r\n\t\tdata: {\r\n\t\t\tscroll: new Coords(),\r\n\t\t\ttrigger: \"HistoryManager\"\r\n\t\t}\r\n\t}) {\r\n\t\tthis.state = state;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state index\r\n\t *\r\n\t * @returns number\r\n\t * @memberof State\r\n\t */\r\n\tpublic getIndex(): number {\r\n\t\treturn this.state.index;\r\n\t}\r\n\r\n\t/**\r\n\t * Set state index\r\n\t *\r\n\t * @param {number} index\r\n\t * @returns State\r\n\t * @memberof State\r\n\t */\r\n\tpublic setIndex(index: number): State {\r\n\t\tthis.state.index = index;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state URL\r\n\t *\r\n\t * @returns _URL\r\n\t * @memberof State\r\n\t */\r\n\tpublic getURL(): _URL {\r\n\t\treturn this.state.url;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state URL as a string\r\n\t *\r\n\t * @returns string\r\n\t * @memberof State\r\n\t */\r\n\tpublic getURLPathname(): string {\r\n\t\treturn this.state.url.getPathname();\r\n\t}\r\n\r\n\t/**\r\n\t * Get state transition\r\n\t *\r\n\t * @returns string\r\n\t * @memberof State\r\n\t */\r\n\tpublic getTransition(): string {\r\n\t\treturn this.state.transition;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state data\r\n\t *\r\n\t * @returns IStateData\r\n\t * @memberof State\r\n\t */\r\n\tpublic getData(): IStateData {\r\n\t\treturn this.state.data;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the State as an Object\r\n\t *\r\n\t * @returns object\r\n\t * @memberof State\r\n\t */\r\n\tpublic toJSON(): object {\r\n\t\tconst { url, index, transition, data }: IState = this.state;\r\n\t\treturn {\r\n\t\t\turl: url.getFullPath(), index, transition, data\r\n\t\t};\r\n\t}\r\n}\r\n\r\n/**\r\n * History of the site, stores only the State class\r\n *\r\n * @export\r\n * @class HistoryManager\r\n * @extends {Manager<number, State>}\r\n */\r\nexport class HistoryManager extends Manager<number, State> {\r\n\t/**\r\n\t * Creates an instance of the HistoryManager class, which inherits properties and methods from the Storage class.\r\n\t *\r\n\t * @memberof HistoryManager\r\n\t * @constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the index of the state before adding to HistoryManager\r\n\t *\r\n\t * @param {State} value\r\n\t * @returns HistoryManager\r\n\t * @memberof HistoryManager\r\n\t */\r\n\tpublic add(value: State): HistoryManager {\r\n\t\tlet state = value;\r\n\t\tlet index = this.size;\r\n\t\tsuper.add(state);\r\n\t\tstate.setIndex(index);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Quick way to add a State to the HistoryManager\r\n\t *\r\n\t * @param {IState} value\r\n\t * @returns HistoryManager\r\n\t * @memberof HistoryManager\r\n\t */\r\n\tpublic addState(value: IState | State): HistoryManager {\r\n\t\tlet state = value instanceof State ? value : new State(value);\r\n\t\tthis.add(state);\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Manager, ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { _URL, URLString } from \"./url\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Parses strings to DOM\r\n */\r\nexport const PARSER: DOMParser = new DOMParser();\r\n\r\n/**\r\n * A page represents the DOM elements that create each page\r\n *\r\n * @export\r\n * @class Page\r\n */\r\nexport class Page extends ManagerItem {\r\n\t/**\r\n\t * Holds the DOM of the current page\r\n\t *\r\n\t * @private\r\n\t * @type Document\r\n\t * @memberof Page\r\n\t */\r\n    private dom: Document;\r\n\r\n\t/**\r\n\t * Holds the wrapper element to be swapped out of each Page\r\n\t *\r\n\t * @private\r\n\t * @type HTMLElement\r\n\t * @memberof Page\r\n\t */\r\n    private wrapper: HTMLElement;\r\n\r\n\t/**\r\n\t * Holds the title of each page\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Page\r\n\t */\r\n    private title: string;\r\n\r\n\t/**\r\n\t * Holds the head element of each page\r\n\t *\r\n\t * @private\r\n\t * @type Element\r\n\t * @memberof Page\r\n\t */\r\n    private head: Element;\r\n\r\n\t/**\r\n\t * Holds the body element of each page\r\n\t *\r\n\t * @private\r\n\t * @type Element\r\n\t * @memberof Page\r\n\t */\r\n    private body: Element;\r\n\r\n\t/**\r\n\t * The URL of the current page\r\n\t *\r\n\t * @private\r\n\t * @type _URL\r\n\t * @memberof Page\r\n\t */\r\n    private url: _URL;\r\n\r\n\t/**\r\n\t * Creates an instance of Page, it also creates a new page from response text, or a Document Object\r\n\t *\r\n\t * @param {_URL} [url=new _URL()]\r\n\t * @param {(string | Document)} [dom=document]\r\n\t * @memberof Page\r\n\t */\r\n    constructor(url: _URL = new _URL(), dom: string | Document = document) {\r\n        super();\r\n        this.url = url;\r\n        if (typeof dom === \"string\") {\r\n            this.dom = PARSER.parseFromString(dom, \"text/html\");\r\n        } else this.dom = dom || document;\r\n\r\n        const { title, head, body } = this.dom;\r\n        this.title = title;\r\n        this.head = head;\r\n        this.body = body;\r\n    }\r\n\r\n    /**\r\n     * Runs once the the manager and config have been registered\r\n     *\r\n     * @returns void\r\n     * @memberof Page\r\n     */\r\n    public install(): void {\r\n        this.wrapper = this.body.querySelector(this.getConfig(\"wrapperAttr\"));\r\n    }\r\n\r\n\t/**\r\n\t * Returns the current page's URL\r\n\t *\r\n\t * @returns _URL\r\n\t * @memberof Page\r\n\t */\r\n    public getURL(): _URL {\r\n        return this.url;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the current page's URL\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Page\r\n\t */\r\n    public getPathname(): string {\r\n        return this.url.pathname;\r\n    }\r\n\r\n\t/**\r\n\t * The page title\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Page\r\n\t */\r\n    public getTitle(): string {\r\n        return this.title;\r\n    }\r\n\r\n\t/**\r\n\t * The page's head element\r\n\t *\r\n\t * @returns Element\r\n\t * @memberof Page\r\n\t */\r\n    public getHead(): Element {\r\n        return this.head;\r\n    }\r\n\r\n\t/**\r\n\t * The page's body element\r\n\t *\r\n\t * @returns Element\r\n\t * @memberof Page\r\n\t */\r\n    public getBody(): Element {\r\n        return this.body;\r\n    }\r\n\r\n\t/**\r\n\t * The page's wrapper element\r\n\t *\r\n\t * @returns HTMLElement\r\n\t * @memberof Page\r\n\t */\r\n    public getWrapper(): HTMLElement {\r\n        return this.wrapper;\r\n    }\r\n\r\n\t/**\r\n\t * The page's document\r\n\t *\r\n\t * @returns Document\r\n\t * @memberof Page\r\n\t */\r\n    public getDOM(): Document {\r\n        return this.dom;\r\n    }\r\n}\r\n\r\n/**\r\n * Controls which page to be load\r\n *\r\n * @export\r\n * @class PageManager\r\n * @extends {AdvancedManager<string, Page>}\r\n */\r\nexport class PageManager extends AdvancedManager<string, Page> {\r\n    /**\r\n     * Stores all URLs that are currently loading\r\n     *\r\n     * @protected\r\n     * @type Manager<string, Promise<string>>\r\n     * @memberof PageManager\r\n     */\r\n    protected loading: Manager<string, Promise<string>> = new Manager();\r\n\r\n\t/**\r\n\t * Creates an instance of the PageManager\r\n\t *\r\n     * @param {App} app\r\n\t * @memberof PageManager\r\n\t */\r\n    constructor(app: App) {\r\n        super(app);\r\n        this.set(URLString, new Page());\r\n    }\r\n\r\n    /**\r\n     * Returns the loading Manager\r\n     *\r\n     * @returns Manager<string, Promise<string>>\r\n     * @memberof PageManager\r\n     */\r\n    public getLoading(): Manager<string, Promise<string>> {\r\n        return this.loading;\r\n    }\r\n\r\n    /**\r\n     * Load from cache or by requesting URL via a fetch request, avoid requesting for the same thing twice by storing the fetch request in \"this.loading\"\r\n     *\r\n     * @param {(_URL | string)} [_url=new _URL()]\r\n     * @returns Promise<Page>\r\n     * @memberof PageManager\r\n     */\r\n    public async load(_url: _URL | string = new _URL()): Promise<Page> {\r\n        let url: _URL = _url instanceof URL ? _url : new _URL(_url);\r\n        let urlString: string = url.getPathname();\r\n        let page: Page, request: Promise<string>;\r\n        if (this.has(urlString)) {\r\n            page = this.get(urlString);\r\n            return Promise.resolve(page);\r\n        }\r\n\r\n        if (!this.loading.has(urlString)) {\r\n            request = this.request(urlString);\r\n            this.loading.set(urlString, request);\r\n        } else request = this.loading.get(urlString);\r\n\r\n        let response = await request;\r\n        this.loading.delete(urlString);\r\n\r\n        page = new Page(url, response);\r\n        this.set(urlString, page);\r\n        return page;\r\n    }\r\n\r\n    /**\r\n     * Starts a fetch request\r\n     *\r\n     * @param {string} url\r\n     * @returns Promise<string>\r\n     * @memberof PageManager\r\n     */\r\n    public async request(url: string): Promise<string> {\r\n        const headers = new Headers(this.getConfig(\"headers\"));\r\n        const timeout = window.setTimeout(() => {\r\n            window.clearTimeout(timeout);\r\n            throw \"Request Timed Out!\";\r\n        }, this.getConfig(\"timeout\"));\r\n\r\n        try {\r\n            let response = await fetch(url, {\r\n                mode: 'same-origin',\r\n                method: \"GET\",\r\n                headers: headers,\r\n                cache: \"default\",\r\n                credentials: \"same-origin\",\r\n            });\r\n\r\n            window.clearTimeout(timeout);\r\n            if (response.status >= 200 && response.status < 300) {\r\n                return await response.text();\r\n            }\r\n\r\n            const err = new Error(response.statusText || \"\" + response.status);\r\n            throw err;\r\n        } catch (err) {\r\n            window.clearTimeout(timeout);\r\n            throw err;\r\n        }\r\n    }\r\n}","import { Manager } from \"managerjs/src/api\";\r\n\r\nexport type ListenerCallback = (...args: any) => void;\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Listener\r\n */\r\nexport class Listener {\r\n\t/**\r\n\t * The current listener data\r\n\t *\r\n\t * @private\r\n\t * @type IListener\r\n\t * @memberof Listener\r\n\t */\r\n    private listener: IListener;\r\n\r\n\t/**\r\n\t * Creates an instance of Listener.\r\n\t *\r\n\t * @param {IListener} { callback = () => { }, scope = null, name = \"event\" }\r\n\t * @memberof Listener\r\n\t */\r\n    constructor({\r\n        callback = () => { },\r\n        scope = null,\r\n        name = \"event\",\r\n    }: IListener) {\r\n        this.listener = { callback, scope, name };\r\n    }\r\n\r\n\t/**\r\n\t * Returns the callback Function of the Listener\r\n\t *\r\n\t * @returns ListenerCallback\r\n\t * @memberof Listener\r\n\t */\r\n    public getCallback(): ListenerCallback {\r\n        return this.listener.callback;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the scope as an Object, from the Listener\r\n\t *\r\n\t * @returns object\r\n\t * @memberof Listener\r\n\t */\r\n    public getScope(): object {\r\n        return this.listener.scope;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the event as a String, from the Listener\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Listener\r\n\t */\r\n    public getEventName(): string {\r\n        return this.listener.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the listener as an Object\r\n\t *\r\n\t * @returns IListener\r\n\t * @memberof Listener\r\n\t */\r\n    public toJSON(): IListener {\r\n        return this.listener;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, Listener> {\r\n\t/**\r\n\t * The name of the event\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Event\r\n\t */\r\n    private name: string;\r\n\r\n\t/**\r\n\t * Creates an instance of Event.\r\n\t *\r\n\t * @param {string} [name=\"event\"]\r\n\t * @memberof Event\r\n\t */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n\t/**\r\n\t * Creates an instance of EventEmitter.\r\n\t *\r\n\t * @memberof EventEmitter\r\n\t */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n\t * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\t/**\r\n\t * Creates a new listener and adds it to the event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(new Listener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a listener for a given event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from an event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.getEvent(name);\r\n\r\n        if (callback) {\r\n            let i = 0,\r\n                len: number = event.size,\r\n                value: Listener;\r\n            let listener = new Listener({ name, callback, scope });\r\n            for (; i < len; i++) {\r\n                value = event.get(i);\r\n                console.log(value);\r\n                if (\r\n                    value.getCallback() === listener.getCallback() &&\r\n                    value.getScope() === listener.getScope()\r\n                )\r\n                    break;\r\n            }\r\n\r\n            event.delete(i);\r\n        }\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from a given event, or it just completely removes an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach((key) => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            if (_callback) {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a one time event listener for an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public once(\r\n        events: EventInput,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let onceFn: ListenerCallback = (...args) => {\r\n            this.off(events, onceFn, scope);\r\n            callback.apply(scope, args);\r\n        };\r\n\r\n        this.on(events, onceFn, scope);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call all listeners within an event\r\n\t *\r\n\t * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let listeners: Event = this.getEvent(event);\r\n\r\n            const customEvent: CustomEvent<any> = new CustomEvent(event, { detail: args })\r\n            window.dispatchEvent(customEvent);\r\n\r\n            listeners.forEach((listener: Listener) => {\r\n                let { callback, scope }: IListener = listener.toJSON();\r\n                callback.apply(scope, args);\r\n            });\r\n        }, this);\r\n        return this;\r\n    }\r\n}","import { EventEmitter } from \"@okikio/event-emitter/src/api\";\r\nimport { AdvancedManager, ManagerItem } from \"./manager\";\r\nimport { TransitionManager } from \"./transition\";\r\nimport { HistoryManager } from \"./history\";\r\nimport { PageManager } from \"./page\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Controls specific kinds of actions that require JS\r\n *\r\n * @export\r\n * @class Service\r\n */\r\nexport class Service extends ManagerItem {\r\n\t/**\r\n\t * Stores access to the App class's EventEmitter\r\n\t *\r\n\t * @protected\r\n\t * @type EventEmitter\r\n\t * @memberof Service\r\n\t */\r\n\tprotected EventEmitter: EventEmitter;\r\n\r\n\t/**\r\n\t * Stores access to the App class's PageManager\r\n\t *\r\n\t * @protected\r\n\t * @type PageManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected PageManager: PageManager;\r\n\r\n\t/**\r\n\t * Stores access to the App class's HistoryManager\r\n\t *\r\n\t * @protected\r\n\t * @type HistoryManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected HistoryManager: HistoryManager;\r\n\r\n\t/**\r\n\t * Stores the ServiceManager the service is install on\r\n\t *\r\n\t * @protected\r\n\t * @type ServiceManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected ServiceManager: ServiceManager;\r\n\r\n\t/**\r\n\t * Stores access to the App's TransitionManager\r\n\t *\r\n\t * @protected\r\n\t * @type TransitionManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected TransitionManager: TransitionManager;\r\n\r\n\t/**\r\n\t * Method is run once when Service is installed on a ServiceManager\r\n     *\r\n\t * @memberof Service\r\n\t */\r\n\tpublic install(): void {\r\n\t\tlet app = this.manager.getApp();\r\n\t\tthis.PageManager = app.getPages();\r\n\t\tthis.EventEmitter = app.getEmitter();\r\n\t\tthis.HistoryManager = app.getHistory();\r\n\t\tthis.ServiceManager = app.getServices();\r\n\t\tthis.TransitionManager = app.getTransitions();\r\n\t}\r\n\r\n\t// Called on start of Service\r\n\tpublic boot(): void { }\r\n\r\n\t// Initialize events\r\n\tpublic initEvents(): void { }\r\n\r\n\t// Stop events\r\n\tpublic stopEvents(): void { }\r\n\r\n\t// Stop services\r\n\tpublic stop(): void {\r\n\t\tthis.stopEvents();\r\n\t}\r\n}\r\n\r\n/**\r\n * The Service Manager controls the lifecycle of all services in an App\r\n *\r\n * @export\r\n * @class ServiceManager\r\n * @extends {AdvancedManager<number, Service>}\r\n */\r\nexport class ServiceManager extends AdvancedManager<number, Service> {\r\n    /**\r\n     * Creates an instance of ServiceManager.\r\n     *\r\n     * @param {App} app\r\n     * @memberof ServiceManager\r\n     */\r\n\tconstructor(app: App) {\r\n\t\tsuper(app);\r\n\t}\r\n\r\n\t/**\r\n\t * Call the boot method for all Services\r\n\t *\r\n\t * @returns Promise<void>\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic async boot(): Promise<void> {\r\n\t\tawait this.asyncMethodCall(\"boot\");\r\n\t}\r\n\r\n\t/**\r\n\t * Call the initEvents method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic initEvents(): ServiceManager {\r\n\t\tthis.methodCall(\"initEvents\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Call the stopEvents method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic stopEvents(): ServiceManager {\r\n\t\tthis.methodCall(\"stopEvents\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Call the stop method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic stop(): ServiceManager {\r\n\t\tthis.methodCall(\"stop\");\r\n\t\treturn this;\r\n\t}\r\n}","import { EventEmitter } from \"@okikio/event-emitter/src/api\";\r\nimport { AdvancedManager, ManagerItem } from \"./manager\";\r\nimport { Trigger } from \"./history\";\r\nimport { Page } from \"./page\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * The async function type, allows for smooth transition between Promises\r\n */\r\nexport type asyncFn = (err?: any, value?: any) => void;\r\nexport interface ITransition {\r\n    oldPage: Page,\r\n    newPage: Page,\r\n    trigger: Trigger\r\n}\r\nexport interface ITransitionData {\r\n    from?: Page,\r\n    to?: Page,\r\n    trigger?: Trigger,\r\n    done: asyncFn\r\n}\r\n\r\n/**\r\n * Controls the animation between pages\r\n *\r\n * @export\r\n * @class Transition\r\n */\r\nexport class Transition extends ManagerItem {\r\n\t/**\r\n\t * Transition name\r\n\t *\r\n\t * @protected\r\n\t * @type string\r\n\t * @memberof Transition\r\n\t */\r\n    protected name: string = \"Transition\";\r\n\r\n\t/**\r\n\t * The page to transition from\r\n\t *\r\n\t * @protected\r\n\t * @type Page\r\n\t * @memberof Transition\r\n\t */\r\n    protected oldPage: Page;\r\n\r\n\t/**\r\n\t * Page to transition to\r\n\t *\r\n\t * @protected\r\n\t * @type Page\r\n\t * @memberof Transition\r\n\t */\r\n    protected newPage: Page;\r\n\r\n\t/**\r\n\t * What triggered the transition to occur\r\n\t *\r\n\t * @protected\r\n\t * @type Trigger\r\n\t * @memberof Transition\r\n\t */\r\n    protected trigger: Trigger;\r\n\r\n    /**\r\n     * Creates an instance of Transition.\r\n     *\r\n     * @memberof Transition\r\n     */\r\n    constructor() { super(); }\r\n\r\n\t/**\r\n\t * Initialize the transition\r\n\t *\r\n\t * @param {ITransition} {\r\n\t * \t\toldPage,\r\n\t * \t\tnewPage,\r\n\t * \t\ttrigger\r\n\t * \t}\r\n     * @returns Transition\r\n\t * @memberof Transition\r\n\t */\r\n    public init({\r\n        oldPage,\r\n        newPage,\r\n        trigger\r\n    }: ITransition): Transition {\r\n        this.oldPage = oldPage;\r\n        this.newPage = newPage;\r\n        this.trigger = trigger;\r\n        this.boot();\r\n        return this;\r\n    }\r\n\r\n    // Called on start of Transition\r\n    public boot(): void { }\r\n\r\n    // Initialize events\r\n    public initEvents(): void { }\r\n\r\n    // Stop events\r\n    public stopEvents(): void { }\r\n\r\n    // Stop services\r\n    public stop(): void {\r\n        this.stopEvents();\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's name\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Transition\r\n\t */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's old page\r\n\t *\r\n\t * @returns Page\r\n\t * @memberof Transition\r\n\t */\r\n    public getOldPage(): Page {\r\n        return this.oldPage;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's new page\r\n\t *\r\n\t * @returns Page\r\n\t * @memberof Transition\r\n\t */\r\n    public getNewPage(): Page {\r\n        return this.newPage;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's trigger\r\n\t *\r\n\t * @returns Trigger\r\n\t * @memberof Transition\r\n\t */\r\n    public getTrigger(): Trigger {\r\n        return this.trigger;\r\n    }\r\n\r\n    // Based off the highwayjs Transition class\r\n\t/**\r\n\t * Transition from current page\r\n\t *\r\n\t * @param {ITransitionData} { from, trigger, done }\r\n\t * @memberof Transition\r\n\t */\r\n    public out({ done }: ITransitionData): any {\r\n        done();\r\n    }\r\n\r\n\t/**\r\n\t * Transition into the next page\r\n\t *\r\n\t * @param {ITransitionData} { from, to, trigger, done }\r\n\t * @memberof Transition\r\n\t */\r\n    public in({ done }: ITransitionData): any {\r\n        done();\r\n    }\r\n\r\n    /**\r\n     * Starts the transition\r\n     *\r\n     * @returns Promise<Transition>\r\n     * @memberof Transition\r\n     */\r\n    public async start(EventEmitter: EventEmitter): Promise<Transition> {\r\n        let fromWrapper = this.oldPage.getWrapper();\r\n        let toWrapper = this.newPage.getWrapper();\r\n        document.title = this.newPage.getTitle();\r\n\r\n        return new Promise(async finish => {\r\n            EventEmitter.emit(\"BEFORE-TRANSITION-OUT\");\r\n            await new Promise(done => {\r\n                let outMethod: Promise<any> = this.out({\r\n                    from: this.oldPage,\r\n                    trigger: this.trigger,\r\n                    done\r\n                });\r\n\r\n                if (outMethod.then)\r\n                    outMethod.then(done);\r\n            });\r\n\r\n            EventEmitter.emit(\"AFTER-TRANSITION-OUT\");\r\n\r\n            await new Promise(done => {\r\n                fromWrapper.insertAdjacentElement('beforebegin', toWrapper);\r\n                fromWrapper.remove();\r\n                done();\r\n            });\r\n\r\n            EventEmitter.emit(\"BEFORE-TRANSITION-IN\");\r\n\r\n            await new Promise(done => {\r\n                let inMethod: Promise<any> = this.in({\r\n                    from: this.oldPage,\r\n                    to: this.newPage,\r\n                    trigger: this.trigger,\r\n                    done\r\n                });\r\n\r\n                if (inMethod.then)\r\n                    inMethod.then(done);\r\n            });\r\n\r\n            EventEmitter.emit(\"AFTER_TRANSITION_IN\");\r\n            finish();\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Controls which animation between pages to use\r\n *\r\n * @export\r\n * @class TransitionManager\r\n * @extends {AdvancedManager<string, Transition>}\r\n */\r\nexport class TransitionManager extends AdvancedManager<string, Transition> {\r\n\t/**\r\n\t * Creates an instance of the TransitionManager\r\n\t *\r\n     * @param {App} app\r\n\t * @memberof TransitionManager\r\n\t */\r\n    constructor(app: App) { super(app); }\r\n\r\n\t/**\r\n\t * Quick way to add a Transition to the TransitionManager\r\n\t *\r\n\t * @param {Transition} value\r\n\t * @returns TransitionManager\r\n\t * @memberof TransitionManager\r\n\t */\r\n    public add(value: Transition): TransitionManager {\r\n        let name = value.getName();\r\n        this.set(name, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Runs a transition\r\n     *\r\n     * @param {{ name: string, oldPage: Page, newPage: Page, trigger: Trigger }} { name, oldPage, newPage, trigger }\r\n     * @returns Promise<void>\r\n     * @memberof TransitionManager\r\n     */\r\n    public async boot({ name, oldPage, newPage, trigger }: { name: string, oldPage: Page, newPage: Page, trigger: Trigger }): Promise<Transition> {\r\n        let transition: Transition = this.get(name);\r\n        transition.init({\r\n            oldPage,\r\n            newPage,\r\n            trigger\r\n        });\r\n\r\n        let EventEmitter = this.getApp().getEmitter();\r\n        return await transition.start(EventEmitter);\r\n    }\r\n\r\n\t/**\r\n\t * Call the initEvents method for all Transitions\r\n\t *\r\n\t * @returns TransitionManager\r\n\t * @memberof TransitionManager\r\n\t */\r\n    public initEvents(): TransitionManager {\r\n        this.methodCall(\"initEvents\");\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call the stopEvents method for all Transitions\r\n\t *\r\n\t * @returns TransitionManager\r\n\t * @memberof TransitionManager\r\n\t */\r\n    public stopEvents(): TransitionManager {\r\n        this.methodCall(\"stopEvents\");\r\n        return this;\r\n    }\r\n}","import { ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { Service } from \"./service\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Services that interact with specific Components to achieve certain actions\r\n *\r\n * @export\r\n * @class Block\r\n * @extends {Service}\r\n */\r\nexport class Block extends Service {\r\n    /**\r\n     * The name of the Block\r\n     *\r\n     * @protected\r\n     * @type string\r\n     * @memberof Block\r\n     */\r\n    protected name: string;\r\n\r\n    /**\r\n     * Query selector string \r\n     *\r\n     * @protected\r\n     * @type string\r\n     * @memberof Block\r\n     */\r\n    protected selector: string;\r\n\r\n    /**\r\n     * Index of Block in a BlockManager \r\n     *\r\n     * @protected\r\n     * @type number\r\n     * @memberof Block\r\n     */\r\n    protected index: number;\r\n\r\n    /**\r\n     * The Root Element of a Block\r\n     *\r\n     * @protected\r\n     * @type HTMLElement\r\n     * @memberof Block\r\n     */\r\n    protected rootElement: HTMLElement;\r\n\r\n    /**\r\n     * It initializes the Block\r\n     *\r\n     * @param {string} [name]\r\n     * @param {HTMLElement} [rootElement]\r\n     * @param {string} [selector]\r\n     * @param {number} [index]\r\n     * @memberof Block\r\n     */\r\n    public init(name?: string, rootElement?: HTMLElement, selector?: string, index?: number) {\r\n        this.rootElement = rootElement;\r\n        this.name = name;\r\n        this.selector = selector;\r\n        this.index = index;\r\n    }\r\n\r\n    /**\r\n     * Get Root Element\r\n     *\r\n     * @returns HTMLElement\r\n     * @memberof Block\r\n     */\r\n    public getRootElement(): HTMLElement {\r\n        return this.rootElement;\r\n    }\r\n\r\n    /**\r\n     * Get Selector\r\n     *\r\n     * @returns string\r\n     * @memberof Block\r\n     */\r\n    public getSelector(): string {\r\n        return this.selector;\r\n    }\r\n\r\n    /**\r\n     * Get Index\r\n     *\r\n     * @returns number\r\n     * @memberof Block\r\n     */\r\n    public getIndex(): number {\r\n        return this.index;\r\n    }\r\n\r\n    /**\r\n     * Get the name of the Block\r\n     *\r\n     * @returns string\r\n     * @memberof Block\r\n     */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new Block Intent Class\r\n *\r\n * @export\r\n * @class BlockIntent\r\n * @extends {ManagerItem}\r\n */\r\nexport class BlockIntent extends ManagerItem {\r\n    /**\r\n     * The name of the Block\r\n     *\r\n     * @protected\r\n     * @type string\r\n     * @memberof BlockIntent\r\n     */\r\n    protected name: string;\r\n\r\n    /**\r\n     * The Block Class\r\n     *\r\n     * @protected\r\n     * @type {typeof Block}\r\n     * @memberof BlockIntent\r\n     */\r\n    protected block: typeof Block;\r\n\r\n    /**\r\n     * Creates an instance of BlockIntent.\r\n     *\r\n     * @param {string} name\r\n     * @param {typeof Block} block\r\n     * @memberof BlockIntent\r\n     */\r\n    constructor(name: string, block: typeof Block) {\r\n        super();\r\n        this.name = name;\r\n        this.block = block;\r\n    }\r\n\r\n    /**\r\n     * Getter for name of Block Intent\r\n     *\r\n     * @returns string\r\n     * @memberof BlockIntent\r\n     */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Getter for the Block of the Block Intent\r\n     *\r\n     * @returns {typeof Block}\r\n     * @memberof BlockIntent\r\n     */\r\n    public getBlock(): typeof Block {\r\n        return this.block;\r\n    }\r\n}\r\n\r\n/**\r\n * A Service Manager designed to handle only Block Services, it refreshes on Page Change\r\n *\r\n * @export\r\n * @class BlockManager\r\n * @extends {AdvancedManager<number, BlockIntent>}\r\n */\r\nexport class BlockManager extends AdvancedManager<number, BlockIntent> {\r\n    /**\r\n     * A list of Active Blocks \r\n     *\r\n     * @protected\r\n     * @type {AdvancedManager<number, Block>}\r\n     * @memberof BlockManager\r\n     */\r\n    protected activeBlocks: AdvancedManager<number, Block>;\r\n\r\n    /**\r\n     * Creates an instance of BlockManager.\r\n     *\r\n     * @param {App} app\r\n     * @memberof BlockManager\r\n     */\r\n    constructor(app: App) {\r\n        super(app);\r\n        this.activeBlocks = new AdvancedManager(app);\r\n    }\r\n\r\n\t/**\r\n\t * Initialize all Blocks\r\n\t *\r\n\t * @memberof BlockManager\r\n\t */\r\n    public init() {\r\n        this.forEach((intent: BlockIntent) => {\r\n            let name: string = intent.getName();\r\n            let block: typeof Block = intent.getBlock();\r\n            let selector: string = `[${this.getConfig(\"blockAttr\", false)}=\"${name}\"]`;\r\n            let rootElements: Node[] = [...document.querySelectorAll(selector)];\r\n\r\n            for (let i = 0, len = rootElements.length; i < len; i++) {\r\n                let newInstance: Block = new block();\r\n                newInstance.init(name, rootElements[i] as HTMLElement, selector, i);\r\n                this.activeBlocks.set(i, newInstance);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Getter for activeBlocks in BlockManager\r\n     *\r\n     * @returns\r\n     * @memberof BlockManager\r\n     */\r\n    public getActiveBlocks() {\r\n        return this.activeBlocks;\r\n    }\r\n\r\n\t/**\r\n\t * Call the boot method for all Blocks\r\n\t *\r\n\t * @returns Promise<void>\r\n\t * @memberof BlockManager\r\n\t */\r\n    public async boot(): Promise<void> {\r\n        await this.activeBlocks.asyncMethodCall(\"boot\");\r\n    }\r\n\r\n    /**\r\n     * Refreshes DOM Elements\r\n     *\r\n     * @memberof BlockManager\r\n     */\r\n    public refresh() {\r\n        const EventEmitter = this.getApp().getEmitter();\r\n        EventEmitter.on(\"BEFORE_TRANSITION_OUT\", () => {\r\n            this.stop();\r\n        });\r\n\r\n        EventEmitter.on(\"AFTER_TRANSITION_IN\", () => {\r\n            this.init();\r\n            this.boot();\r\n            // this.activeBlocks.methodCall(\"initEvents\");\r\n        });\r\n    }\r\n\r\n\t/**\r\n\t * Call the initEvents method for all Blocks\r\n\t *\r\n\t * @returns BlockManager\r\n\t * @memberof BlockManager\r\n\t */\r\n    public initEvents(): BlockManager {\r\n        this.activeBlocks.methodCall(\"initEvents\");\r\n        this.refresh();\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call the stopEvents method for all Blocks\r\n\t *\r\n\t * @returns BlockManager\r\n\t * @memberof BlockManager\r\n\t */\r\n    public stopEvents(): BlockManager {\r\n        this.activeBlocks.methodCall(\"stopEvents\");\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call the stop method for all Blocks\r\n\t *\r\n\t * @returns BlockManager\r\n\t * @memberof BlockManager\r\n\t */\r\n    public stop(): BlockManager {\r\n        this.activeBlocks.methodCall(\"stop\");\r\n        this.activeBlocks.clear();\r\n        return this;\r\n    }\r\n}","import { EventEmitter, ListenerCallback, EventInput } from \"@okikio/event-emitter/src/api\";\r\nimport { TransitionManager, Transition } from \"./transition\";\r\nimport { BlockManager, BlockIntent, Block } from \"./block\";\r\nimport { HistoryManager, State, IState } from \"./history\";\r\nimport { ServiceManager, Service } from \"./service\";\r\nimport { PageManager, Page } from \"./page\";\r\nimport { CONFIG, ICONFIG } from \"./config\";\r\n\r\n/**\r\n * The App class starts the entire process, it controls all managers and all services\r\n *\r\n * @export\r\n * @class App\r\n */\r\nexport class App {\r\n    /**\r\n     * A new instance of the HistoryManager\r\n     *\r\n     * @protected\r\n     * @type HistoryManager\r\n     * @memberof App\r\n     */\r\n    protected history: HistoryManager;\r\n\r\n    /**\r\n     * A new instance of the TransitionManager\r\n     *\r\n     * @protected\r\n     * @type TransitionManager\r\n     * @memberof App\r\n     */\r\n    protected transitions: TransitionManager;\r\n\r\n    /**\r\n     * A new instance of the ServiceManager\r\n     *\r\n     * @protected\r\n     * @type ServiceManager\r\n     * @memberof App\r\n     */\r\n    protected services: ServiceManager;\r\n\r\n    /**\r\n     * A new instance of the BlockManager\r\n     *\r\n     * @protected\r\n     * @type BlockManager\r\n     * @memberof App\r\n     */\r\n    protected blocks: BlockManager;\r\n\r\n    /**\r\n     * A new instance of an EventEmitter\r\n     *\r\n     * @protected\r\n     * @type EventEmitter\r\n     * @memberof App\r\n     */\r\n    protected emitter: EventEmitter;\r\n\r\n    /**\r\n     * A new instance of the PageManager\r\n     *\r\n     * @protected\r\n     * @type PageManager\r\n     * @memberof App\r\n     */\r\n    protected pages: PageManager;\r\n\r\n    /**\r\n     * The current Configuration's for the framework\r\n     *\r\n     * @protected\r\n     * @type CONFIG\r\n     * @memberof App\r\n     */\r\n    protected config: CONFIG;\r\n\r\n    /**\r\n     * Creates an instance of App.\r\n     *\r\n     * @param {(ICONFIG | CONFIG)} [config={}]\r\n     * @memberof App\r\n     */\r\n    constructor(config: object = {}) {\r\n        this.register(config);\r\n    }\r\n\r\n    /**\r\n     * For registering all managers and the configurations\r\n     *\r\n     * @param {(ICONFIG | CONFIG)} [config={}]\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public register(config: ICONFIG | CONFIG = {}): App {\r\n        this.config = config instanceof CONFIG ? config : new CONFIG(config);\r\n        this.transitions = new TransitionManager(this);\r\n        this.services = new ServiceManager(this);\r\n        this.blocks = new BlockManager(this);\r\n        this.history = new HistoryManager();\r\n        this.pages = new PageManager(this);\r\n        this.emitter = new EventEmitter();\r\n\r\n        let handler = (() => {\r\n            document.removeEventListener(\"DOMContentLoaded\", handler);\r\n            window.removeEventListener(\"load\", handler);\r\n            this.emitter.emit(\"READY ready\");\r\n        }).bind(this);\r\n\r\n        document.addEventListener(\"DOMContentLoaded\", handler);\r\n        window.addEventListener(\"load\", handler);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the current configurations for the framework\r\n     *\r\n     * @param {...any} args\r\n     * @returns any\r\n     * @memberof App\r\n     */\r\n    public getConfig(...args: any): any {\r\n        return this.config.getConfig(...args);\r\n    }\r\n\r\n    /**\r\n     * Return the App's EventEmitter\r\n     *\r\n     * @returns EventEmitter\r\n     * @memberof App\r\n     */\r\n    public getEmitter(): EventEmitter {\r\n        return this.emitter;\r\n    }\r\n\r\n    /**\r\n     * Returns the App's BlockManager\r\n     *\r\n     * @returns BlockManager\r\n     * @memberof App\r\n     */\r\n    public getBlocks(): BlockManager {\r\n        return this.blocks;\r\n    }\r\n\r\n    /**\r\n     * Return the App's ServiceManager\r\n     *\r\n     * @returns ServiceManager\r\n     * @memberof App\r\n     */\r\n    public getServices(): ServiceManager {\r\n        return this.services;\r\n    }\r\n\r\n    /**\r\n     * Return the App's PageManager\r\n     *\r\n     * @returns PageManager\r\n     * @memberof App\r\n     */\r\n    public getPages(): PageManager {\r\n        return this.pages;\r\n    }\r\n\r\n    /**\r\n     * Return the App's TransitionManager\r\n     *\r\n     * @returns TransitionManager\r\n     * @memberof App\r\n     */\r\n    public getTransitions(): TransitionManager {\r\n        return this.transitions;\r\n    }\r\n\r\n    /**\r\n     * Return the App's HistoryManager\r\n     *\r\n     * @returns HistoryManager\r\n     * @memberof App\r\n     */\r\n    public getHistory(): HistoryManager {\r\n        return this.history;\r\n    }\r\n\r\n    /**\r\n     * Returns a Block Intent Object from the App's instance of the BlockManager\r\n     *\r\n     * @param {number} key\r\n     * @returns IBlockIntent\r\n     * @memberof App\r\n     */\r\n    public getBlock(key: number): BlockIntent {\r\n        return this.blocks.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns an instance of a Block from the App's instance of the BlockManager\r\n     *\r\n     * @param {number} key\r\n     * @returns Block\r\n     * @memberof App\r\n     */\r\n    public getActiveBlock(key: number): Block {\r\n        return this.blocks.getActiveBlocks().get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns a Service from the App's instance of the ServiceManager\r\n     *\r\n     * @param {number} key\r\n     * @returns Service\r\n     * @memberof App\r\n     */\r\n    public getService(key: number): Service {\r\n        return this.services.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns a Transition from the App's instance of the TransitionManager\r\n     *\r\n     * @param {string} key\r\n     * @returns Transition\r\n     * @memberof App\r\n     */\r\n    public getTransition(key: string): Transition {\r\n        return this.transitions.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns a State from the App's instance of the HistoryManager\r\n     *\r\n     * @param {number} key\r\n     * @returns State\r\n     * @memberof App\r\n     */\r\n    public getState(key: number): State {\r\n        return this.history.get(key);\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will return either a Transition, a Service, or a State from their respective Managers\r\n     *\r\n     * @param {(\"service\" | \"transition\" | \"state\" | \"block\" | string)} type\r\n     * @param {any} key\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public get(type: \"service\" | \"transition\" | \"state\" | \"block\" | string, key: any): App {\r\n        switch (type.toLowerCase()) {\r\n            case \"service\":\r\n                this.getService(key);\r\n                break;\r\n            case \"transition\":\r\n                this.getTransition(key);\r\n                break;\r\n            case \"state\":\r\n                this.getState(key);\r\n                break;\r\n            case \"block\":\r\n                this.getActiveBlock(key);\r\n                break;\r\n            default:\r\n                throw `Error: can't get type '${type}', it is not a recognized type. Did you spell it correctly.`;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a Page\r\n     *\r\n     * @param {string} url\r\n     * @returns Promise<Page>\r\n     * @memberof App\r\n     */\r\n    public async loadPage(url: string): Promise<Page> {\r\n        return await this.pages.load(url);\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will return load a Transition, a Service, a State, or a Page from their respective Managers\r\n     *\r\n     * @param {(\"page\" | string)} type\r\n     * @param {any} key\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public async load(type: \"page\" | string, key: any): Promise<any> {\r\n        switch (type.toLowerCase()) {\r\n            case \"page\":\r\n                return await this.loadPage(key);\r\n            default:\r\n                return Promise.resolve(this.get(type, key));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a Block Intent to the App's instance of the BlockManager\r\n     *\r\n     * @param {BlockIntent} blockIntent\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addBlock(blockIntent: BlockIntent): App {\r\n        this.blocks.add(blockIntent);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a Service to the App's instance of the ServiceManager\r\n     *\r\n     * @param {Service} service\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addService(service: Service): App {\r\n        this.services.add(service);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a Transition to the App's instance of the TransitionManager\r\n     *\r\n     * @param {Transition} transition\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addTransition(transition: Transition): App {\r\n        this.transitions.add(transition);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a State to the App's instance of the HistoryManager\r\n     *\r\n     * @param {(IState | State)} state\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addState(state: IState | State): App {\r\n        this.history.addState(state);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will add either a Transition, a Service, or a State to their respective Managers\r\n     *\r\n     * @param {(\"service\" | \"transition\" | \"state\")} type\r\n     * @param {any} value\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public add(type: \"service\" | \"transition\" | \"state\" | \"block\", value: any): App {\r\n        switch (type.toLowerCase()) {\r\n            case \"service\":\r\n                this.addService(value);\r\n                break;\r\n            case \"transition\":\r\n                this.addTransition(value);\r\n                break;\r\n            case \"state\":\r\n                this.addState(value);\r\n                break;\r\n            case \"block\":\r\n                this.addBlock(value);\r\n                break;\r\n            default:\r\n                throw `Error: can't add type '${type}', it is not a recognized type. Did you spell it correctly.`;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Start the App and the ServiceManager\r\n     *\r\n     * @returns Promise<App>\r\n     * @memberof App\r\n     */\r\n    public async boot(): Promise<App> {\r\n        this.blocks.init();\r\n        await this.services.boot();\r\n        await this.blocks.boot();\r\n        this.services.initEvents();\r\n        this.blocks.initEvents();\r\n        this.transitions.initEvents();\r\n        return Promise.resolve(this);\r\n    }\r\n\r\n    /**\r\n     * Stop the App and the ServiceManager\r\n     *\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public stop(): App {\r\n        this.services.stop();\r\n        this.blocks.stop();\r\n        this.transitions.stopEvents();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the current page in the PageManager\r\n     *\r\n     * @returns Page\r\n     * @memberof App\r\n     */\r\n    public currentPage(): Page {\r\n        let currentState = this.history.last();\r\n        return this.pages.get(currentState.getURLPathname());\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter on method\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public on(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.on(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter off method\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public off(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.off(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter once method\r\n     *\r\n     * @param {string} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public once(events: string, callback: ListenerCallback): App {\r\n        this.emitter.once(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter emit method\r\n     *\r\n     * @param {(string | any[])} events\r\n     * @param {...any} args\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public emit(events: string | any[], ...args: any): App {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n}\r\n","import { State, Trigger, IState, Coords } from \"./history\";\r\nimport { Service } from \"./service\";\r\nimport { Page } from \"./page\";\r\nimport { _URL } from \"./url\";\r\n\r\nexport type LinkEvent = MouseEvent | TouchEvent;\r\nexport type StateEvent = LinkEvent | PopStateEvent;\r\nexport type IgnoreURLsList = Array<RegExp | string>;\r\n\r\n/**\r\n * Creates a Barba JS like PJAX Service, for the Framework\r\n *\r\n * @export\r\n * @class PJAX\r\n * @extends {Service}\r\n */\r\n// Based on Barba JS and StartingBlocks\r\nexport class PJAX extends Service {\r\n    /**\r\n     * URLs to ignore when prefetching\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected ignoreURLs: IgnoreURLsList = [];\r\n\r\n    /**\r\n     * Whether or not to disable prefetching\r\n     *\r\n     * @private\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    protected prefetchIgnore: boolean = false;\r\n\r\n    /**\r\n     * Current state or transitions\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected isTransitioning: boolean = false;\r\n\r\n    /**\r\n     * Ignore extra clicks of an anchor element if a transition has already started\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected stopOnTransitioning: boolean = false;\r\n\r\n    /**\r\n     * On page change (excluding popstate event) keep current scroll position\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected stickyScroll: boolean = true;\r\n\r\n    /**\r\n     * Force load a page if an error occurs\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected forceOnError: boolean = false;\r\n\r\n    /**\r\n     * Dictates whether to auto scroll if an hash is present in the window URL\r\n     *\r\n     * @protected\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected autoScrollOnHash: boolean = true;\r\n\r\n    /**\r\n     * Sets the transition state, sets isTransitioning to true\r\n     *\r\n     * @private\r\n     * @memberof PJAX\r\n     */\r\n    private transitionStart() {\r\n        this.isTransitioning = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition state, sets isTransitioning to false\r\n     *\r\n     * @private\r\n     * @memberof PJAX\r\n     */\r\n    private transitionStop() {\r\n        this.isTransitioning = false;\r\n    }\r\n\r\n    /**\r\n     * Starts the PJAX Service\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public boot() {\r\n        let current = new State();\r\n        this.HistoryManager.add(current);\r\n        this.changeState(\"replace\", current);\r\n    }\r\n\r\n    /**\r\n     * Gets the transition to use for a certain anchor\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {(string | null)}\r\n     * @memberof PJAX\r\n     */\r\n    public getTransitionName(el: HTMLAnchorElement): string | null {\r\n        if (!el || !el.getAttribute) return null;\r\n        let transitionAttr = el.getAttribute(this.getConfig(\"transitionAttr\", false));\r\n        if (typeof transitionAttr === 'string')\r\n            return transitionAttr;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the anchor is valid\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @param {(LinkEvent | KeyboardEvent)} event\r\n     * @param {string} href\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public validLink(el: HTMLAnchorElement, event: LinkEvent | KeyboardEvent, href: string): boolean {\r\n        let pushStateSupport = !window.history.pushState;\r\n        let exists = !el || !href;\r\n        let eventMutate =\r\n            (event as KeyboardEvent).which > 1 ||\r\n            (event as KeyboardEvent).metaKey ||\r\n            (event as KeyboardEvent).ctrlKey ||\r\n            (event as KeyboardEvent).shiftKey ||\r\n            (event as KeyboardEvent).altKey;\r\n        let newTab = el.hasAttribute('target') && (el as HTMLAnchorElement).target === '_blank';\r\n        let crossOrigin =\r\n            ((el as HTMLAnchorElement).protocol !== location.protocol) ||\r\n            ((el as HTMLAnchorElement).hostname !== location.hostname);\r\n        let download = typeof el.getAttribute('download') === 'string';\r\n        let preventSelf = el.hasAttribute(this.getConfig(\"preventSelfAttr\", false));\r\n        let preventAll = Boolean(\r\n            el.closest(this.getConfig(\"preventAllAttr\"))\r\n        );\r\n        let prevent = preventSelf && preventAll;\r\n        let sameURL = new _URL().getFullPath() === new _URL(href).getFullPath();\r\n        return !(exists || pushStateSupport || eventMutate || newTab || crossOrigin || download || prevent || sameURL);\r\n    }\r\n\r\n    /**\r\n     * Returns the href or an Anchor element\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {(string | null)}\r\n     * @memberof PJAX\r\n     */\r\n    public getHref(el: HTMLAnchorElement): string | null {\r\n        if (el && el.tagName && el.tagName.toLowerCase() === 'a' && typeof el.href === 'string')\r\n            return el.href;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if event target is a valid anchor with an href, if so, return the link\r\n     *\r\n     * @param {LinkEvent} event\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public getLink(event: LinkEvent): HTMLAnchorElement {\r\n        let el = event.target as HTMLAnchorElement;\r\n        let href: string = this.getHref(el);\r\n\r\n        while (el && !href) {\r\n            el = (el as HTMLElement).parentNode as HTMLAnchorElement;\r\n            href = this.getHref(el);\r\n        }\r\n\r\n        // Check for a valid link\r\n        if (!el || !this.validLink(el, event, href)) return;\r\n        return el;\r\n    }\r\n\r\n    /**\r\n     * When an element is clicked.\r\n     *\r\n     * Get valid anchor element.\r\n     * Go for a transition.\r\n     *\r\n     * @param {LinkEvent} event\r\n     * @returns\r\n     * @memberof PJAX\r\n     */\r\n    public onClick(event: LinkEvent) {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        if (this.isTransitioning && this.stopOnTransitioning) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            return;\r\n        }\r\n\r\n        let href = this.getHref(el);\r\n        this.EventEmitter.emit(\"ANCHOR-CLICK CLICK click\", event);\r\n        this.go({ href, trigger: el, event });\r\n    }\r\n\r\n    /**\r\n     * Returns the direction of the State change as a String, either the Back button or the Forward button\r\n     *\r\n     * @param {number} value\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public getDirection(value: number): Trigger {\r\n        if (Math.abs(value) > 1) {\r\n            // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\r\n            return value > 0 ? 'forward' : 'back';\r\n        } else {\r\n            if (value === 0) {\r\n                return 'popstate';\r\n            } else {\r\n                // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\r\n                return value > 0 ? 'back' : 'forward';\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force a page to go to a certain URL\r\n     *\r\n     * @param {string} href\r\n     * @memberof PJAX\r\n     */\r\n    public force(href: string): void {\r\n        window.location.assign(href);\r\n    }\r\n\r\n    /**\r\n     * If transition is running force load page.\r\n     * Stop if currentURL is the same as new url.\r\n     * On state change, change the current state history,\r\n     * to reflect the direction of said state change\r\n     * Load page and page transition.\r\n     *\r\n     * @param {string} href\r\n     * @param {Trigger} [trigger='HistoryManager']\r\n     * @param {StateEvent} [event]\r\n     * @memberof PJAX\r\n     */\r\n    public go({ href, trigger = 'HistoryManager', event }: { href: string; trigger?: Trigger; event?: StateEvent; }): Promise<void> {\r\n        // If transition is already running and the go method is called again, force load page\r\n        if (this.isTransitioning && this.stopOnTransitioning) {\r\n            this.force(href);\r\n            return;\r\n        }\r\n\r\n        let url = new _URL(href);\r\n        let currentState = this.HistoryManager.last();\r\n        let currentURL = currentState.getURL();\r\n        if (currentURL.equalTo(url)) {\r\n            this.hashAction(url.hash);\r\n            return;\r\n        }\r\n\r\n        let transitionName: string;\r\n        if (event && (event as PopStateEvent).state) {\r\n            this.EventEmitter.emit(\"POPSTATE\", event);\r\n\r\n            // If popstate, get back/forward direction.\r\n            let { state }: { state: IState } = event as PopStateEvent;\r\n            let { index, transition, data } = state;\r\n            let currentIndex = currentState.getIndex();\r\n            let difference = currentIndex - index;\r\n\r\n            trigger = this.getDirection(difference);\r\n            transitionName = transition;\r\n\r\n            // If page remains the same on state change DO NOT run this, it's pointless\r\n            if (trigger !== \"popstate\") {\r\n                // Keep scroll position\r\n                let { x, y } = data.scroll;\r\n                window.scroll({\r\n                    top: y, left: x,\r\n                    behavior: 'smooth'  // 👈 \r\n                });\r\n            }\r\n\r\n            // Based on the direction of the state change either remove or add a state\r\n            if (trigger === \"back\") {\r\n                this.HistoryManager.delete(currentIndex);\r\n                this.EventEmitter.emit(`POPSTATE-BACK`, event);\r\n            } else if (trigger === \"forward\") {\r\n                this.HistoryManager.addState({ url, transition, data });\r\n                this.EventEmitter.emit(`POPSTATE-FORWARD`, event);\r\n            }\r\n        } else {\r\n            // Add new state\r\n            transitionName = this.getTransitionName(trigger as HTMLAnchorElement) || \"default\";\r\n            const scroll = new Coords();\r\n            const index = this.HistoryManager.size;\r\n            const state = new State({\r\n                url, index,\r\n                transition: transitionName,\r\n                data: { scroll }\r\n            });\r\n\r\n            if (this.stickyScroll) {\r\n                // Keep scroll position\r\n                let { x, y } = scroll;\r\n                window.scroll({\r\n                    top: y, left: x,\r\n                    behavior: 'smooth'  // 👈 \r\n                });\r\n            } else {\r\n                window.scroll({\r\n                    top: 0, left: 0,\r\n                    behavior: 'smooth'  // 👈 \r\n                });\r\n            }\r\n\r\n            this.HistoryManager.add(state);\r\n            this.changeState(\"push\", state);\r\n            this.EventEmitter.emit(\"HISTORY-NEW-ITEM\", event);\r\n        }\r\n\r\n        if (event) {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n\r\n        this.EventEmitter.emit(\"GO go\", event);\r\n        return this.load({ oldHref: currentURL.getPathname(), href, trigger, transitionName });\r\n    }\r\n\r\n    /**\r\n     * Either push or replace history state\r\n     *\r\n     * @param {(\"push\" | \"replace\")} action\r\n     * @param {IState} state\r\n     * @param {_URL} url\r\n     * @memberof PJAX\r\n     */\r\n    public changeState(action: \"push\" | \"replace\", state: State) {\r\n        let url = state.getURL();\r\n        let href = url.getFullPath();\r\n        let json = state.toJSON();\r\n        let args = [json, '', href];\r\n        if (window.history) {\r\n            switch (action) {\r\n                case 'push':\r\n                    window.history.pushState.apply(window.history, args);\r\n                    break;\r\n                case 'replace':\r\n                    window.history.replaceState.apply(window.history, args);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the new Page as well as a Transition; run the Transition\r\n     *\r\n     * @param {string} oldHref\r\n     * @param {string} href\r\n     * @param {Trigger} trigger\r\n     * @param {string} [transitionName=\"default\"]\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public async load({ oldHref, href, trigger, transitionName = \"default\" }: { oldHref: string; href: string; trigger: Trigger; transitionName?: string; }): Promise<any> {\r\n        try {\r\n            let oldPage = this.PageManager.get(oldHref);\r\n            let newPage: Page;\r\n\r\n            this.EventEmitter.emit(\"PAGE-LOADING\", { href, oldPage, trigger });\r\n            try {\r\n                try {\r\n                    newPage = await this.PageManager.load(href);\r\n                    this.transitionStart();\r\n                    this.EventEmitter.emit(\"PAGE-LOAD-COMPLETE\", { newPage, oldPage, trigger });\r\n                } catch (err) {\r\n                    throw `[PJAX] Page load error: ${err}`;\r\n                }\r\n\r\n                // --\r\n                // --\r\n\r\n                this.EventEmitter.emit(\"NAVIGATION-START\", { oldPage, newPage, trigger, transitionName });\r\n                try {\r\n                    this.EventEmitter.emit(\"TRANSITION-START\", transitionName);\r\n                    let transition = await this.TransitionManager.boot({\r\n                        name: transitionName,\r\n                        oldPage,\r\n                        newPage,\r\n                        trigger\r\n                    });\r\n\r\n                    this.EventEmitter.emit(\"TRANSITION-END\", { transition });\r\n                } catch (err) {\r\n                    throw `[PJAX] Transition error: ${err}`;\r\n                }\r\n\r\n                this.EventEmitter.emit(\"NAVIGATION-END\", { oldPage, newPage, trigger, transitionName });\r\n                this.hashAction();\r\n            } catch (err) {\r\n                this.transitionStop();\r\n                throw err;\r\n            }\r\n\r\n            this.transitionStop(); // Sets isTransitioning to false\r\n        } catch (err) {\r\n            if (this.forceOnError) this.force(href);\r\n            else console.error(err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Auto scrolls to an elements position if the element has an hash\r\n     *\r\n     * @param {string} [hash=window.location.hash]\r\n     * @memberof PJAX\r\n     */\r\n    public hashAction(hash: string = window.location.hash) {\r\n        if (this.autoScrollOnHash) {\r\n            let hashID = hash.slice(1);\r\n\r\n            if (hashID.length) {\r\n                let el = document.getElementById(hashID);\r\n\r\n                if (el) {\r\n                    if (el.scrollIntoView) {\r\n                        el.scrollIntoView({ behavior: 'smooth' });\r\n                    } else {\r\n                        let { left, top } = el.getBoundingClientRect();\r\n                        window.scroll({ left, top, behavior: 'smooth' });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check to see if the URL is to be ignored, uses either RegExp of Strings to check\r\n     *\r\n     * @param {_URL} { pathname }\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public ignoredURL({ pathname }: _URL): boolean {\r\n        return this.ignoreURLs.length && this.ignoreURLs.some(url => {\r\n            return typeof url === \"string\" ? url === pathname : (url as RegExp).exec(pathname) !== null;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * When you hover over an anchor, prefetch the event target's href\r\n     *\r\n     * @param {LinkEvent} event\r\n     * @memberof PJAX\r\n     */\r\n    public onHover(event: LinkEvent): Promise<void> {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        const url = new _URL(this.getHref(el));\r\n        const urlString: string = url.getPathname();\r\n        // If Url is ignored or already in cache, don't do any think\r\n        if (this.ignoredURL(url) || this.PageManager.has(urlString)) return;\r\n\r\n        this.EventEmitter.emit(\"ANCHOR-HOVER HOVER hover\", event);\r\n\r\n        (async () => {\r\n            try {\r\n                await this.PageManager.load(url);\r\n            } catch (err) {\r\n                console.warn(\"[PJAX] Prefetch error: \", err);\r\n            }\r\n        })();\r\n    }\r\n\r\n    /**\r\n     * When History state changes.\r\n     *\r\n     * Get url from State\r\n     * Go for a Barba transition.\r\n     *\r\n     * @param {PopStateEvent} event\r\n     * @memberof PJAX\r\n     */\r\n    public onStateChange(event: PopStateEvent): void {\r\n        this.go({ href: window.location.href, trigger: 'popstate', event });\r\n    }\r\n\r\n    /**\r\n     * Bind the event listeners to the PJAX class\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public bindEvents() {\r\n        this.onHover = this.onHover.bind(this);\r\n        this.onClick = this.onClick.bind(this);\r\n        this.onStateChange = this.onStateChange.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Initialize DOM Events\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public initEvents() {\r\n        this.bindEvents();\r\n\r\n        if (this.prefetchIgnore !== true) {\r\n            document.addEventListener('mouseover', this.onHover);\r\n            document.addEventListener('touchstart', this.onHover);\r\n        }\r\n\r\n        document.addEventListener('click', this.onClick);\r\n        window.addEventListener('popstate', this.onStateChange);\r\n    }\r\n\r\n    /**\r\n     * Stop DOM Events\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public stopEvents() {\r\n        if (this.prefetchIgnore !== true) {\r\n            document.removeEventListener('mouseover', this.onHover);\r\n            document.removeEventListener('touchstart', this.onHover);\r\n        }\r\n\r\n        document.removeEventListener('click', this.onClick);\r\n        window.removeEventListener('popstate', this.onStateChange);\r\n    }\r\n}","import { Service } from \"./service\";\r\nimport { Manager } from \"./manager\";\r\n\r\nexport type RouteMethod = (...args: any) => any;\r\nexport type RouteStyle = string | RegExp;\r\nexport interface IRouteToFrom {\r\n    to: RouteStyle,\r\n    from: RouteStyle\r\n}\r\nexport type RoutePath = IRouteToFrom | RouteStyle;\r\nexport interface IRoute {\r\n    path: RoutePath,\r\n    method: RouteMethod\r\n}\r\n\r\n/**\r\n * Controls what happens when certain url paths match a set of criteria\r\n *\r\n * @export\r\n * @class Router\r\n * @extends {Service}\r\n */\r\nexport class Router extends Service {\r\n    /**\r\n     * List of routes inputted\r\n     *\r\n     * @protected\r\n     * @type {Manager<IRouteToFrom, RouteMethod>}\r\n     * @memberof Router\r\n     */\r\n    protected routes: Manager<IRouteToFrom, RouteMethod>;\r\n\r\n    /**\r\n     * Creates an instance of Router.\r\n     * \r\n     * @param {Array<IRoute>} [routes=[]]\r\n     * @memberof Router\r\n     */\r\n    constructor(routes: IRoute[] = []) {\r\n        super();\r\n        this.routes = new Manager();\r\n        for (const route of routes) {\r\n            this.add(route);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new route to watch for\r\n     *\r\n     * @param {IRoute} { path, method }\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    public add({ path, method }: IRoute): Router {\r\n        const key = this.parse(path);\r\n        this.routes.set(key, method);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Convert strings into path match functions\r\n     *\r\n     * @param {RouteStyle} path\r\n     * @returns {RegExp}\r\n     * @memberof Router\r\n     */\r\n    public parsePath(path: RouteStyle): RegExp {\r\n        if (typeof path === \"string\")\r\n            return new RegExp(path, \"i\");\r\n        else if (path instanceof RegExp)\r\n            return path;\r\n        throw \"[Router] only regular expressions and strings are accepted as paths.\";\r\n    }\r\n\r\n    /**\r\n     * Determines if a strings counts has a path\r\n     *\r\n     * @param {RouteStyle} input\r\n     * @returns boolean\r\n     * @memberof Router\r\n     */\r\n    public isPath(input: RouteStyle): boolean {\r\n        return typeof input === \"string\" || input instanceof RegExp;\r\n    }\r\n\r\n    /**\r\n     * Parse the multiple different formats for paths, into a { from, to } object\r\n     *\r\n     * @param {RouteStyle} input\r\n     * @returns {IRouteToFrom}\r\n     * @memberof Router\r\n     */\r\n    public parse(input: RoutePath): IRouteToFrom {\r\n        let route = (input as IRouteToFrom);\r\n        let toFromPath: IRouteToFrom = {\r\n            from: /(.*)/g,\r\n            to: /(.*)/g\r\n        };\r\n\r\n        if (this.isPath(input as RouteStyle))\r\n            toFromPath = {\r\n                from: input as RouteStyle,\r\n                to: /(.*)/g\r\n            };\r\n        else if (this.isPath(route.from) && this.isPath(route.to))\r\n            toFromPath = route;\r\n        else\r\n            throw \"[Router] path is neither a string, regular expression, or a { from, to } object.\";\r\n\r\n        let { from, to } = toFromPath;\r\n        return {\r\n            from: this.parsePath(from),\r\n            to: this.parsePath(to)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if route paths are true, if so run their methods\r\n     *\r\n     * @memberof Router\r\n     */\r\n    public route() {\r\n        let from: string = this.HistoryManager.last().getURLPathname();\r\n        let to: string = window.location.pathname;\r\n\r\n        this.routes.forEach((method: RouteMethod, path: IRouteToFrom) => {\r\n            let fromRegExp = (path.from as RegExp);\r\n            let toRegExp = (path.to as RegExp);\r\n\r\n            if (fromRegExp.test(from) && toRegExp.test(to)) {\r\n                let fromExec = fromRegExp.exec(from);\r\n                let toExec = toRegExp.exec(to);\r\n\r\n                method({ from: fromExec, to: toExec });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add listeners for PJAX Events\r\n     *\r\n     * @memberof Router\r\n     */\r\n    public initEvents() {\r\n        this.route = this.route.bind(this);\r\n        this.EventEmitter.on(\"READY\", this.route);\r\n        this.EventEmitter.on(\"PAGE-LOADING\", this.route);\r\n    }\r\n}"],"names":["CONFIG_DEFAULTS","wrapperAttr","noAjaxLinkAttr","noPrefetchAttr","headers","preventSelfAttr","preventAllAttr","transitionAttr","blockAttr","timeout","CONFIG","constructor","config","this","Object","assign","toAttr","value","brackets","prefix","attr","getConfig","Manager","[object Object]","map","Map","key","get","keys","values","set","size","distance","last","delete","clear","has","entries","callback","args","context","forEach","Symbol","iterator","method","item","ManagerItem","manager","install","register","AdvancedManager","app","super","getApp","_URL","URL","url","window","location","href","origin","getFullPath","pathname","hash","getHash","slice","clean","toString","replace","getPathname","equalTo","a","b","urlA","urlB","newURL","URLString","Coords","x","scrollX","y","scrollY","State","state","index","transition","data","scroll","trigger","getIndex","setIndex","getURL","getURLPathname","getTransition","getData","toJSON","HistoryManager","add","addState","PARSER","DOMParser","Page","dom","document","parseFromString","title","head","body","wrapper","querySelector","getTitle","getHead","getBody","getWrapper","getDOM","PageManager","getLoading","loading","_url","page","request","urlString","Promise","resolve","response","Headers","setTimeout","clearTimeout","fetch","mode","cache","credentials","status","text","Error","statusText","err","Listener","scope","name","listener","Event","EventEmitter","event","getEvent","events","_name","_callback","_scope","split","Array","isArray","newListener","i","len","console","log","getCallback","getScope","removeListener","onceFn","off","apply","on","listeners","customEvent","CustomEvent","detail","dispatchEvent","Service","getPages","getEmitter","getHistory","ServiceManager","getServices","TransitionManager","getTransitions","boot","initEvents","stopEvents","stop","asyncMethodCall","methodCall","Transition","init","oldPage","newPage","getName","getOldPage","getNewPage","getTrigger","out","done","in","fromWrapper","toWrapper","async","finish","emit","outMethod","_this","from","then","insertAdjacentElement","remove","inMethod","to","start","Block","rootElement","selector","getRootElement","getSelector","BlockIntent","block","getBlock","BlockManager","activeBlocks","intent","rootElements","querySelectorAll","length","newInstance","getActiveBlocks","refresh","App","transitions","services","blocks","history","pages","emitter","handler","removeEventListener","bind","addEventListener","getBlocks","getActiveBlock","getService","getState","type","toLowerCase","load","loadPage","addBlock","blockIntent","addService","service","addTransition","currentPage","currentState","once","PJAX","transitionStart","isTransitioning","transitionStop","current","changeState","getTransitionName","el","getAttribute","validLink","pushStateSupport","pushState","exists","eventMutate","which","metaKey","ctrlKey","shiftKey","altKey","newTab","hasAttribute","target","crossOrigin","protocol","hostname","download","preventSelf","preventAll","Boolean","closest","prevent","sameURL","getHref","tagName","getLink","parentNode","onClick","stopOnTransitioning","preventDefault","stopPropagation","go","getDirection","Math","abs","force","transitionName","currentURL","currentIndex","top","left","behavior","stickyScroll","oldHref","hashAction","action","replaceState","forceOnError","error","autoScrollOnHash","hashID","getElementById","scrollIntoView","getBoundingClientRect","ignoredURL","ignoreURLs","some","exec","onHover","warn","onStateChange","bindEvents","prefetchIgnore","Router","routes","route","path","parse","parsePath","RegExp","isPath","input","toFromPath","fromRegExp","toRegExp","test"],"mappings":"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"}