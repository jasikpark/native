{
  "version": 3,
  "sources": ["../src/api.ts", "../src/config.ts", "../../manager/src/api.ts", "../src/manager.ts", "../src/url.ts", "../src/history.ts", "../src/page.ts", "../../emitter/src/api.ts", "../src/service.ts", "../src/transition.ts", "../src/app.ts", "../src/pjax.ts", "../src/route.ts", "../../animate/src/api.ts"],
  "sourcesContent": ["export * from \"./config\";\r\nexport * from \"./manager\";\r\nexport * from \"./url\";\r\n\r\nexport * from \"./history\";\r\nexport * from \"./page\";\r\n\r\nexport * from \"./emitter\";\r\nexport * from \"./service\";\r\n\r\nexport * from \"./transition\";\r\n\r\nexport * from \"./app\";\r\nexport * from \"./pjax\";\r\nexport * from \"./route\";\r\n\r\nexport * from \"@okikio/animate\";\r\n", "// The config variables\r\nexport interface ICONFIG {\r\n    prefix?: string;\r\n    wrapperAttr?: string;\r\n    noAjaxLinkAttr?: string;\r\n    noPrefetchAttr?: \"no-prefetch\";\r\n    headers?: string[][];\r\n    preventSelfAttr?: string;\r\n    preventAllAttr?: string;\r\n    transitionAttr?: string;\r\n    blockAttr?: string;\r\n    timeout?: number\r\n}\r\n\r\nexport const CONFIG_DEFAULTS: ICONFIG = {\r\n    wrapperAttr: \"wrapper\",\r\n    noAjaxLinkAttr: \"no-ajax-link\",\r\n    noPrefetchAttr: \"no-prefetch\",\r\n    headers: [\r\n        [\"x-partial\", \"true\"]\r\n    ],\r\n    preventSelfAttr: `prevent=\"self\"`,\r\n    preventAllAttr: `prevent=\"all\"`,\r\n    transitionAttr: \"transition\",\r\n    blockAttr: `block`,\r\n    timeout: 30000\r\n};\r\n\r\nexport type ConfigKeys = keyof ICONFIG;\r\n\r\n/**\r\n * The Config class\r\n *\r\n * @export\r\n * @class CONFIG\r\n */\r\nexport class CONFIG {\r\n    /**\r\n     * The current Configuration\r\n     *\r\n     * @public\r\n     * @type ICONFIG\r\n     * @memberof CONFIG\r\n     */\r\n    public config: ICONFIG;\r\n\r\n    /**\r\n     * Creates an instance of CONFIG.\r\n     *\r\n     * @param {ICONFIG} config\r\n     * @memberof CONFIG\r\n     */\r\n    constructor(config: ICONFIG) {\r\n        this.config = Object.assign({ ...CONFIG_DEFAULTS }, config);\r\n    }\r\n\r\n    /**\r\n     * Converts string into data attributes\r\n     *\r\n     * @param {string} value\r\n     * @param {boolean} brackets [brackets=true]\r\n     * @returns string\r\n     * @memberof CONFIG\r\n     */\r\n    public toAttr(value: string, brackets: boolean = true): string {\r\n        let { prefix } = this.config;\r\n        let attr = `data${prefix ? \"-\" + prefix : \"\"}-${value}`;\r\n        return brackets ? `[${attr}]` : attr;\r\n    }\r\n\r\n    /**\r\n     * Selects config vars, and formats them for use, or simply returns the current configurations for the framework\r\n     *\r\n     * @param {ConfigKeys} value\r\n     * @param {boolean} [brackets=true]\r\n     * @returns any\r\n     * @memberof CONFIG\r\n     */\r\n    public getConfig(value?: ConfigKeys, brackets: boolean = true): any {\r\n        if (typeof value !== \"string\")\r\n            return this.config;\r\n\r\n        let config = this.config[value];\r\n        if (typeof config === \"string\")\r\n            return this.toAttr(config, brackets);\r\n        return config;\r\n    }\r\n}\r\n", "/**\r\n * Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data.\r\n *\r\n * @export\r\n * @class Manager\r\n * @template K\r\n * @template V\r\n */\r\nexport class Manager<K, V> {\r\n\t/**\r\n\t * The complex list of named data, to which the Manager controls\r\n\t *\r\n\t * @public\r\n\t * @type Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic map: Map<K, V>;\r\n\r\n\t/**\r\n\t * Creates an instance of Manager.\r\n\t *\r\n\t * @param {Array<[K, V]>} [value]\r\n\t * @memberof Manager\r\n\t */\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Manager class's list\r\n\t *\r\n\t * @returns Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key to find in the Manager's list\r\n\t * @returns V\r\n\t */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the keys of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<K>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the values of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic values(): Array<V> {\r\n\t\treturn Array.from(this.map.values());\r\n\t}\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers\r\n\t *\r\n\t * @public\r\n\t * @param  {V} value\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\tlet size = this.size;\r\n\t\t// @ts-ignore\r\n\t\tlet num: K = size as K;\r\n\t\tthis.set(num, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total number of items stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns Number\r\n\t */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\tpublic get length(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the last item in the Manager who's index is a certain distance from the last item in the Manager\r\n\t *\r\n\t * @param {number} [distance=1]\r\n\t * @returns V | undefined\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key, returns true if an element in the Map object existed and has been removed, or false if the element does not exist.\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns boolean\r\n\t */\r\n\tpublic delete(key: K): boolean {\r\n\t\treturn this.map.delete(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key, returns the Manager class, allowing for chains\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic remove(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the Manager of all its contents\r\n\t *\r\n\t * @public\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the Manager contains a certain key\r\n\t *\r\n\t * @public\r\n\t * @param {K} key\r\n\t * @returns boolean\r\n\t */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.\r\n\t *\r\n\t * @public\r\n\t * @returns IterableIterator<[K, V]>\r\n\t */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates through the Managers contents, calling a callback function every iteration\r\n\t *\r\n\t * @param {*} [callback=(...args: any): void => { }]\r\n\t * @param {object} context\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic forEach(\r\n\t\tcallback: any = (...args: any): void => { },\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Allows iteration via the for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators]\r\n\t *\r\n\t * @returns IterableIterator<[K, V]>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\r\n\t\treturn this.entries();\r\n\t}\r\n}\r\n\r\n/**\r\n * Calls the method of a certain name for all items that are currently installed\r\n *\r\n * @param {Manager<any, any>} manager\r\n * @param {string} method\r\n * @param {Array<any>} [args=[]]\r\n */\r\nexport const methodCall = (manager: Manager<any, any>, method: string, ...args: any): void => {\r\n\tmanager.forEach((item) => {\r\n\t\t// @ts-ignore\r\n\t\titem[method](...args);\r\n\t});\r\n};\r\n\r\n/**\r\n * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n *\r\n * @param {Manager<any, any>} manager\r\n * @param {string} method\r\n * @param {Array<any>} [args=[]]\r\n */\r\nexport const asyncMethodCall = async (manager: Manager<any, any>, method: string, ...args: any): Promise<void> => {\r\n\tfor (let [, item] of manager) {\r\n\t\t// @ts-ignore\r\n\t\tawait item[method](...args);\r\n\t}\r\n};\r\n\r\nexport default Manager;\r\n", "import { Manager, methodCall, asyncMethodCall } from \"@okikio/manager\";\r\nimport { CONFIG } from \"./config\";\r\nimport { App } from \"./app\";\r\nimport EventEmitter from \"@okikio/emitter\";\r\n\r\nexport type IAdvancedManager = AdvancedManager<any, ManagerItem>;\r\n\r\n/**\r\n * The base class for all AdvancedManager and AdvancedStorage items\r\n *\r\n * @export\r\n * @class ManagerItem\r\n */\r\nexport class ManagerItem {\r\n    /**\r\n     * The AdvancedManager the ManagerItem is attached to\r\n     *\r\n     * @public\r\n     * @type IAdvancedManager\r\n     * @memberof ManagerItem\r\n     */\r\n    public manager: IAdvancedManager;\r\n\r\n    /**\r\n     * The App the ManagerItem is attached to\r\n     *\r\n     * @public\r\n     * @type App\r\n     * @memberof ManagerItem\r\n    */\r\n    public app: App;\r\n\r\n    /**\r\n     * The Config class of the App the ManagerItem is attached to\r\n     *\r\n     * @public\r\n     * @type CONFIG\r\n     * @memberof ManagerItem\r\n    */\r\n    public config: CONFIG;\r\n    public emitter: EventEmitter;\r\n    public key: any;\r\n\r\n    /**\r\n     * Creates an instance of ManagerItem.\r\n     *\r\n     * @memberof ManagerItem\r\n     */\r\n    constructor() { }\r\n\r\n    /**\r\n     * Run after the Manager Item has been registered\r\n     *\r\n     * @returns any\r\n     * @memberof ManagerItem\r\n     */\r\n    public install(): any { }\r\n\r\n    /**\r\n     * Register the current Manager Item's manager\r\n     *\r\n     * @param {IAdvancedManager} manager\r\n     * @returns ManagerItem\r\n     * @memberof ManagerItem\r\n     */\r\n    public register(manager: IAdvancedManager, key: any): ManagerItem {\r\n        this.manager = manager;\r\n        this.app = manager.app;\r\n        this.config = manager.config;\r\n        this.emitter = manager.emitter;\r\n        this.key = key;\r\n        this.install();\r\n        return this;\r\n    }\r\n\r\n    public uninstall(): any { }\r\n\r\n    public unregister() {\r\n        this.uninstall();\r\n\r\n        this.manager.delete(this.key);\r\n        this.key = undefined;\r\n        this.manager = undefined;\r\n        this.app = undefined;\r\n        this.config = undefined;\r\n        this.emitter = undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * A tweak to the Manager class that makes it self aware of the App class it's instantiated in\r\n *\r\n * @export\r\n * @class AdvancedManager\r\n * @extends {Manager<K, V>}\r\n * @template K\r\n * @template V\r\n */\r\nexport class AdvancedManager<K, V extends ManagerItem> extends Manager<K, V> {\r\n    /**\r\n     * The instance of the App class, the Manager is instantiated in\r\n     *\r\n     * @type App\r\n     * @memberof AdvancedManager\r\n     */\r\n    public app: App;\r\n\r\n    /**\r\n     * The Config class of the App the AdvancedManager is attached to\r\n     *\r\n     * @public\r\n     * @type CONFIG\r\n     * @memberof AdvancedManager\r\n    */\r\n    public config: CONFIG;\r\n\r\n    /**\r\n     * The EventEmitter class of the App the AdvancedManager is attached to\r\n     *\r\n     * @public\r\n     * @type EventEmitter\r\n     * @memberof AdvancedManager\r\n    */\r\n    public emitter: EventEmitter;\r\n\r\n    /**\r\n     * Creates an instance of AdvancedManager.\r\n     *\r\n     * @param {App} app - The instance of the App class, the Manager is instantiated in\r\n     * @memberof AdvancedManager\r\n     */\r\n    constructor(app: App) {\r\n        super();\r\n        this.app = app;\r\n        this.config = app.config;\r\n        this.emitter = app.emitter;\r\n    }\r\n\r\n    /**\r\n     * Set a value stored in the Manager\r\n     *\r\n     * @public\r\n     * @param  {K} key - The key where the value will be stored\r\n     * @param  {V} value - The value to store\r\n     * @returns AdvancedManager<K, V>\r\n     */\r\n    public set(key: K, value: V) {\r\n        super.set(key, value);\r\n        value.register(this, key);\r\n        return this;\r\n    }\r\n}\r\n\r\nexport { Manager, methodCall, asyncMethodCall };\r\n", "/**\r\n * Adds new methods to the native URL Object; it seemed cleaner than using a custom method or editing the prototype.\r\n *\r\n * This doesn't extend the **Class** object because it's meant to be a small extension of the native URL class.\r\n *\r\n * @export\r\n * @class URL\r\n * @extends {URL}\r\n */\r\n// Read up on the native URL class [devdocs.io/dom/url]\r\n/**\r\n * Creates an instance of URL.\r\n *\r\n * @param {(string | URL | Location)} [url=window.location.pathname]\r\n * @return URL\r\n */\r\nexport const newURL = (url: string | URL | Location = window.location.href): URL => {\r\n    return url instanceof URL ? url : new URL(url as unknown as string, window.location.origin);\r\n};\r\n\r\n/**\r\n * Returns the pathname with the hash\r\n *\r\n * @param {URL} url\r\n * @returns string\r\n */\r\nexport const getHashedPath = (url: URL): string => (`${url.pathname}${url.hash}`);\r\n\r\n/**\r\n * Returns the actual hash without the hashtag\r\n *\r\n * @param {URL} url\r\n * @returns string\r\n */\r\nexport const getHash = (url: URL): string => (url.hash.slice(1));\r\n\r\n/**\r\n * Removes the hash from the full URL for a clean URL string\r\n *\r\n * @param {URL} url\r\n * @returns string\r\n */\r\nexport const clean = (url: URL): string => (url.toString().replace(/(\\/#.*|\\/|#.*)$/, ''));\r\n\r\n/**\r\n * Compares two URLs to each other\r\n *\r\n * @param {URL} a\r\n * @param {URL} b\r\n * @returns boolean\r\n */\r\nexport const equal = (a: URL | string, b: URL | string): boolean => {\r\n    let urlA = newURL(a);\r\n    let urlB = newURL(b);\r\n    return clean(urlA) === clean(urlB);\r\n};\r\n", "import { getHashedPath, newURL } from \"./url\";\r\n\r\nexport type Trigger = HTMLAnchorElement | \"HistoryManager\" | \"popstate\" | \"back\" | \"forward\";\r\nexport interface ICoords {\r\n\treadonly x: number;\r\n\treadonly y: number;\r\n}\r\n\r\nexport interface IStateData {\r\n\tscroll: ICoords;\r\n\t[key: string]: any;\r\n}\r\n\r\nexport interface IState {\r\n\turl: string;\r\n\tindex?: number;\r\n\ttransition: string;\r\n\tdata: IStateData;\r\n}\r\n\r\nexport interface IHistoryItem {\r\n\tindex: number;\r\n\tstates: IState[];\r\n}\r\n\r\n/**\r\n * A quick snapshot of page coordinates, e.g. scroll positions\r\n *\r\n * @export\r\n * @param {number} [x=window.scrollX]\r\n * @param {number} [y=window.scrollY]\r\n */\r\nexport const newCoords = (x: number = window.scrollX, y: number = window.scrollY): ICoords => ({ x, y });\r\n\r\n/**\r\n * Represents the current status of the page consisting of properties like: url, transition, and data\r\n *\r\n * @export\r\n * @param {IState} {\r\n *         url = getHashedPath(newURL()),\r\n *         index = 0,\r\n *         transition = \"default\",\r\n *         data = {\r\n *             scroll: newCoords(),\r\n *             trigger: \"HistoryManager\"\r\n *         }\r\n *     }\r\n * @memberof State\r\n*/\r\nexport const newState = (state: IState = {\r\n\turl: getHashedPath(newURL()),\r\n\tindex: 0,\r\n\ttransition: \"default\",\r\n\tdata: {\r\n\t\tscroll: newCoords(),\r\n\t\ttrigger: \"HistoryManager\"\r\n\t}\r\n}): IState => (state);\r\n\r\n\r\n/**\r\n * History of the site, stores only the State class\r\n *\r\n * @export\r\n * @class HistoryManager\r\n * @extends {Manager<number, IState>}\r\n */\r\nexport class HistoryManager {\r\n\tpublic states: IState[];\r\n\tpublic pointer = -1;\r\n\r\n\t/**\r\n\t * Creates an instance of the HistoryManager class, which inherits properties and methods from the Storage class.\r\n\t *\r\n\t * @memberof HistoryManager\r\n\t * @constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tthis.states = [];\r\n\r\n\t\tlet state = newState();\r\n\t\tthis.add(state, \"replace\");\r\n\t}\r\n\r\n\tpublic get(index: number) {\r\n\t\treturn this.states[index];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the index of the state before adding to HistoryManager\r\n\t *\r\n\t * @param {IState} value\r\n\t * @returns HistoryManager\r\n\t */\r\n\tpublic add(value?: IState, historyAction: \"replace\" | \"push\" = \"push\"): HistoryManager {\r\n\t\tlet state = newState(value);\r\n\t\tlet len = this.length;\r\n\t\tthis.states.push({ ...state });\r\n\t\tthis.pointer = len;\r\n\r\n\t\tlet item: IHistoryItem = {\r\n\t\t\tindex: this.pointer,\r\n\t\t\tstates: [...this.states]\r\n\t\t};\r\n\t\tthis.changeState(historyAction, state, item);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic remove(index?: number) {\r\n\t\tif (index) {\r\n\t\t\tthis.states.splice(index, 1);\r\n\t\t} else {\r\n\t\t\tthis.states.pop();\r\n\t\t}\r\n\r\n\t\tthis.pointer--;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic replace(newStates: IState[]) {\r\n\t\tthis.states = newStates;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Set state by index.\r\n\t */\r\n\tpublic set(i: number, state: IState) {\r\n\t\treturn (this.states[i] = state);\r\n\t}\r\n\r\n\t/**\r\n\t * Get the current state.\r\n\t */\r\n\tget current(): IState {\r\n\t\treturn this.get(this.pointer);\r\n\t}\r\n\r\n\t/**\r\n\t * Get the last state (top of the history stack).\r\n\t */\r\n\tget last(): IState {\r\n\t\treturn this.get(this.length - 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Get the previous state.\r\n\t */\r\n\tget previous(): IState | null {\r\n\t\treturn this.pointer < 1 ? null : this.get(this.pointer - 1);\r\n\t}\r\n\r\n\tget length() {\r\n\t\treturn this.states.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Either push or replace history state\r\n\t *\r\n\t * @param {(\"push\" | \"replace\")} action\r\n\t * @param {IState} state\r\n\t * @param {_URL} url\r\n\t * @memberof PJAX\r\n\t */\r\n\tpublic changeState(action: \"push\" | \"replace\", state: IState, item: object) {\r\n\t\tlet href = getHashedPath(newURL(state.url));\r\n\t\tlet args = [item, \"\", href];\r\n\t\tif (window.history) {\r\n\t\t\tswitch (action) {\r\n\t\t\t\tcase \"push\":\r\n\t\t\t\t\twindow.history.pushState.apply(window.history, args);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"replace\":\r\n\t\t\t\t\twindow.history.replaceState.apply(window.history, args);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n", "import { Manager, ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { equal, newURL } from \"./url\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Parses strings to DOM\r\n */\r\nexport const PARSER: DOMParser = new DOMParser();\r\n\r\n/**\r\n * A page represents the DOM elements that create each page\r\n *\r\n * @export\r\n * @class Page\r\n */\r\nexport class Page extends ManagerItem {\r\n    /**\r\n     * Holds the DOM of the current page\r\n     *\r\n     * @public\r\n     * @type Document\r\n     * @memberof Page\r\n     */\r\n    public dom: Document;\r\n\r\n    /**\r\n     * Holds the wrapper element to be swapped out of each Page\r\n     *\r\n     * @public\r\n     * @type HTMLElement\r\n     * @memberof Page\r\n     */\r\n    public wrapper: HTMLElement;\r\n\r\n    /**\r\n     * Holds the title of each page\r\n     *\r\n     * @public\r\n     * @type string\r\n     * @memberof Page\r\n     */\r\n    public title: string;\r\n\r\n    /**\r\n     * Holds the head element of each page\r\n     *\r\n     * @public\r\n     * @type Element\r\n     * @memberof Page\r\n     */\r\n    public head: Element;\r\n\r\n    /**\r\n     * Holds the body element of each page\r\n     *\r\n     * @public\r\n     * @type Element\r\n     * @memberof Page\r\n     */\r\n    public body: Element;\r\n\r\n    /**\r\n     * The URL of the current page\r\n     *\r\n     * @public\r\n     * @type URL\r\n     * @memberof Page\r\n     */\r\n    public url: URL;\r\n    public data: string;\r\n    public wrapperAttr: string;\r\n\r\n    /**\r\n     * Creates an instance of Page, it also creates a new page from response text, or a Document Object\r\n     *\r\n     * @param {URL} [url = newURL()]\r\n     * @param {(string | Document)} [dom=document]\r\n     * @memberof Page\r\n     */\r\n    constructor(url: URL = newURL(), dom: string | Document = document) {\r\n        super();\r\n        this.url = url;\r\n\r\n        if (typeof dom === \"string\") {\r\n            this.data = dom;\r\n        } else this.dom = dom || document;\r\n    }\r\n\r\n    public async build() {\r\n        if (!(this.dom instanceof Node)) {\r\n            this.dom = PARSER.parseFromString(this.data, \"text/html\");\r\n        }\r\n\r\n        if (!(this.body instanceof Node)) {\r\n            let { title, head, body } = this.dom;\r\n            this.title = title;\r\n            this.head = head;\r\n            this.body = body;\r\n            this.wrapper = this.body.querySelector(this.wrapperAttr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs once the the manager and config have been registered\r\n     *\r\n     * @returns void\r\n     * @memberof Page\r\n     */\r\n    public install(): void {\r\n        this.wrapperAttr = this.config.getConfig(\"wrapperAttr\");\r\n    }\r\n\r\n    public uninstall() {\r\n        this.url = undefined;\r\n        this.title = undefined;\r\n        this.head = undefined;\r\n        this.body = undefined;\r\n        this.dom = undefined;\r\n        this.wrapper = undefined;\r\n        this.data = undefined;\r\n        this.wrapperAttr = undefined;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Controls which page to be load\r\n *\r\n * @export\r\n * @class PageManager\r\n * @extends {AdvancedManager<string, Page>}\r\n */\r\nexport class PageManager extends AdvancedManager<string, Page> {\r\n    /**\r\n     * Stores all URLs that are currently loading\r\n     *\r\n     * @public\r\n     * @type Manager<string, Promise<string>>\r\n     * @memberof PageManager\r\n     */\r\n    public loading: Manager<string, Promise<string>> = new Manager();\r\n    public maxPages = 5;\r\n\r\n    /**\r\n     * Creates an instance of the PageManager\r\n     *\r\n     * @param {App} app\r\n     * @memberof PageManager\r\n     */\r\n    constructor(app: App) {\r\n        super(app);\r\n        let URLString = newURL().pathname;\r\n        this.set(URLString, new Page());\r\n        URLString = undefined;\r\n    }\r\n\r\n    /**\r\n     * Load from cache or by requesting URL via a fetch request, avoid requesting for the same thing twice by storing the fetch request in \"this.loading\"\r\n     *\r\n     * @param {(URL | string)} [_url=newURL()]\r\n     * @returns Promise<Page>\r\n     * @memberof PageManager\r\n     */\r\n    public async load(_url: URL | string = newURL()): Promise<Page> {\r\n        let url: URL = newURL(_url);\r\n        let urlString: string = url.pathname;\r\n        let page: Page, request: Promise<string>;\r\n        if (this.has(urlString)) {\r\n            page = this.get(urlString);\r\n            return Promise.resolve(page);\r\n        }\r\n\r\n        if (!this.loading.has(urlString)) {\r\n            request = this.request(urlString);\r\n            this.loading.set(urlString, request);\r\n        } else request = this.loading.get(urlString);\r\n\r\n        let response = await request;\r\n        this.loading.delete(urlString);\r\n\r\n        page = new Page(url, response);\r\n        this.set(urlString, page);\r\n\r\n        if (this.size > this.maxPages) {\r\n            let currentUrl = newURL();\r\n            let keys = this.keys();\r\n            let first = equal(currentUrl, keys[0]) ? keys[1] : keys[0];\r\n            let page = this.get(first);\r\n            page.unregister();\r\n            page = undefined;\r\n            keys = undefined;\r\n            currentUrl = undefined;\r\n            first = undefined;\r\n        }\r\n        return page;\r\n    }\r\n\r\n    /**\r\n     * Starts a fetch request\r\n     *\r\n     * @param {string} url\r\n     * @returns Promise<string>\r\n     * @memberof PageManager\r\n     */\r\n    public async request(url: string): Promise<string> {\r\n        const headers = new Headers(this.config.getConfig(\"headers\"));\r\n        const timeout = window.setTimeout(() => {\r\n            window.clearTimeout(timeout);\r\n            throw \"Request Timed Out!\";\r\n        }, this.config.getConfig(\"timeout\"));\r\n\r\n        try {\r\n            let response = await fetch(url, {\r\n                mode: 'same-origin',\r\n                method: \"GET\",\r\n                headers,\r\n                cache: \"default\",\r\n                credentials: \"same-origin\",\r\n            });\r\n\r\n            window.clearTimeout(timeout);\r\n            if (response.status >= 200 && response.status < 300) {\r\n                return await response.text();\r\n            }\r\n\r\n            const err = new Error(response.statusText || \"\" + response.status);\r\n            throw err;\r\n        } catch (err) {\r\n            window.clearTimeout(timeout);\r\n            throw err;\r\n        }\r\n    }\r\n}\r\n", "import { Manager } from \"@okikio/manager\";\r\n\r\nexport type ListenerCallback = ((...args: any) => void);\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n */\r\nexport const newListener = ({\r\n    callback = () => { },\r\n    scope = null,\r\n    name = \"event\",\r\n}: IListener): IListener => ({ callback, scope, name });\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, IListener> {\r\n    /**\r\n     * The name of the event\r\n     *\r\n     * @public\r\n     * @type string\r\n     * @memberof Event\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Creates an instance of Event.\r\n     *\r\n     * @param {string} [name=\"event\"]\r\n     * @memberof Event\r\n     */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n    /**\r\n     * Creates an instance of EventEmitter.\r\n     *\r\n     * @memberof EventEmitter\r\n     */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n    /**\r\n     * Creates a new listener and adds it to the event\r\n     *\r\n     * @param {string} name\r\n     * @param {ListenerCallback} callback\r\n     * @param {object} scope\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(newListener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback | object} callback\r\n     * @param {object} scope\r\n     * @returns EventEmitter\r\n     * @memberof EventEmitter\r\n     */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     *\r\n     * @param {string} name\r\n     * @param {ListenerCallback} [callback]\r\n     * @param {object} [scope]\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let listener = newListener({ name, callback, scope });\r\n\r\n            event.forEach((value: IListener, i: number) => {\r\n                if (\r\n                    value.callback === listener.callback &&\r\n                    value.scope === listener.scope\r\n                ) {\r\n                    return event.delete(i);\r\n                }\r\n            });\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from a given event, or it just completely removes an event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback | object} [callback]\r\n     * @param {object} [scope]\r\n     * @returns EventEmitter\r\n     * @memberof EventEmitter\r\n     */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            if (typeof _callback === \"function\") {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     *\r\n     * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n     * @returns EventEmitter\r\n     * @memberof EventEmitter\r\n     */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: IListener) => {\r\n                    let { callback, scope } = listener;\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default EventEmitter;\r\n", "import { AdvancedManager, ManagerItem, methodCall } from \"./manager\";\r\nimport { TransitionManager } from \"./transition\";\r\nimport { HistoryManager } from \"./history\";\r\nimport { EventEmitter } from \"./emitter\";\r\nimport { PageManager } from \"./page\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Controls specific kinds of actions that require JS\r\n *\r\n * @export\r\n * @class Service\r\n */\r\nexport class Service extends ManagerItem {\r\n\t/**\r\n\t * Stores access to the App class's EventEmitter\r\n\t *\r\n\t * @public\r\n\t * @type EventEmitter\r\n\t * @memberof Service\r\n\t */\r\n\tpublic emitter: EventEmitter;\r\n\r\n\t/**\r\n\t * Stores access to the App class's PageManager\r\n\t *\r\n\t * @public\r\n\t * @type PageManager\r\n\t * @memberof Service\r\n\t */\r\n\tpublic PageManager: PageManager;\r\n\r\n\t/**\r\n\t * Stores access to the App class's HistoryManager\r\n\t *\r\n\t * @public\r\n\t * @type HistoryManager\r\n\t * @memberof Service\r\n\t */\r\n\tpublic HistoryManager: HistoryManager;\r\n\r\n\t/**\r\n\t * Stores the ServiceManager the service is install on\r\n\t *\r\n\t * @public\r\n\t * @type ServiceManager\r\n\t * @memberof Service\r\n\t */\r\n\tpublic ServiceManager: ServiceManager;\r\n\r\n\t/**\r\n\t * Stores access to the App's TransitionManager\r\n\t *\r\n\t * @public\r\n\t * @type TransitionManager\r\n\t * @memberof Service\r\n\t */\r\n\tpublic TransitionManager: TransitionManager;\r\n\r\n\t/**\r\n\t * Method is run once when Service is installed on a ServiceManager\r\n\t *\r\n\t * @memberof Service\r\n\t */\r\n\tpublic install(): void {\r\n\t\tlet { app } = this.manager;\r\n\t\tthis.PageManager = app.pages;\r\n\t\tthis.HistoryManager = app.history;\r\n\t\tthis.ServiceManager = app.services;\r\n\t\tthis.TransitionManager = app.transitions;\r\n\t}\r\n\r\n\t// Called before the start of a Service, represents a constructor of sorts\r\n\tpublic init(...args: any): void { }\r\n\r\n\t// Called on start of Service\r\n\tpublic boot(): void {\r\n\t\tthis.initEvents();\r\n\t}\r\n\r\n\t// Initialize events\r\n\tpublic initEvents(): void { }\r\n\r\n\t// Stop events\r\n\tpublic stopEvents(): void { }\r\n\r\n\tpublic uninstall() {\r\n\t\tthis.PageManager = undefined;\r\n\t\tthis.HistoryManager = undefined;\r\n\t\tthis.ServiceManager = undefined;\r\n\t\tthis.TransitionManager = undefined;\r\n\t}\r\n\r\n\t// Stop services\r\n\tpublic stop(): void {\r\n\t\tthis.stopEvents();\r\n\t\tthis.unregister();\r\n\t}\r\n}\r\n\r\n/**\r\n * The Service Manager controls the lifecycle of all services in an App\r\n *\r\n * @export\r\n * @class ServiceManager\r\n * @extends {AdvancedManager<string, Service>}\r\n */\r\nexport class ServiceManager extends AdvancedManager<string, Service> {\r\n\t/**\r\n\t * Creates an instance of ServiceManager.\r\n\t *\r\n\t * @param {App} app\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tconstructor(app: App) {\r\n\t\tsuper(app);\r\n\t}\r\n\r\n\t/**\r\n\t * Call the init method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic init(): ServiceManager {\r\n\t\tmethodCall(this, \"init\", this.app);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Call the boot method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic boot(): ServiceManager {\r\n\t\tmethodCall(this, \"boot\", this.app);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Call the stop method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic stop(): ServiceManager {\r\n\t\tmethodCall(this, \"stop\", this.app);\r\n\t\treturn this;\r\n\t}\r\n}\r\n", "import { Manager } from \"./manager\";\r\nimport { EventEmitter } from \"./emitter\";\r\nimport { ICoords, Trigger } from \"./history\";\r\nimport { Page } from \"./page\";\r\nimport { App } from \"./app\";\r\nimport { CONFIG } from \"./config\";\r\n\r\n/**\r\n * The async function type, allows for smooth transition between Promises\r\n */\r\nexport type asyncFn = (err?: any, value?: any) => void;\r\nexport interface ITransition {\r\n    oldPage?: Page;\r\n    newPage?: Page;\r\n    trigger?: Trigger;\r\n    scroll?: { x: number; y: number };\r\n    scrollable?: boolean;\r\n    in: (data: ITransitionData) => any;\r\n    out: (data: ITransitionData) => any;\r\n    [key: string]: any;\r\n}\r\nexport interface ITransitionData {\r\n    from?: Page;\r\n    to?: Page;\r\n    trigger?: Trigger;\r\n    scroll?: ICoords;\r\n    done: asyncFn;\r\n}\r\n\r\n/**\r\n * Controls which animation between pages to use\r\n *\r\n * @export\r\n * @class TransitionManager\r\n * @extends {Manager<string, ITransition>}\r\n */\r\nexport class TransitionManager extends Manager<string, ITransition> {\r\n    /**\r\n     * The instance of the App class, the Manager is instantiated in\r\n     *\r\n     * @type App\r\n     * @memberof AdvancedManager\r\n     */\r\n    public app: App;\r\n\r\n    /**\r\n     * The Config class of the App the AdvancedManager is attached to\r\n     *\r\n     * @public\r\n     * @type CONFIG\r\n     * @memberof AdvancedManager\r\n    */\r\n    public config: CONFIG;\r\n\r\n    /**\r\n     * The EventEmitter class of the App the AdvancedManager is attached to\r\n     *\r\n     * @public\r\n     * @type EventEmitter\r\n     * @memberof AdvancedManager\r\n    */\r\n    public emitter: EventEmitter;\r\n\r\n    /**\r\n     * Creates an instance of the TransitionManager\r\n     *\r\n     * @param {App} app\r\n     * @memberof TransitionManager\r\n     */\r\n    constructor(app: App) {\r\n        super();\r\n        this.app = app;\r\n        this.config = app.config;\r\n        this.emitter = app.emitter;\r\n    }\r\n\r\n    /**\r\n     * Runs a transition\r\n     *\r\n     * @param {{ name: string, oldPage: Page, newPage: Page, trigger: Trigger }} data\r\n     * @returns Promise<Transition>\r\n     * @memberof TransitionManager\r\n     */\r\n    public async boot(name: string, data: { oldPage: Page, newPage: Page, trigger: Trigger, scroll: ICoords }): Promise<ITransition> {\r\n        let transition: ITransition = this.get(name);\r\n        if (!(data.oldPage instanceof Page) || !(data.newPage instanceof Page))\r\n            throw `[Page] either oldPage or newPage aren't instances of the Page Class.\\n ${{\r\n                newPage: data.newPage,\r\n                oldPage: data.oldPage,\r\n            }}`;\r\n\r\n        let fromWrapper = data.oldPage.wrapper;\r\n        let toWrapper = data.newPage.wrapper;\r\n        document.title = `` + data.newPage.title;\r\n\r\n        if (!(fromWrapper instanceof Node) || !(toWrapper instanceof Node))\r\n            throw `[Wrapper] the wrapper from the ${!(toWrapper instanceof Node) ? \"next\" : \"current\"\r\n            } page cannot be found. The wrapper must be an element that has the attribute ${this.config.getConfig(\r\n                \"wrapperAttr\"\r\n            )}.`;\r\n        transition.init && transition?.init(data);\r\n\r\n        this.emitter.emit(\"BEFORE_TRANSITION_OUT\");\r\n        await new Promise((done) => {\r\n            let outMethod: Promise<any> = transition.out.call(transition, {\r\n                from: data.oldPage,\r\n                trigger: data.trigger,\r\n                scroll,\r\n                done,\r\n            });\r\n\r\n            if (outMethod.then) outMethod.then(done);\r\n        });\r\n\r\n        this.emitter.emit(\"AFTER_TRANSITION_OUT\");\r\n        await new Promise((done) => {\r\n            fromWrapper.insertAdjacentElement(\"beforebegin\", toWrapper);\r\n            this.emitter.emit(\"CONTENT_INSERT\");\r\n            done();\r\n        });\r\n\r\n        await new Promise((done) => {\r\n            fromWrapper.remove();\r\n            fromWrapper = undefined;\r\n            toWrapper = undefined;\r\n            this.emitter.emit(\"CONTENT_REPLACED\");\r\n            done();\r\n        });\r\n\r\n        this.emitter.emit(\"BEFORE_TRANSITION_IN\");\r\n\r\n        await new Promise((done) => {\r\n            let inMethod: Promise<any> = transition.in.call(transition, {\r\n                from: data.oldPage,\r\n                to: data.newPage,\r\n                trigger: data.trigger,\r\n                scroll,\r\n                done,\r\n            });\r\n\r\n            if (inMethod.then) inMethod.then(done);\r\n        });\r\n\r\n        this.emitter.emit(\"AFTER_TRANSITION_IN\");\r\n        return transition;\r\n    }\r\n}\r\n", "import { EventEmitter, ListenerCallback, EventInput } from \"./emitter\";\r\nimport { ITransition, TransitionManager } from \"./transition\";\r\nimport { HistoryManager, IState } from \"./history\";\r\nimport { ServiceManager, Service } from \"./service\";\r\nimport { PageManager } from \"./page\";\r\nimport { CONFIG, ICONFIG } from \"./config\";\r\n\r\n/**\r\n * The App class starts the entire process, it controls all managers and all services\r\n *\r\n * @export\r\n * @class App\r\n */\r\nexport class App {\r\n    /**\r\n     * A new instance of the HistoryManager\r\n     *\r\n     * @public\r\n     * @type HistoryManager\r\n     * @memberof App\r\n     */\r\n    public history: HistoryManager;\r\n\r\n    /**\r\n     * A new instance of the TransitionManager\r\n     *\r\n     * @public\r\n     * @type TransitionManager\r\n     * @memberof App\r\n     */\r\n    public transitions: TransitionManager;\r\n\r\n    /**\r\n     * A new instance of the ServiceManager\r\n     *\r\n     * @public\r\n     * @type ServiceManager\r\n     * @memberof App\r\n     */\r\n    public services: ServiceManager;\r\n\r\n    /**\r\n     * A new instance of an EventEmitter\r\n     *\r\n     * @public\r\n     * @type EventEmitter\r\n     * @memberof App\r\n     */\r\n    public emitter: EventEmitter;\r\n\r\n    /**\r\n     * A new instance of the PageManager\r\n     *\r\n     * @public\r\n     * @type PageManager\r\n     * @memberof App\r\n     */\r\n    public pages: PageManager;\r\n\r\n    /**\r\n     * The current Configuration's for the framework\r\n     *\r\n     * @public\r\n     * @type CONFIG\r\n     * @memberof App\r\n     */\r\n    public config: CONFIG;\r\n\r\n    /**\r\n     * Creates an instance of App.\r\n     *\r\n     * @param {(ICONFIG | CONFIG)} [config={}]\r\n     * @memberof App\r\n     */\r\n    constructor(config: object = {}) {\r\n        this.register(config);\r\n    }\r\n\r\n    /**\r\n     * For registering all managers and the configurations\r\n     *\r\n     * @param {(ICONFIG | CONFIG)} [config={}]\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public register(config: ICONFIG | CONFIG = {}): App {\r\n        this.config = config instanceof CONFIG ? config : new CONFIG(config);\r\n        this.emitter = new EventEmitter();\r\n        this.history = new HistoryManager();\r\n        this.pages = new PageManager(this);\r\n        this.transitions = new TransitionManager(this);\r\n        this.services = new ServiceManager(this);\r\n\r\n        let handler = (() => {\r\n            document.removeEventListener(\"DOMContentLoaded\", handler);\r\n            window.removeEventListener(\"load\", handler);\r\n            this.emitter.emit(\"READY ready\");\r\n        }).bind(this);\r\n\r\n        document.addEventListener(\"DOMContentLoaded\", handler);\r\n        window.addEventListener(\"load\", handler);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will return either a Transition, a Service, or a State from their respective Managers\r\n     *\r\n     * @param {(\"service\" | \"transition\" | \"state\" | string)} type\r\n     * @param {any} key\r\n     * @returns Service | Transition | State\r\n     * @memberof App\r\n     */\r\n    public get(type: \"service\" | \"transition\" | \"state\" | string, key: any): Service | ITransition | IState {\r\n        switch (type.toLowerCase()) {\r\n            case \"service\":\r\n                return this.services.get(key);\r\n            case \"transition\":\r\n                return this.transitions.get(key);\r\n            case \"state\":\r\n                return this.history.get(key);\r\n            default:\r\n                throw `Error: can't get type '${type}', it is not a recognized type. Did you spell it correctly.`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will return load either Page a Transition, a Service, a State, or a Page from their respective Managers\r\n     *\r\n     * @param {(\"page\" | string)} type\r\n     * @param {any} key\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public async load(type: \"page\" | string, key: any): Promise<any> {\r\n        switch (type.toLowerCase()) {\r\n            case \"page\":\r\n                return await this.pages.load(key);\r\n            default:\r\n                return Promise.resolve(this.get(type, key));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a Service to the App's instance of the ServiceManager, with a name\r\n     *\r\n     * @param {string} key\r\n     * @param {Service} service\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public setService(key: string, service: Service): App {\r\n        this.services.set(key, service);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a Service to the App's instance of the ServiceManager, with a name\r\n     *\r\n     * @param {string} key\r\n     * @param {ITransition} tranisition\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public setTransition(key: string, transition: ITransition): App {\r\n        this.transitions.set(key, transition);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will add either a Transition, a Service, or a State to their respective Managers\r\n     *\r\n     * @param {(\"service\" | \"transition\" | \"state\")} type\r\n     * @param {any} value\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public add(type: \"service\" | \"transition\" | \"state\", value: any): App {\r\n        switch (type.toLowerCase()) {\r\n            case \"service\":\r\n                this.services.add(value);\r\n                break;\r\n            case \"transition\":\r\n                this.transitions.set(value.name, value);\r\n                break;\r\n            case \"state\":\r\n                this.history.add(value);\r\n                break;\r\n            default:\r\n                throw `Error: can't add type '${type}', it is not a recognized type. Did you spell it correctly.`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Start the App and the ServiceManager\r\n     *\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public boot(): App {\r\n        this.services.init();\r\n        this.services.boot();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stop the App and the ServiceManager\r\n     *\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public stop(): App {\r\n        this.services.stop();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter on method\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public on(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.on(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter off method\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public off(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.off(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter emit method\r\n     *\r\n     * @param {(string | any[])} events\r\n     * @param {...any} args\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public emit(events: string | any[], ...args: any): App {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n}\r\n", "import { newState, Trigger, IState, newCoords, IHistoryItem } from \"./history\";\r\nimport { Service } from \"./service\";\r\nimport { Page } from \"./page\";\r\nimport { newURL, getHashedPath, equal } from \"./url\";\r\n\r\nexport type LinkEvent = MouseEvent | TouchEvent;\r\nexport type StateEvent = LinkEvent | PopStateEvent;\r\nexport type IgnoreURLsList = Array<RegExp | string>;\r\n\r\n/**\r\n * Creates a Barba JS like PJAX Service, for the Framework\r\n *\r\n * @export\r\n * @class PJAX\r\n * @extends {Service}\r\n */\r\n// Based on Barba JS and StartingBlocks\r\nexport class PJAX extends Service {\r\n    /**\r\n     * URLs to ignore when prefetching\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected ignoreURLs: IgnoreURLsList = [];\r\n\r\n    /**\r\n     * Whether or not to disable prefetching\r\n     *\r\n     * @private\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    protected prefetchIgnore: boolean = false;\r\n\r\n    /**\r\n     * Current state or transitions\r\n     *\r\n     * @public\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    public isTransitioning: boolean = false;\r\n\r\n    /**\r\n     * Ignore extra clicks of an anchor element if a transition has already started\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected stopOnTransitioning: boolean = false;\r\n\r\n    /**\r\n     * On page change (excluding popstate event) keep current scroll position\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected stickyScroll: boolean = false;\r\n\r\n    /**\r\n     * Force load a page if an error occurs\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected forceOnError: boolean = false;\r\n\r\n    /**\r\n     * Dictates whether to auto scroll if an hash is present in the window URL\r\n     *\r\n     * @protected\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected autoScrollOnHash: boolean = true;\r\n\r\n    /**\r\n     * Disables all extra scroll effects of PJAX, however, it won't affect scroll on hash,\r\n     * since scrolling when an hash is in the URL is the default behavior\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected dontScroll: boolean = true;\r\n\r\n    /**\r\n     * Sets the transition state, sets isTransitioning to true\r\n     *\r\n     * @private\r\n     * @memberof PJAX\r\n     */\r\n    private transitionStart() {\r\n        this.isTransitioning = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition state, sets isTransitioning to false\r\n     *\r\n     * @private\r\n     * @memberof PJAX\r\n     */\r\n    private transitionStop() {\r\n        this.isTransitioning = false;\r\n    }\r\n\r\n    public init() {\r\n        super.init();\r\n\r\n        /**\r\n         * Bind the event listeners to the PJAX class\r\n         *\r\n         * @memberof PJAX\r\n         */\r\n        this.onHover = this.onHover.bind(this);\r\n        this.onClick = this.onClick.bind(this);\r\n        this.onStateChange = this.onStateChange.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Starts the PJAX Service\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public boot() {\r\n        if (\"scrollRestoration\" in window.history) {\r\n            // Back off, browser, I got this...\r\n            window.history.scrollRestoration = \"manual\";\r\n        }\r\n\r\n        super.boot();\r\n    }\r\n\r\n    /**\r\n     * Gets the transition to use for a certain anchor\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {(string | null)}\r\n     * @memberof PJAX\r\n     */\r\n    public getTransitionName(el: HTMLAnchorElement): string | null {\r\n        if (!el || !el.getAttribute) return null;\r\n        let transitionAttr = el.getAttribute(\r\n            this.config.getConfig(\"transitionAttr\", false)\r\n        );\r\n        if (typeof transitionAttr === \"string\") return transitionAttr;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the anchor is valid\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @param {(LinkEvent | KeyboardEvent)} event\r\n     * @param {string} href\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public validLink(\r\n        el: HTMLAnchorElement,\r\n        event: LinkEvent | KeyboardEvent,\r\n        href: string\r\n    ): boolean {\r\n        let pushStateSupport = !window.history.pushState;\r\n        let exists = !el || !href;\r\n        let eventMutate =\r\n            (event as KeyboardEvent).metaKey ||\r\n            (event as KeyboardEvent).ctrlKey ||\r\n            (event as KeyboardEvent).shiftKey ||\r\n            (event as KeyboardEvent).altKey;\r\n        let newTab =\r\n            el.hasAttribute(\"target\") &&\r\n            (el as HTMLAnchorElement).target === \"_blank\";\r\n        let crossOrigin =\r\n            (el as HTMLAnchorElement).protocol !== location.protocol ||\r\n            (el as HTMLAnchorElement).hostname !== location.hostname;\r\n        let download = typeof el.getAttribute(\"download\") === \"string\";\r\n        let preventSelf = el.hasAttribute(this.config.getConfig(\"preventSelfAttr\", false));\r\n        let preventAll = Boolean(\r\n            el.closest(this.config.getConfig(\"preventAllAttr\"))\r\n        );\r\n        let prevent = preventSelf && preventAll;\r\n        let sameURL = getHashedPath(newURL()) === getHashedPath(newURL(href));\r\n        return !(\r\n            exists ||\r\n            pushStateSupport ||\r\n            eventMutate ||\r\n            newTab ||\r\n            crossOrigin ||\r\n            download ||\r\n            prevent ||\r\n            sameURL\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the href or an Anchor element\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {(string | null)}\r\n     * @memberof PJAX\r\n     */\r\n    public getHref(el: HTMLAnchorElement): string | null {\r\n        if (\r\n            el &&\r\n            el.tagName &&\r\n            el.tagName.toLowerCase() === \"a\" &&\r\n            typeof el.href === \"string\"\r\n        )\r\n            return el.href;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if event target is a valid anchor with an href, if so, return the link\r\n     *\r\n     * @param {LinkEvent} event\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public getLink(event: LinkEvent): HTMLAnchorElement {\r\n        let el = event.target as HTMLAnchorElement;\r\n        let href: string = this.getHref(el);\r\n\r\n        while (el && !href) {\r\n            el = (el as HTMLElement).parentNode as HTMLAnchorElement;\r\n            href = this.getHref(el);\r\n        }\r\n\r\n        // Check for a valid link\r\n        if (!el || !this.validLink(el, event, href)) return;\r\n        return el;\r\n    }\r\n\r\n    /**\r\n     * When an element is clicked.\r\n     *\r\n     * Get valid anchor element.\r\n     * Go for a transition.\r\n     *\r\n     * @param {LinkEvent} event\r\n     * @returns\r\n     * @memberof PJAX\r\n     */\r\n    public onClick(event: LinkEvent) {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        if (this.isTransitioning && this.stopOnTransitioning) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            return;\r\n        }\r\n\r\n        let href = this.getHref(el);\r\n        this.emitter.emit(\"ANCHOR_CLICK CLICK\", event);\r\n        this.go({ href, trigger: el, event });\r\n    }\r\n\r\n    /**\r\n     * Returns the direction of the State change as a String, either the Back button or the Forward button\r\n     *\r\n     * @param {number} value\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public getDirection(value: number): Trigger {\r\n        if (Math.abs(value) > 1) {\r\n            // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\r\n            return value > 0 ? \"forward\" : \"back\";\r\n        } else {\r\n            if (value === 0) {\r\n                return \"popstate\";\r\n            } else {\r\n                // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\r\n                return value > 0 ? \"back\" : \"forward\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force a page to go to a certain URL\r\n     *\r\n     * @param {string} href\r\n     * @memberof PJAX\r\n     */\r\n    public force(href: string): void {\r\n        window.location.assign(href);\r\n    }\r\n\r\n    /**\r\n     * If transition is running force load page.\r\n     * Stop if currentURL is the same as new url.\r\n     * On state change, change the current state history,\r\n     * to reflect the direction of said state change\r\n     * Load page and page transition.\r\n     *\r\n     * @param {string} href\r\n     * @param {Trigger} [trigger='HistoryManager']\r\n     * @param {StateEvent} [event]\r\n     * @memberof PJAX\r\n     */\r\n    public go({\r\n        href,\r\n        trigger = \"HistoryManager\",\r\n        event,\r\n    }: {\r\n        href: string;\r\n        trigger?: Trigger;\r\n        event?: StateEvent;\r\n    }): Promise<void> {\r\n        // If transition is already running and the go method is called again, force load page\r\n        if (this.isTransitioning && this.stopOnTransitioning) {\r\n            this.force(href);\r\n            return;\r\n        }\r\n\r\n        let scroll = { x: 0, y: 0 };\r\n        let currentState = this.HistoryManager.current;\r\n        let currentURL = currentState.url;\r\n        if (equal(currentURL, href)) {\r\n            return;\r\n        }\r\n\r\n        let transitionName: string;\r\n        if (event && (event as PopStateEvent).state) {\r\n            this.emitter.emit(\"POPSTATE\", event);\r\n\r\n            // If popstate, get back/forward direction.\r\n            let { state }: { state: IHistoryItem } = event as PopStateEvent;\r\n            let { index } = state;\r\n            let currentIndex = currentState.index;\r\n            let difference = currentIndex - index;\r\n\r\n            trigger = this.getDirection(difference);\r\n\r\n            // Based on the direction of the state change either remove or add a state\r\n            this.HistoryManager.replace(state.states);\r\n            this.HistoryManager.pointer = index;\r\n            if (trigger === \"back\") {\r\n                // this.HistoryManager.remove(currentIndex);\r\n                this.emitter.emit(`POPSTATE_BACK`, event);\r\n            } else if (trigger === \"forward\") {\r\n                // this.HistoryManager.add({ url: href, transition, data });\r\n                this.emitter.emit(`POPSTATE_FORWARD`, event);\r\n            }\r\n\r\n            let _state = this.HistoryManager.get(index);\r\n            transitionName = _state.transition;\r\n\r\n            // If the page remains on the same history state DO NOT scroll, it's pointless\r\n            if (trigger !== \"popstate\") {\r\n                // Keep scroll position\r\n                scroll = _state.data.scroll;\r\n            }\r\n        } else {\r\n            // Add new state\r\n            transitionName = this.getTransitionName(trigger as HTMLAnchorElement) ||\r\n                \"default\";\r\n            let scrollCoords = newCoords();\r\n\r\n            if (!this.dontScroll && this.stickyScroll) {\r\n                // Keep scroll position\r\n                let { x, y } = scrollCoords;\r\n                scroll = { x, y };\r\n            } else {\r\n                scroll = {\r\n                    x: 0,\r\n                    y: 0\r\n                };\r\n            }\r\n\r\n            let state = newState({\r\n                url: href,\r\n                transition: transitionName,\r\n                data: { scroll: scrollCoords },\r\n            });\r\n\r\n            this.HistoryManager.add(state);\r\n            this.emitter.emit(\"HISTORY_NEW_ITEM\", event);\r\n        }\r\n\r\n        if (event) {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n\r\n        this.emitter.emit(\"GO\", event);\r\n        return this.load({\r\n            oldHref: currentURL,\r\n            href,\r\n            trigger,\r\n            transitionName,\r\n            scroll,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load the new Page as well as a Transition; run the Transition\r\n     *\r\n     * @param {string} oldHref\r\n     * @param {string} href\r\n     * @param {Trigger} trigger\r\n     * @param {string} [transitionName=\"default\"]\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public async load({\r\n        oldHref,\r\n        href,\r\n        trigger,\r\n        transitionName = \"default\",\r\n        scroll = { x: 0, y: 0 },\r\n    }: {\r\n        oldHref: string;\r\n        href: string;\r\n        trigger: Trigger;\r\n        transitionName?: string;\r\n        scroll: { x: number; y: number };\r\n    }): Promise<any> {\r\n        try {\r\n            let oldPage = await this.PageManager.load(oldHref);\r\n            await oldPage.build();\r\n            let newPage: Page;\r\n\r\n            this.emitter.emit(\"PAGE_LOADING\", { href, oldPage, trigger });\r\n            try {\r\n                try {\r\n                    newPage = await this.PageManager.load(href);\r\n                    await newPage.build();\r\n                    this.transitionStart();\r\n                    this.emitter.emit(\"PAGE_LOAD_COMPLETE\", {\r\n                        newPage,\r\n                        oldPage,\r\n                        trigger,\r\n                    });\r\n                } catch (err) {\r\n                    console.error(`[PJAX] page load error: ${err}`);\r\n                }\r\n\r\n                // --\r\n                // --\r\n\r\n                this.emitter.emit(\"NAVIGATION_START\", {\r\n                    oldPage,\r\n                    newPage,\r\n                    trigger,\r\n                    transitionName,\r\n                });\r\n\r\n                try {\r\n                    this.emitter.emit(\"TRANSITION_START\", transitionName);\r\n                    let transition = await this.TransitionManager.boot(transitionName, {\r\n                        oldPage,\r\n                        newPage,\r\n                        trigger,\r\n                        scroll,\r\n                    });\r\n\r\n                    if (!transition.scrollable) {\r\n                        if (!/back|popstate|forward/.test(trigger as string)) scroll = hashAction(href);\r\n                        window.scroll(scroll.x, scroll.y);\r\n                    }\r\n\r\n                    this.emitter.emit(\"TRANSITION_END\", { transition });\r\n\r\n                } catch (err) {\r\n                    console.error(`[PJAX] transition error: ${err}`);\r\n                }\r\n\r\n                this.emitter.emit(\"NAVIGATION_END\", {\r\n                    oldPage,\r\n                    newPage,\r\n                    trigger,\r\n                    transitionName,\r\n                });\r\n            } catch (err) {\r\n                this.transitionStop();\r\n                throw err;\r\n            }\r\n\r\n            this.transitionStop(); // Sets isTransitioning to false\r\n        } catch (err) {\r\n            if (this.forceOnError) this.force(href);\r\n            else console.error(err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check to see if the URL is to be ignored, uses either RegExp of Strings to check\r\n     *\r\n     * @param {URL} { pathname }\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public ignoredURL({ pathname }: URL): boolean {\r\n        return (\r\n            this.ignoreURLs.length &&\r\n            this.ignoreURLs.some((url) => {\r\n                return typeof url === \"string\"\r\n                    ? url === pathname\r\n                    : (url as RegExp).exec(pathname) !== null;\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * When you hover over an anchor, prefetch the event target's href\r\n     *\r\n     * @param {LinkEvent} event\r\n     * @memberof PJAX\r\n     */\r\n    public onHover(event: LinkEvent): Promise<void> {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        let url = newURL(this.getHref(el));\r\n        let urlString: string = url.pathname;\r\n        // If Url is ignored or already in cache, don't do any think\r\n        if (this.ignoredURL(url) || this.PageManager.has(urlString)) return;\r\n        this.emitter.emit(\"ANCHOR_HOVER HOVER\", event);\r\n\r\n        try {\r\n            this.PageManager.load(url);\r\n        } catch (err) {\r\n            console.warn(\"[PJAX] prefetch error,\", err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When History state changes.\r\n     *\r\n     * Get url from State\r\n     * Go for a Barba transition.\r\n     *\r\n     * @param {PopStateEvent} event\r\n     * @memberof PJAX\r\n     */\r\n    public onStateChange(event: PopStateEvent): void {\r\n        this.go({ href: window.location.href, trigger: \"popstate\", event });\r\n    }\r\n\r\n    /**\r\n     * Initialize DOM Events\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public initEvents() {\r\n        if (this.prefetchIgnore !== true) {\r\n            document.addEventListener(\"mouseover\", this.onHover);\r\n            document.addEventListener(\"touchstart\", this.onHover);\r\n        }\r\n\r\n        document.addEventListener(\"click\", this.onClick);\r\n        window.addEventListener(\"popstate\", this.onStateChange);\r\n    }\r\n\r\n    /**\r\n     * Stop DOM Events\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public stopEvents() {\r\n        if (this.prefetchIgnore !== true) {\r\n            document.removeEventListener(\"mouseover\", this.onHover);\r\n            document.removeEventListener(\"touchstart\", this.onHover);\r\n        }\r\n\r\n        document.removeEventListener(\"click\", this.onClick);\r\n        window.removeEventListener(\"popstate\", this.onStateChange);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Auto scrolls to an elements position if the element has an hash\r\n *\r\n * @param {string} [hash=window.location.hash]\r\n * @memberof PJAX\r\n */\r\nexport const hashAction = (hash: string = window.location.hash) => {\r\n    try {\r\n        let _hash = hash[0] == \"#\" ? hash : newURL(hash).hash;\r\n        if (_hash.length > 1) {\r\n            let el = document.querySelector(_hash) as HTMLElement;\r\n\r\n            if (el) {\r\n                return { x: el.offsetLeft, y: el.offsetTop };\r\n            }\r\n        }\r\n    } catch (e) {\r\n        console.warn(\"hashAction error\", e);\r\n    }\r\n\r\n    return { x: 0, y: 0 };\r\n};\r\n", "import { Service } from \"./service\";\r\nimport { Manager } from \"./manager\";\r\nimport { newURL, getHashedPath } from \"./url\";\r\n\r\nexport type RouteMethod = (...args: any) => any;\r\nexport type RouteStyle = string | RegExp | boolean;\r\nexport interface IRouteToFrom {\r\n    to: RouteStyle,\r\n    from: RouteStyle\r\n}\r\nexport type RoutePath = IRouteToFrom | RouteStyle;\r\nexport interface IRoute {\r\n    path: RoutePath,\r\n    method: RouteMethod\r\n}\r\n\r\n/**\r\n * Controls what happens when certain url paths match a set of criteria\r\n *\r\n * @export\r\n * @class Router\r\n * @extends {Service}\r\n */\r\nexport class Router extends Service {\r\n    /**\r\n     * List of routes inputted\r\n     *\r\n     * @protected\r\n     * @type {Manager<IRouteToFrom, RouteMethod>}\r\n     * @memberof Router\r\n     */\r\n    protected routes: Manager<IRouteToFrom, RouteMethod>;\r\n\r\n    /**\r\n     * Creates an instance of Router.\r\n     *\r\n     * @param {Array<IRoute>} [routes=[]]\r\n     * @memberof Router\r\n     */\r\n    constructor(routes: IRoute[] = []) {\r\n        super();\r\n        this.routes = new Manager();\r\n        for (let route of routes) {\r\n            this.add(route);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new route to watch for\r\n     *\r\n     * @param {IRoute} { path, method }\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    public add({ path, method }: IRoute): Router {\r\n        let key = this.parse(path);\r\n        this.routes.set(key, method);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Convert strings into path match functions\r\n     *\r\n     * @param {RouteStyle} path\r\n     * @returns {RegExp | boolean}\r\n     * @memberof Router\r\n     */\r\n    public parsePath(path: RouteStyle): RegExp | boolean {\r\n        if (typeof path === \"string\") return new RegExp(path, \"i\");\r\n        else if (path instanceof RegExp || typeof path === \"boolean\")\r\n            return path;\r\n        throw \"[Router] only regular expressions, strings and booleans are accepted as paths.\";\r\n    }\r\n\r\n    /**\r\n     * Determines if a strings counts has a path\r\n     *\r\n     * @param {RouteStyle} input\r\n     * @returns boolean\r\n     * @memberof Router\r\n     */\r\n    public isPath(input: RouteStyle): boolean {\r\n        return (\r\n            typeof input === \"string\" ||\r\n            input instanceof RegExp ||\r\n            typeof input === \"boolean\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Parse the multiple different formats for paths, into a { from, to } object\r\n     *\r\n     * @param {RouteStyle} input\r\n     * @returns {IRouteToFrom}\r\n     * @memberof Router\r\n     */\r\n    public parse(input: RoutePath): IRouteToFrom {\r\n        let route = input as IRouteToFrom;\r\n        let toFromPath: IRouteToFrom = {\r\n            from: /(.*)/g,\r\n            to: /(.*)/g,\r\n        };\r\n\r\n        if (this.isPath(input as RouteStyle))\r\n            toFromPath = {\r\n                from: true,\r\n                to: input as RouteStyle,\r\n            };\r\n        else if (this.isPath(route.from) && this.isPath(route.to as RouteStyle))\r\n            toFromPath = route;\r\n        else\r\n            throw \"[Router] path is neither a string, regular expression, or a { from, to } object.\";\r\n\r\n        let { from, to } = toFromPath;\r\n        return {\r\n            from: this.parsePath(from),\r\n            to: this.parsePath(to),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Test if route paths are true, if so run their methods\r\n     *\r\n     * @memberof Router\r\n     */\r\n    public route() {\r\n        let history = this.HistoryManager;\r\n        let from: string = getHashedPath(newURL((history.length > 1 ? history.previous : history.current).url));\r\n        let to: string = getHashedPath(newURL());\r\n\r\n        this.routes.forEach((method: RouteMethod, path: IRouteToFrom) => {\r\n            let fromRegExp = path.from as RegExp | boolean;\r\n            let toRegExp = path.to as RegExp | boolean;\r\n\r\n            if (\r\n                typeof fromRegExp === \"boolean\" &&\r\n                typeof toRegExp === \"boolean\"\r\n            ) {\r\n                throw `[Router] path ({ from: ${fromRegExp}, to: ${toRegExp} }) is not valid, remember paths can only be strings, regular expressions, or a boolean; however, both the from and to paths cannot be both booleans.`;\r\n            }\r\n\r\n            let fromParam: RegExpExecArray | RegExp | boolean = fromRegExp;\r\n            let toParam: RegExpExecArray | RegExp | boolean = toRegExp;\r\n\r\n            if (fromRegExp instanceof RegExp && fromRegExp.test(from))\r\n                fromParam = fromRegExp.exec(from);\r\n            if (toRegExp instanceof RegExp && toRegExp.test(to))\r\n                toParam = toRegExp.exec(to);\r\n\r\n            if (\r\n                (Array.isArray(toParam) && Array.isArray(fromParam)) ||\r\n                (Array.isArray(toParam) &&\r\n                    typeof fromParam == \"boolean\" &&\r\n                    fromParam) ||\r\n                (Array.isArray(fromParam) &&\r\n                    typeof toParam == \"boolean\" &&\r\n                    toParam)\r\n            )\r\n                method({ from: fromParam, to: toParam, path: { from, to } });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add listeners for PJAX Events\r\n     *\r\n     * @memberof Router\r\n     */\r\n    public initEvents() {\r\n        this.emitter.on(\"READY\", this.route, this);\r\n        this.emitter.on(\"CONTENT_REPLACED\", this.route, this);\r\n    }\r\n\r\n    /**\r\n     * Remove listeners for PJAX Events\r\n     *\r\n     * @memberof Router\r\n     */\r\n    public stopEvents() {\r\n        this.emitter.off(\"READY\", this.route, this);\r\n        this.emitter.off(\"CONTENT_REPLACED\", this.route, this);\r\n    }\r\n}\r\n", "import { EventEmitter, EventInput, ListenerCallback } from \"@okikio/emitter\";\r\n\r\n// DOM\r\nexport type AnimationTarget = string | Node | NodeList | HTMLCollection | HTMLElement[] | any[];\r\nexport const getElements = (selector: string | Node): Node[] => {\r\n    return typeof selector === \"string\" ? Array.from(document.querySelectorAll(selector as string)) : [selector];\r\n};\r\n\r\nexport const getTargets = (targets: AnimationTarget): Node[] => {\r\n    if (Array.isArray(targets)) return targets;\r\n    if (typeof targets == \"string\" || targets instanceof Node)\r\n        return getElements(targets);\r\n    if (targets instanceof NodeList || targets instanceof HTMLCollection)\r\n        return Array.from(targets);\r\n    return [];\r\n};\r\n\r\n// VALUES\r\nexport type closureArgs = [number, number, HTMLElement];\r\nexport type closure = ((index?: number, total?: number, element?: HTMLElement) => any) | any;\r\nexport const computeValue = (value: closure, args: closureArgs) => {\r\n    if (typeof value === \"function\") {\r\n        return value(...args);\r\n    } else { return value; }\r\n};\r\n\r\nexport const mapObject = (obj: object, args: closureArgs): any => {\r\n    let key, value, result = {};\r\n    let keys = Object.keys(obj);\r\n    for (let i = 0, len = keys.length; i < len; i++) {\r\n        key = keys[i];\r\n        value = obj[key];\r\n        result[key] = computeValue(value, args);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n// From: [https://easings.net]\r\nexport const easings = {\r\n    \"ease\": \"ease\",\r\n    \"in\": \"ease-in\",\r\n    \"out\": \"ease-out\",\r\n    \"in-out\": \"ease-in-out\",\r\n\r\n    // Sine\r\n    \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n    \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n    \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n\r\n    // Quad\r\n    \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n    \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n    \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n\r\n    // Cubic\r\n    \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n    \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n    \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n\r\n    // Quart\r\n    \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n    \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n    \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n\r\n    // Quint\r\n    \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n    \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n    \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n\r\n    // Expo\r\n    \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n    \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n    \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n\r\n    // Circ\r\n    \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n    \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n    \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n\r\n    // Back\r\n    \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n    \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n    \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n};\r\nexport const getEase = (ease: string) => {\r\n    return /^(ease|in|out)/.test(ease) ? easings[ease] : ease;\r\n};\r\n\r\nexport interface AnimationOptions {\r\n    target?: AnimationTarget,\r\n\r\n    speed?: number | closure,\r\n    delay?: number | closure,\r\n    easing?: string | closure,\r\n    endDelay?: number | closure,\r\n    duration?: number | closure,\r\n    autoplay?: boolean | closure,\r\n    keyframes?: object[] | closure,\r\n    loop?: number | boolean | closure, // iterations: number,\r\n    options?: AnimationOptions | closure,\r\n    onfinish?: (element?: HTMLElement, index?: number, total?: number) => any,\r\n    fillMode?: \"none\" | \"forwards\" | \"backwards\" | \"both\" | \"auto\" | closure,\r\n    direction?: \"normal\" | \"reverse\" | \"alternate\" | \"alternate-reverse\" | closure,\r\n    [property: string]: closure | boolean | object | string | string[] | number | null | (number | null)[] | undefined;\r\n};\r\n\r\nexport const DefaultAnimationOptions: AnimationOptions = {\r\n    keyframes: [],\r\n\r\n    loop: 1, // iterations: number,\r\n    delay: 0,\r\n    speed: 1,\r\n    endDelay: 0,\r\n    easing: \"ease\",\r\n    autoplay: true,\r\n    duration: 1000,\r\n    onfinish() { },\r\n    fillMode: \"auto\",\r\n    direction: \"normal\",\r\n};\r\n\r\n// You can check it out here: https://codepen.io/okikio/pen/qBbdGaW?editors=0011\r\nexport class Animate {\r\n    /**\r\n     * Stores the options for the current animation\r\n     *\r\n     * @public\r\n     * @type AnimationOptions\r\n     * @memberof Animate\r\n     */\r\n    public options: AnimationOptions = {};\r\n\r\n    /**\r\n     * The Array of Elements to Animate\r\n     *\r\n     * @public\r\n     * @type {Node[]}\r\n     * @memberof Animate\r\n     */\r\n    public targets: Node[] = [];\r\n\r\n    /**\r\n     * The properties to animate\r\n     *\r\n     * @public\r\n     * @type {object}\r\n     * @memberof Animate\r\n     */\r\n    public properties: object = {};\r\n\r\n    /**\r\n     * A Set of Animations\r\n     *\r\n     * @public\r\n     * @type {Map<HTMLElement, Animation>}\r\n     * @memberof Animate\r\n     */\r\n    public animations: Map<HTMLElement, Animation> = new Map();\r\n\r\n    /**\r\n     * The total duration of all Animation's\r\n     *\r\n     * @public\r\n     * @type {number}\r\n     * @memberof Animate\r\n     */\r\n    public duration: number = 0;\r\n\r\n    /**\r\n     * The Element the main animation uses\r\n     *\r\n     * @public\r\n     * @type {HTMLElement}\r\n     * @memberof Animate\r\n     */\r\n    public mainElement: HTMLElement;\r\n\r\n    /**\r\n     * Stores an animation that runs on the total duration of the all other Animations, and as such it's the main Animation\r\n     *\r\n     * @public\r\n     * @type {Animation}\r\n     * @memberof Animate\r\n     */\r\n    public mainAnimation: Animation;\r\n\r\n    /**\r\n     * Stores request frame calls\r\n     *\r\n     * @public\r\n     * @type {number}\r\n     * @memberof Animate\r\n     */\r\n    public animationFrame: number;\r\n\r\n    /**\r\n     * An event emitter\r\n     *\r\n     * @public\r\n     * @type {EventEmitter}\r\n     * @memberof Animate\r\n     */\r\n    public emitter: EventEmitter = new EventEmitter();\r\n\r\n    /**\r\n     * The finish method, is called when the main animation has finished\r\n     *\r\n     * @public\r\n     * @type {*}\r\n     * @memberof Animate\r\n     */\r\n    public finish: any;\r\n\r\n    /**\r\n     * Returns a promise that is fulfilled when the mainAnimation is finished\r\n     *\r\n     * @public\r\n     * @type {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public promise: Promise<AnimationOptions>;\r\n\r\n    /**\r\n     * Creates an instance of Animate.\r\n     *\r\n     * @param {AnimationOptions} options\r\n     * @memberof Animate\r\n     */\r\n    constructor(options: AnimationOptions = {}) {\r\n        let { options: animation, ...rest } = options;\r\n        this.options = Object.assign({}, DefaultAnimationOptions, animation, rest);\r\n        this.loop = this.loop.bind(this);\r\n\r\n        let {\r\n            loop,\r\n            delay,\r\n            speed,\r\n            easing,\r\n            endDelay,\r\n            duration,\r\n            direction,\r\n            fillMode,\r\n            onfinish,\r\n            target,\r\n            keyframes,\r\n            autoplay,\r\n            ...properties\r\n        } = this.options;\r\n\r\n        this.mainElement = document.createElement(\"span\");\r\n        this.targets = getTargets(target);\r\n        this.properties = properties;\r\n\r\n        let animationKeyframe: Keyframe[] | PropertyIndexedKeyframes;\r\n        for (let i = 0, len = this.targets.length; i < len; i++) {\r\n            let target = this.targets[i] as HTMLElement;\r\n            let animationOptions = {\r\n                easing: getEase(easing),\r\n                iterations: loop === true ? Infinity : (loop as number),\r\n                direction,\r\n                endDelay,\r\n                duration,\r\n                delay,\r\n                fill: fillMode,\r\n            };\r\n\r\n            // Accept keyframes as a keyframes Object, or a method,\r\n            // if there are no animations in the keyframes array,\r\n            // uses css properties from the options object\r\n            let arrKeyframes = computeValue((keyframes as Keyframe[]), [i, len, target]);\r\n            animationKeyframe = arrKeyframes.length ? arrKeyframes :\r\n                (this.properties as PropertyIndexedKeyframes);\r\n\r\n            // Allows the use of functions as the values, for both the keyframes and the animation object\r\n            // It adds the capability of advanced stagger animation, similar to the anime js stagger functions\r\n            animationOptions = mapObject(animationOptions, [i, len, target]);\r\n            if (!(arrKeyframes.length > 0))\r\n                animationKeyframe = mapObject(animationKeyframe, [i, len, target]);\r\n\r\n            // Set the Animate classes duration to be the Animation with the largest totalDuration\r\n            let tempDuration: number =\r\n                animationOptions.delay +\r\n                (animationOptions.duration * animationOptions.iterations) +\r\n                animationOptions.endDelay;\r\n            if (this.duration < tempDuration) this.duration = tempDuration;\r\n\r\n            // Add animation to the Animations Set\r\n            let animation = target.animate(animationKeyframe, animationOptions);\r\n            animation.onfinish = () => {\r\n                onfinish(target, i, len);\r\n            };\r\n            this.animations.set(target, animation);\r\n        }\r\n\r\n        this.mainAnimation = this.mainElement.animate([\r\n            { opacity: \"0\" },\r\n            { opacity: \"1\" }\r\n        ], {\r\n            duration: this.duration,\r\n            easing: \"linear\"\r\n        });\r\n\r\n        this.setSpeed(speed);\r\n        if (autoplay) this.play();\r\n        else this.pause();\r\n\r\n        this.promise = this.newPromise();\r\n        this.mainAnimation.onfinish = () => {\r\n            this.finish(this.options);\r\n            window.cancelAnimationFrame(this.animationFrame);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the Array of targets\r\n     *\r\n     * @returns {Node[]}\r\n     * @memberof Animate\r\n     */\r\n    public getTargets(): Node[] {\r\n        return this.targets;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Promise that is resolve when this.finish is called\r\n     *\r\n     * @public\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public newPromise(): Promise<AnimationOptions> {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                this.finish = (options: AnimationOptions) => {\r\n                    this.emit(\"finish\", options);\r\n                    return resolve(options);\r\n                };\r\n            } catch (err) { reject(err); }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fulfills the this.promise Promise\r\n     *\r\n     * @param {(value?: any) => any} [onFulfilled]\r\n     * @param {(reason?: any) => any} [onRejected]\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public then(\r\n        onFulfilled?: (value?: any) => any,\r\n        onRejected?: (reason?: any) => any\r\n    ): Promise<AnimationOptions> {\r\n        return this.promise.then(onFulfilled, onRejected);\r\n    }\r\n\r\n    /**\r\n     * Catches error that occur in the this.promise Promise\r\n     *\r\n     * @param {(reason?: any) => any} onRejected\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public catch(onRejected: (reason?: any) => any): Promise<AnimationOptions> {\r\n        return this.promise.catch(onRejected);\r\n    }\r\n\r\n    /**\r\n     * If you don't care if the this.promise Promise has either been rejected or resolved\r\n     *\r\n     * @param {() => any} onFinally\r\n     * @returns {Promise<AnimationOptions>}\r\n     * @memberof Animate\r\n     */\r\n    public finally(onFinally: () => any): Promise<AnimationOptions> {\r\n        return this.promise.finally(onFinally);\r\n    }\r\n\r\n    /**\r\n     * Represents an Animation Frame Loop\r\n     *\r\n     * @public\r\n     * @memberof Animate\r\n     */\r\n    public loop(): void {\r\n        this.animationFrame = window.requestAnimationFrame(this.loop);\r\n        this.emit(\"tick change\", this.getCurrentTime());\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} [callback]\r\n     * @param {object} [scope]\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public on(events: EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.on(events, callback, scope);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} [callback]\r\n     * @param {object} [scope]\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public off(events: EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.off(events, callback, scope);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     *\r\n     * @param {(string | any[])} events\r\n     * @param {...any} args\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public emit(events: string | any[], ...args: any): Animate {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get a specific Animation from an Animate instance\r\n     *\r\n     * @param {HTMLElement} element\r\n     * @returns {Animation}\r\n     * @memberof Animate\r\n     */\r\n    public getAnimation(element: HTMLElement): Animation {\r\n        return this.animations.get(element);\r\n    }\r\n\r\n    /**\r\n     * Play Animation's\r\n     *\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public play(): Animate {\r\n        // Once the animation is done, it's done, it can only be paused by the reset method\r\n        if (this.mainAnimation.playState !== \"finished\") {\r\n            this.mainAnimation.play();\r\n            this.animationFrame = requestAnimationFrame(this.loop);\r\n            this.animations.forEach(animation => {\r\n                if (animation.playState !== \"finished\") animation.play();\r\n            });\r\n            this.emit(\"play\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause Animation's\r\n     *\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public pause(): Animate {\r\n        // Once the animation is done, it's done, it can only be reset by the reset method\r\n        if (this.mainAnimation.playState !== \"finished\") {\r\n            this.mainAnimation.pause();\r\n            window.cancelAnimationFrame(this.animationFrame);\r\n            this.animations.forEach(animation => {\r\n                if (animation.playState !== \"finished\") animation.pause();\r\n            });\r\n            this.emit(\"pause\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the total duration of all Animations\r\n     *\r\n     * @returns {number}\r\n     * @memberof Animate\r\n     */\r\n    public getDuration(): number {\r\n        return this.duration;\r\n    }\r\n\r\n    /**\r\n     * Returns the current time of the Main Animation\r\n     *\r\n     * @returns {number}\r\n     * @memberof Animate\r\n     */\r\n    public getCurrentTime(): number {\r\n        return this.mainAnimation.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Set the current time of the Main Animation\r\n     *\r\n     * @param {number} time\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public setCurrentTime(time: number): Animate {\r\n        this.mainAnimation.currentTime = time;\r\n        this.animations.forEach(animation => {\r\n            animation.currentTime = time;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the Animation progress as a fraction of the current time / duration\r\n     *\r\n     * @returns\r\n     * @memberof Animate\r\n     */\r\n    public getProgress() {\r\n        return this.getCurrentTime() / this.duration;\r\n    }\r\n\r\n    /**\r\n     * Set the Animation progress as a fraction of the current time / duration\r\n     *\r\n     * @param {number} percent\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public setProgress(percent: number): Animate {\r\n        this.mainAnimation.currentTime = percent * this.duration;\r\n        this.animations.forEach(animation => {\r\n            animation.currentTime = percent * this.duration;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the playback speed of the animation\r\n     *\r\n     * @returns {number}\r\n     * @memberof Animate\r\n     */\r\n    public getSpeed(): number {\r\n        return this.mainAnimation.playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Set the playback speed of an Animation\r\n     *\r\n     * @param {number} [speed=1]\r\n     * @returns {Animate}\r\n     * @memberof Animate\r\n     */\r\n    public setSpeed(speed: number = 1): Animate {\r\n        this.mainAnimation.playbackRate = speed;\r\n        this.animations.forEach(animation => {\r\n            animation.playbackRate = speed;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all Animations\r\n     *\r\n     * @memberof Animate\r\n     */\r\n    public reset() {\r\n        this.setCurrentTime(0);\r\n        this.promise = this.newPromise();\r\n\r\n        if (this.options.autoplay) this.play();\r\n        else this.pause();\r\n    }\r\n\r\n    /**\r\n     * Returns the current playing state\r\n     *\r\n     * @returns {(\"idle\" | \"running\" | \"paused\" | \"finished\")}\r\n     * @memberof Animate\r\n     */\r\n    public getPlayState(): \"idle\" | \"running\" | \"paused\" | \"finished\" {\r\n        return this.mainAnimation.playState;\r\n    }\r\n\r\n    /**\r\n     * Get the options of an Animate instance\r\n     *\r\n     * @returns {AnimationOptions}\r\n     * @memberof Animate\r\n     */\r\n    public getOptions(): AnimationOptions {\r\n        return this.options;\r\n    }\r\n\r\n    // Returns the Animate options, as JSON\r\n    public toJSON(): AnimationOptions {\r\n        return this.getOptions();\r\n    }\r\n}\r\n\r\n// Creates a new Animate instance\r\nexport const animate = (options: AnimationOptions = {}): Animate => {\r\n    return new Animate(options);\r\n};\r\n\r\nexport default animate;\r\n"],
  "mappings": "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",
  "names": []
}
