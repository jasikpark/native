{
  "version": 3,
  "sources": ["packages/manager/src/api.ts", "packages/native/src/page.ts", "packages/emitter/src/api.ts", "packages/animate/src/builtin-effects.ts", "packages/animate/src/api.ts", "build/ts/animate.ts"],
  "sourcesContent": ["/**\r\n * Acts as an enhanced version of the Map class with new features and changed behavior for convenience\r\n *\r\n * @typeParam K - the type of keys to store use to store values\r\n * @typeParam V - the type of values to store\r\n * */\r\nexport class Manager<K, V> {\r\n\t/** For backward compatability and performance reasons Manager use Map to store data */\r\n\tpublic map: Map<K, V>;\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/** Returns the Manager classes base Map */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/** Get a value stored in the Manager */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/** Returns the keys of all items stored in the Manager as an Array */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\t/** Returns the values of all items stored in the Manager as an Array */\r\n\tpublic values(): Array<V> {\r\n\t\treturn Array.from(this.map.values());\r\n\t}\r\n\r\n\t/** Set a value to the Manager using a key */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\tlet size = this.size;\r\n\t\t// @ts-ignore\r\n\t\tlet num: K = size as K;\r\n\t\tthis.set(num, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Returns the total number of items stored in the Manager */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** An alias for size */\r\n\tpublic get length(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** Returns the last item in the Manager who's index is a certain distance from the last item in the Manager */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns true if an element in the Map object existed and has been removed, or false if the element does not exist */\r\n\tpublic delete(key: K): boolean {\r\n\t\treturn this.map.delete(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns the Manager class, allowing for chains */\r\n\tpublic remove(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Clear the Manager of all its contents */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Checks if the Manager contains a certain key */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/** Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order. */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/** Iterates through the Managers contents, calling a callback function every iteration */\r\n\tpublic forEach(\r\n\t\tcallback: (value?: V, key?: K, map?: Map<K, V>) => void,\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Allows for iteration via for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators] */\r\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\r\n\t\treturn this.entries();\r\n\t}\r\n}\r\n\r\n/**\r\n * Calls the method of a certain name for all items that are currently installed\r\n */\r\nexport const methodCall = (manager: Manager<any, any>, method: string, ...args: any): void => {\r\n\tmanager.forEach((item) => {\r\n\t\t// @ts-ignore\r\n\t\titem[method](...args);\r\n\t});\r\n};\r\n\r\n/**\r\n * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n */\r\nexport const asyncMethodCall = async (manager: Manager<any, any>, method: string, ...args: any): Promise<void> => {\r\n\tfor (let [, item] of manager) {\r\n\t\t// @ts-ignore\r\n\t\tawait item[method](...args);\r\n\t}\r\n};\r\n\r\nexport default Manager;\r\n", "import { Manager, ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { equal, newURL } from \"./url\";\r\nimport { getConfig } from \"./config\";\r\nimport { Service } from \"./service\";\r\n\r\nexport interface IPage extends ManagerItem {\r\n    dom: Document,\r\n    wrapper: HTMLElement,\r\n    title: string,\r\n    head: Element,\r\n    body: Element,\r\n    url: URL,\r\n    data: string,\r\n    wrapperAttr: string,\r\n\r\n    build(): any,\r\n    install(): void,\r\n    uninstall(): any,\r\n}\r\n\r\n/**\r\n * Parses strings to DOM\r\n */\r\nexport const PARSER: DOMParser = new DOMParser();\r\n\r\n/** A page represents the DOM elements that create each page */\r\nexport class Page extends ManagerItem implements IPage {\r\n    /** Holds the DOM of the current page */\r\n    public dom: Document;\r\n\r\n    /** Holds the wrapper element to be swapped out of each Page */\r\n    public wrapper: HTMLElement;\r\n\r\n    /** Holds the title of each page */\r\n    public title: string;\r\n\r\n    /** Holds the head element of each page */\r\n    public head: Element;\r\n\r\n    /** Holds the body element of each page */\r\n    public body: Element;\r\n\r\n    /** The URL of the current page */\r\n    public url: URL;\r\n\r\n    /** The payload of a page request */\r\n    public data: string;\r\n\r\n    /** Attr that identifies the wrapper */\r\n    public wrapperAttr: string;\r\n\r\n    constructor(url: URL = newURL(), dom: string | Document = document) {\r\n        super();\r\n        this.url = url;\r\n\r\n        if (typeof dom === \"string\") {\r\n            this.data = dom;\r\n        } else this.dom = dom || document;\r\n    }\r\n\r\n    /** Builds the page's dom, and sets the title, head, body, and wrapper properties of the Page class */\r\n    public build() {\r\n        if (!(this.dom instanceof Node)) {\r\n            this.dom = PARSER.parseFromString(this.data, \"text/html\");\r\n        }\r\n\r\n        if (!(this.body instanceof Node)) {\r\n            let { title, head, body } = this.dom;\r\n            this.title = title;\r\n            this.head = head;\r\n            this.body = body;\r\n            this.wrapper = this.body.querySelector(this.wrapperAttr);\r\n        }\r\n    }\r\n\r\n    public install() {\r\n        this.wrapperAttr = getConfig(this.config, \"wrapperAttr\");\r\n    }\r\n\r\n    public uninstall() {\r\n        this.url = undefined;\r\n        this.title = undefined;\r\n        this.head = undefined;\r\n        this.body = undefined;\r\n        this.dom = undefined;\r\n        this.wrapper = undefined;\r\n        this.data = undefined;\r\n        this.wrapperAttr = undefined;\r\n    }\r\n}\r\n\r\nexport interface IPageManager extends Service {\r\n    loading: Manager<string, Promise<string>>,\r\n    pages: AdvancedManager<string, Page>;\r\n\r\n    install(): any,\r\n\r\n    get(key: string): Page,\r\n    add(value: IPage): PageManager,\r\n    set(key: string, value: IPage): PageManager,\r\n    remove(key: string): PageManager,\r\n    has(key: string): boolean,\r\n    clear(): PageManager,\r\n    size: number,\r\n    keys(): any[],\r\n\r\n    load(_url: URL | string): Promise<Page>,\r\n    request(url: string): Promise<string>,\r\n}\r\n\r\n/** Controls which page to load */\r\nexport class PageManager extends Service implements IPageManager {\r\n    /** Stores all fetch requests that are currently loading */\r\n    public loading: Manager<string, Promise<string>> = new Manager();\r\n\r\n    pages: AdvancedManager<string, Page>;\r\n\r\n    /** Instantiate pages, and add the current page to pages */\r\n    install() {\r\n        this.pages = new AdvancedManager(this.app);\r\n\r\n        let URLString = newURL().pathname;\r\n        this.set(URLString, new Page());\r\n        URLString = undefined;\r\n    }\r\n\r\n    get(key: string) { return this.pages.get(key); }\r\n    add(value: IPage) { this.pages.add(value); return this; }\r\n    set(key: string, value: IPage) { this.pages.set(key, value); return this; }\r\n    remove(key: string) { this.pages.remove(key); return this; }\r\n    has(key: string) { return this.pages.has(key); }\r\n    clear() { this.pages.clear(); return this; }\r\n    get size() { return this.pages.size; }\r\n    keys() { return this.pages.keys(); }\r\n\r\n    /** Load from cache or by requesting URL via a fetch request, avoid requesting for the same thing twice by storing the fetch request in \"this.loading\" */\r\n    public async load(_url: URL | string = newURL()): Promise<Page> {\r\n        let url: URL = newURL(_url);\r\n        let urlString: string = url.pathname;\r\n        let page: Page, request: Promise<string>;\r\n\r\n        if (this.has(urlString)) {\r\n            page = this.get(urlString);\r\n            return Promise.resolve(page);\r\n        }\r\n\r\n        if (!this.loading.has(urlString)) {\r\n            request = this.request(urlString);\r\n            this.loading.set(urlString, request);\r\n        } else request = this.loading.get(urlString);\r\n\r\n        let response = await request;\r\n        this.loading.remove(urlString);\r\n\r\n        page = new Page(url, response);\r\n        this.set(urlString, page);\r\n\r\n        if (this.size > getConfig(this.config, \"maxPages\")) {\r\n            let currentUrl = newURL();\r\n            let keys = this.keys();\r\n            let first = equal(currentUrl, keys[0]) ? keys[1] : keys[0];\r\n            let page = this.get(first);\r\n            page.unregister();\r\n            page = undefined;\r\n            keys = undefined;\r\n            currentUrl = undefined;\r\n            first = undefined;\r\n        }\r\n\r\n        return page;\r\n    }\r\n\r\n    /** Starts a fetch request */\r\n    public async request(url: string): Promise<string> {\r\n        const headers = new Headers(getConfig(this.config, \"headers\"));\r\n        const timeout = window.setTimeout(() => {\r\n            window.clearTimeout(timeout);\r\n            throw \"Request Timed Out!\";\r\n        }, getConfig(this.config, \"timeout\"));\r\n\r\n        try {\r\n            let response = await fetch(url, {\r\n                mode: 'same-origin',\r\n                method: \"GET\",\r\n                headers,\r\n                cache: \"default\",\r\n                credentials: \"same-origin\",\r\n            });\r\n\r\n            window.clearTimeout(timeout);\r\n            if (response.status >= 200 && response.status < 300) {\r\n                return await response.text();\r\n            }\r\n\r\n            const err = new Error(response.statusText || \"\" + response.status);\r\n            throw err;\r\n        } catch (err) {\r\n            window.clearTimeout(timeout);\r\n            throw err;\r\n        }\r\n    }\r\n}\r\n", "import { Manager, methodCall } from \"@okikio/manager\";\r\n\r\n/**\r\n * Represents a listener callback function\r\n */\r\nexport type TypeListenerCallback = ((...args: any) => void);\r\n\r\n/** Represents a new event listener consisting of properties like: callback, scope, name */\r\nexport interface IListener {\r\n    readonly callback: TypeListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Creates a new listener based on {@link IListener | IListener}\r\n */\r\nexport const newListener = ({\r\n    callback = () => { },\r\n    scope = null,\r\n    name = \"event\",\r\n}: IListener): IListener => ({ callback, scope, name });\r\n\r\n/** Represents a new event  */\r\nexport class Event extends Manager<number, IListener> {\r\n    /** The name of the event */\r\n    public name: string;\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\n/**\r\n * The types of values `EventEmitter.prototype.on(...), EventEmitter.prototype.once(...), and EventEmitter.prototype.off(...)` accept\r\n */\r\nexport type TypeEventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An Event Emitter\r\n * */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /** Gets event, if event doesn't exist create a new one */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Creates a listener and adds it to an event */\r\n    public newListener(\r\n        name: string,\r\n        callback: TypeListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(newListener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n    /** Adds a listener to a given event */\r\n    public on(\r\n        events: TypeEventInput,\r\n        callback?: TypeListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: TypeListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as TypeListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            _name = isObject ? key : events[key];\r\n            if (isObject) _callback = events[key];\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Removes a listener from an event */\r\n    public removeListener(\r\n        name: string,\r\n        callback: TypeListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let listener = newListener({ name, callback, scope });\r\n\r\n            event.forEach((value: IListener, i: number) => {\r\n                if (\r\n                    value.callback === listener.callback &&\r\n                    value.scope === listener.scope\r\n                ) return event.remove(i);\r\n            });\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Remove a listener from a given event, or just completely remove an event */\r\n    public off(\r\n        events: TypeEventInput,\r\n        callback?: TypeListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: TypeListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as TypeListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            _name = isObject ? key : events[key];\r\n            if (isObject) _callback = events[key];\r\n\r\n            if (typeof _callback === \"function\") {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.remove(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a one time event listener for an event\r\n     */\r\n    public once(\r\n        events: TypeEventInput,\r\n        callback?: TypeListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            let _name: string = isObject ? key : events[key];\r\n            let _callback: TypeListenerCallback = isObject ? events[key] : (callback as TypeListenerCallback);\r\n            let _scope: object = isObject ? callback : scope;\r\n            let onceFn: TypeListenerCallback = (...args) => {\r\n                _callback.apply(_scope, args);\r\n                this.removeListener(_name, onceFn, _scope);\r\n            };\r\n\r\n            this.newListener(_name, onceFn, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Call all listeners within an event */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: IListener) => {\r\n                    let { callback, scope } = listener;\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Clears events and event listeners */\r\n    public clear() {\r\n        methodCall(this, \"clear\");\r\n        super.clear();\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default EventEmitter;\r\n", "/**\r\n * Convert the words \"from\", and \"to\" as well as percentage or numbers to offset value between 0 and 1\r\n */\r\nexport const parseOffset = (input: string | number): number => {\r\n    if (typeof input == \"string\") {\r\n        if (input.includes(\"%\"))\r\n            return parseFloat(input) / 100;\r\n        else if (input == \"from\")\r\n            return 0;\r\n        else if (input == \"to\")\r\n            return 1;\r\n        else\r\n            return parseFloat(input);\r\n    }\r\n\r\n    return input;\r\n};\r\n\r\n/**\r\n * Allows you to quickly convert CSS like JSON into keyframes\r\n *\r\n * @param input - CSS style JSON; check the example to understand what I mean\r\n *\r\n * @example\r\n * ```typescript\r\n * let keyframes = KeyframeParse({\r\n *     \"from, 50%, to\": {\r\n *         opacity: 1\r\n *     },\r\n *\r\n *     \"25%, 0.7\": {\r\n *         opacity: 0\r\n *     }\r\n * });\r\n *\r\n * console.log(keyframes);\r\n * //= [\r\n * //=   { opacity: 1, offset: 0 },\r\n * //=   { opacity: 0, offset: 0.25 },\r\n * //=   { opacity: 1, offset: 0.5 },\r\n * //=   { opacity: 0, offset: 0.7 },\r\n * //=   { opacity: 1, offset: 1 }\r\n * //= ]\r\n * ```\r\n */\r\nexport const KeyframeParse = (input: object): Keyframe[] => {\r\n    // Set removes duplicate Keyframes for the same offset\r\n    let results = new Set<Keyframe>();\r\n    let keys = Object.keys(input);\r\n    let len = keys.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let key = \"\" + keys[i];\r\n        let value = input[key];\r\n        let offsets = key.split(\",\");\r\n        let offsetLen = offsets.length;\r\n\r\n        for (let j = 0; j < offsetLen; j++) {\r\n            let offset = parseOffset(offsets[j]);\r\n            results.add({ ...value, offset });\r\n        }\r\n    }\r\n\r\n    return [...results].sort((a, b) => {\r\n        return a.offset - b.offset;\r\n    });\r\n};\r\n\r\n/**\r\n * I don't really want to put in the effort to create a complete list, so instead just look through the `animate.css` github and copy and paste the effects you need, into using a CSS Keyframe style JSON object, make sure to read the documentation for {@link KeyframeParse}\r\n *\r\n * or\r\n *\r\n * if you just need some quick effects go to [github.com/wellyshen/use-web-animations/](https://github.com/wellyshen/use-web-animations/tree/master/src/animations) and copy the `keyframes` array for the effect you want, remember to say thank you to @wellyshen for all his hardwork, \uD83D\uDE02\r\n *\r\n * @internal\r\n*/\r\nexport const EFFECTS = {};\r\n", "import { EventEmitter, TypeEventInput, TypeListenerCallback } from \"@okikio/emitter\";\r\nimport { Manager } from \"@okikio/manager\";\r\nimport { KeyframeParse, parseOffset } from \"./builtin-effects\";\r\n\r\n/* DOM */\r\nexport type TypeAnimationTarget = string | Node | NodeList | HTMLCollection | HTMLElement[] | TypeAnimationTarget[];\r\nexport const getElements = (selector: string | Node): Node[] => {\r\n    return typeof selector === \"string\" ? Array.from(document.querySelectorAll(selector as string)) : [selector];\r\n};\r\n\r\nexport const flatten = (arr: TypeAnimationTarget[]) => [].concat(...arr);\r\nexport const getTargets = (targets: TypeAnimationTarget): Node[] => {\r\n    if (Array.isArray(targets)) {\r\n        return flatten((targets as TypeAnimationTarget[]).map(getTargets));\r\n    }\r\n    if (typeof targets == \"string\" || targets instanceof Node)\r\n        return getElements(targets);\r\n    if (targets instanceof NodeList || targets instanceof HTMLCollection)\r\n        return Array.from(targets);\r\n    return [];\r\n};\r\n\r\n/* VALUES */\r\n// Types\r\nexport type TypeCallbackArgs = [number, number, HTMLElement];\r\nexport type TypeGeneric = boolean | object | string | number;\r\nexport type TypeCSSLikeKeyframe = { [key: string]: Keyframe & ICSSComputedTransformableProperties };\r\nexport type TypeKeyFrameOptionsType = TypeCSSLikeKeyframe | Keyframe[] | PropertyIndexedKeyframes;\r\nexport type TypeCSSPropertyValue = (string | number)[];\r\nexport type TypeComputedAnimationOptions = TypeGeneric | TypeGeneric[] | TypeKeyFrameOptionsType | KeyframeEffectOptions | ICSSComputedTransformableProperties;\r\nexport type TypeCallback = (index?: number, total?: number, element?: HTMLElement) => TypeComputedAnimationOptions;\r\nexport type TypeAnimationOptionTypes = TypeCallback | TypeComputedAnimationOptions;\r\nexport type TypeComputedOptions = { [key: string]: TypeComputedAnimationOptions };\r\n\r\n// Functions\r\nexport const computeOption = (value: TypeAnimationOptionTypes, args: TypeCallbackArgs, context: Animate): TypeComputedAnimationOptions => {\r\n    if (typeof value === \"function\") {\r\n        return value.apply(context, args);\r\n    } else return value;\r\n};\r\n\r\nexport const mapAnimationOptions = (obj: IAnimationOptions, args: TypeCallbackArgs, options: Animate) => {\r\n    let key: string, value: TypeAnimationOptionTypes, result: TypeComputedOptions = {};\r\n    let keys = Object.keys(obj);\r\n    for (let i = 0, len = keys.length; i < len; i++) {\r\n        key = keys[i];\r\n        value = obj[key];\r\n        result[key] = computeOption(value, args, options);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * From: [https://easings.net]\r\n *\r\n * Read More about easings on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/easing)\r\n *\r\n * ```ts\r\n * {\r\n *     \"in\": \"ease-in\",\r\n *     \"out\": \"ease-out\",\r\n *     \"in-out\": \"ease-in-out\",\r\n *\r\n *     // Sine\r\n *     \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n *     \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n *     \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n *\r\n *     // Quad\r\n *     \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n *     \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n *     \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n *\r\n *     // Cubic\r\n *     \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n *     \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n *     \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n *\r\n *     // Quart\r\n *     \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n *     \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n *     \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n *\r\n *     // Quint\r\n *     \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n *     \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n *     \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n *\r\n *     // Expo\r\n *     \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n *     \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n *     \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n *\r\n *     // Circ\r\n *     \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n *     \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n *     \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n *\r\n *     // Back\r\n *     \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n *     \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n *     \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n * }\r\n * ```\r\n */\r\nexport const EASINGS = {\r\n    \"in\": \"ease-in\",\r\n    \"out\": \"ease-out\",\r\n    \"in-out\": \"ease-in-out\",\r\n\r\n    // Sine\r\n    \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n    \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n    \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n\r\n    // Quad\r\n    \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n    \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n    \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n\r\n    // Cubic\r\n    \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n    \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n    \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n\r\n    // Quart\r\n    \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n    \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n    \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n\r\n    // Quint\r\n    \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n    \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n    \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n\r\n    // Expo\r\n    \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n    \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n    \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n\r\n    // Circ\r\n    \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n    \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n    \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n\r\n    // Back\r\n    \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n    \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n    \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n};\r\n\r\n/**\r\n * The keys of {@link EASINGS}\r\n *\r\n * @remark\r\n * \"in\", \"out\", \"in-out\", \"in-sine\", \"out-sine\", \"in-out-sine\", \"in-quad\", \"out-quad\", \"in-out-quad\", \"in-cubic\", \"out-cubic\", \"in-out-cubic\", \"in-quart\", \"out-quart\", \"in-out-quart\", \"in-quint\", \"out-quint\", \"in-out-quint\", \"in-expo\", \"out-expo\", \"in-out-expo\", \"in-circ\", \"out-circ\", \"in-out-circ\", \"in-back\", \"out-back\", \"in-out-back\"\r\n */\r\nexport const EasingKeys = Object.keys(EASINGS);\r\n\r\n/**\r\n * Converts users input into a usable easing function\r\n *\r\n * @param ease - easing functions; {@link EasingKeys}, cubic-bezier, steps, linear, etc...\r\n * @returns an easing function that `KeyframeEffect` can accept\r\n */\r\nexport const GetEase = (ease: keyof typeof EASINGS | string): string => {\r\n    let search = ease.replace(/^ease-/, \"\"); // Remove the \"ease-\" keyword\r\n    return EasingKeys.includes(search) ? EASINGS[search] : ease;\r\n};\r\n\r\nexport type TypeSingleValueCSSProperty = string | number | TypeCSSPropertyValue;\r\n\r\n/**\r\n * CSS properties the `ParseTransformableCSSProperties` can parse\r\n */\r\nexport interface ICSSTransformableProperties {\r\n    perspective?: TypeSingleValueCSSProperty | TypeCallback,\r\n    rotate?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty> | TypeCallback,\r\n    rotate3d?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty> | TypeCallback,\r\n    rotateX?: TypeSingleValueCSSProperty | TypeCallback,\r\n    rotateY?: TypeSingleValueCSSProperty | TypeCallback,\r\n    rotateZ?: TypeSingleValueCSSProperty | TypeCallback,\r\n    translate?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty> | TypeCallback,\r\n    translate3d?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty> | TypeCallback,\r\n    translateX?: TypeSingleValueCSSProperty | TypeCallback,\r\n    translateY?: TypeSingleValueCSSProperty | TypeCallback,\r\n    translateZ?: TypeSingleValueCSSProperty | TypeCallback,\r\n    scale?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty> | TypeCallback,\r\n    scale3d?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty> | TypeCallback,\r\n    scaleX?: TypeSingleValueCSSProperty | TypeCallback,\r\n    scaleY?: TypeSingleValueCSSProperty | TypeCallback,\r\n    scaleZ?: TypeSingleValueCSSProperty | TypeCallback,\r\n    skew?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty> | TypeCallback,\r\n    skewX?: TypeSingleValueCSSProperty | TypeCallback,\r\n    skewY?: TypeSingleValueCSSProperty | TypeCallback,\r\n    opacity?: TypeSingleValueCSSProperty | TypeCallback,\r\n}\r\n\r\n/**\r\n * Animation options control how an animation is produced, it shouldn't be too different for those who have used `animejs`, or `jquery`'s animate method.\r\n *\r\n * @remark\r\n * An animation option is an object with keys and values that are computed and passed to the `Animate` class to create animations that match the specified options.\r\n */\r\nexport interface IAnimationOptions extends ICSSTransformableProperties {\r\n    /**\r\n     * Determines the DOM elements to animate. You can pass it a CSS selector, DOM elements, or an Array of DOM Elements and/or CSS Selectors.\r\n     */\r\n    target?: TypeAnimationTarget,\r\n\r\n    /**\r\n     * Alias of `target`\r\n     * {@link AnimationOptions.target | target }\r\n     */\r\n    targets?: TypeAnimationTarget,\r\n\r\n    /**\r\n     * Determines the acceleration curve of your animation. Based on the easings of [easings.net](https://easings.net)\r\n     *\r\n     * Read More about easings on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/easing)\r\n     *\r\n     *\r\n     * | constant | accelerate | decelerate | accelerate-decelerate |\r\n     * | :------- | :--------- | :--------- | :-------------------- |\r\n     * | linear   | in-cubic   | out-cubic  | in-out-cubic          |\r\n     * | ease     | in-quart   | out-quart  | in-out-quart          |\r\n     * |          | in-quint   | out-quint  | in-out-quint          |\r\n     * |          | in-expo    | out-expo   | in-out-expo           |\r\n     * |          | in-circ    | out-circ   | in-out-circ           |\r\n     * |          | in-back    | out-back   | in-out-back           |\r\n     *\r\n     * You can create your own custom cubic-bezier easing curves. Similar to css you type `cubic-bezier(...)` with 4 numbers representing the shape of the bezier curve, for example, `cubic-bezier(0.47, 0, 0.745, 0.715)` this is the bezier curve for `in-sine`.\r\n     *\r\n     * *Note: the `easing` property supports the original values and functions for easing as well, for example, `steps(1)`, and etc... are supported.*\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * // cubic-bezier easing\r\n     * animate({\r\n     *     target: \".div\",\r\n     *     easing: \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n     *\r\n     *     // or\r\n     *     easing: \"in-sine\",\r\n     *     transform: [\"translate(0px)\", \"translate(500px)\"],\r\n     * });\r\n     * ```\r\n     */\r\n    easing?: keyof typeof EASINGS | TypeCallback | string | string[],\r\n\r\n    /**\r\n     * Determines the duration of your animation in milliseconds. By passing it a callback, you can define a different duration for each element. The callback takes the index of each element, the target dom element, and the total number of target elements as its argument and returns a number.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * // First element fades out in 1s, second element in 2s, etc.\r\n     * animate({\r\n     *      target: \".div\",\r\n     *      easing: \"linear\",\r\n     *      duration: 1000,\r\n     *      // or\r\n     *      duration: (index) => (index + 1) * 1000,\r\n     *      opacity: [1, 0],\r\n     * });\r\n     * ```\r\n     */\r\n    duration?: number | string | TypeCallback,\r\n\r\n    /**\r\n     * Determines the delay of your animation in milliseconds. By passing it a callback, you can define a different delay for each element. The callback takes the index of each element, the target dom element, and the total number of target elements as its argument and returns a number.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * // First element starts fading out after 1s, second element after 2s, etc.\r\n     * animate({\r\n     *     target: \".div\",\r\n     *     easing: \"linear\",\r\n     *     delay: 5,\r\n     *     // or\r\n     *     delay: (index) => (index + 1) * 1000,\r\n     *     opacity: [1, 0],\r\n     * });\r\n     * ```\r\n     */\r\n    delay?: number | TypeCallback,\r\n\r\n    /**\r\n     * Adds an offset ammount to the `delay`, for creating a timeline similar to `animejs`\r\n     */\r\n    timelineOffset?: number | TypeCallback,\r\n\r\n    /**\r\n     * Similar to delay but it indicates the number of milliseconds to delay **after** the full animation has played **not before**.\r\n     *\r\n     * _**Note**: `endDelay` will delay the `onfinish` method and event, but will not reserve the current state of the CSS animation, if you need to use endDelay you may need to use the `fillMode` property to reserve the changes to the animation target._\r\n\r\n     * @example\r\n     * ```ts\r\n     * // First element fades out but then after 1s finishes, the second element after 2s, etc.\r\n     * animate({\r\n     *     target: \".div\",\r\n     *     easing: \"linear\",\r\n     *     endDelay: 1000,\r\n     *     // or\r\n     *     endDelay: (index) => (index + 1) * 1000,\r\n     *     opacity: [1, 0],\r\n     * });\r\n     * ```\r\n     */\r\n    endDelay?: number | TypeCallback,\r\n\r\n    /**\r\n     *\r\n     * This ensures all `animations` match up to the total duration, and don't finish too early, if animations finish too early when the `.play()` method is called specific animations  that are finished will restart while the rest of the animations will continue playing.\r\n     *\r\n     * _**Note**: you cannot use the `padEndDelay` option and set a value for `endDelay`, the `endDelay` value will replace the padded endDelay_\r\n     */\r\n    padEndDelay?: Boolean,\r\n\r\n    /**\r\n     * Determines if the animation should repeat, and how many times it should repeat.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * // Loop forever\r\n     * animate({\r\n     *     target: \".div\",\r\n     *     easing: \"linear\",\r\n     *     loop: true, // If you want it to continously loop\r\n     *     // or\r\n     *     // loop: 5, // If you want the animation to loop 5 times\r\n     *     opacity: [1, 0],\r\n     * });\r\n     * ```\r\n     */\r\n    loop?: number | boolean | TypeCallback,\r\n\r\n    /**\r\n     * Occurs when the animation for one of the targets completes, meaning when animating many targets that finish at different times this will run multiple times. The arguments it takes is slightly different from the rest of the animation options.\r\n     *\r\n     * The animation argument represents the animation for the current target.\r\n     *\r\n     * @param element - the current target element\r\n     * @param index - the index of the current target element in `Animate.prototype.targets`\r\n     * @param total -  the total number of target elements\r\n     * @param animation - the animation of the current target element\r\n     *\r\n     * **Warning**: the order of the callback's arguments are in a different order, with the target element first, and the index second.\r\n     */\r\n    onfinish?: (element?: HTMLElement, index?: number, total?: number, animation?: Animation) => void,\r\n\r\n    /**\r\n     * Occurs when the animation for one of the targets is cancelled, meaning when animating many targets that are cancelled at different times this will run multiple times. The arguments it takes is slightly different from the rest of the animation options.\r\n     *\r\n     * The animation argument represents the animation for the current target.\r\n     *\r\n     * @param element - the current target element\r\n     * @param index - the index of the current target element in `Animate.prototype.targets`\r\n     * @param total - the total number of target elements\r\n     * @param animation - the animation of the current target element\r\n     *\r\n     *\r\n     * **Warning**: the order of the callback's arguments are in a different order, with the target element first, and the index second.\r\n     */\r\n    oncancel?: (element?: HTMLElement, index?: number, total?: number, animation?: Animation) => void,\r\n\r\n    /**\r\n     *\r\n     * Determines if the animation should automatically play immediately after being instantiated.\r\n     */\r\n    autoplay?: boolean,\r\n\r\n    /**\r\n     * Determines the direction of the animation;\r\n     * - `reverse` runs the animation backwards,\r\n     * - `alternate` switches direction after each iteration if the animation loops.\r\n     * - `alternate-reverse` starts the animation at what would be the end of the animation if the direction were\r\n     * - `normal` but then when the animation reaches the beginning of the animation it alternates going back to the position it started at.\r\n     */\r\n    direction?: PlaybackDirection,\r\n\r\n    /**\r\n     * Determines the animation playback rate. Useful in the authoring process to speed up some parts of a long sequence (value above 1) or slow down a specific animation to observe it (value between 0 to 1).\r\n     *\r\n     * _**Note**: negative numbers reverse the animation._\r\n     */\r\n    speed?: number | TypeCallback,\r\n\r\n    /**\r\n     * Defines how an element should look after the animation.\r\n     *\r\n     * @remark\r\n     * fillMode of:\r\n     * - `none` means the animation's effects are only visible while the animation is playing.\r\n     * - `forwards` the affected element will continue to be rendered in the state of the final animation frame.\r\n     * - `backwards` the animation's effects should be reflected by the element(s) state prior to playing.\r\n     * - `both` combining the effects of both forwards and backwards; The animation's effects should be reflected by the element(s) state prior to playing and retained after the animation has completed playing.\r\n     * - `auto` if the animation effect fill mode is being applied to is a keyframe effect. \"auto\" is equivalent to \"none\". Otherwise, the result is \"both\".\r\n     *\r\n     * You can learn more here on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/fill).\r\n\r\n     * _Be careful when using fillMode, it has some problems when it comes to concurrency of animations read more on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/fill), if browser support were better I would remove fillMode and use Animation.commitStyles, I'll have to change the way `fillMode` functions later. Use the onfinish method to commit styles [onfinish](#onfinish)._\r\n     */\r\n    fillMode?: FillMode,\r\n\r\n    /**\r\n     * Another way to input options for an animation, it's also used to chain animations.\r\n     *\r\n     * @remarks\r\n     * The `options` animation option is another way to declare options, it can take an instance of `Animate`, a single `Animate` instance in an Array, e.g. `[Animate]` or an object containing animation options.\r\n     *\r\n     *\r\n     * `options` extends the animation properties of an animation, but more importance is given to the actual animation options object, so, the properties from `options` will be ignored if there is already an animation option with the same name declared.\r\n     *\r\n     *\r\n     * _**Note**: you can't use this property as a method._\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * (async () => {\r\n     *     // animate is Promise-like, as in it has a then() method like a Promise but it isn't a Promise.\r\n     *     // animate resolves to an Array that contains the Animate instance, e.g. [Animate]\r\n     *     let [options] = await animate({\r\n     *         target: \".div\",\r\n     *         opacity: [0, 1],\r\n     *     });\r\n     *\r\n     *     animate({\r\n     *         options,\r\n     *\r\n     *         // opacity overrides the opacity property from `options`\r\n     *         opacity: [1, 0],\r\n     *     });\r\n     *\r\n     *     console.log(options); //= Animate\r\n     * })();\r\n     *\r\n     * // or\r\n     * (async () => {\r\n     *     let options = await animate({\r\n     *         target: \".div\",\r\n     *         opacity: [0, 1],\r\n     *         duration: 2000,\r\n     *\r\n     *     });\r\n     *\r\n     *     // Remeber, the `options` animation option can handle Arrays with an Animate instance, e.g. [Animate]\r\n     *     // Also, remeber that Animate resolves to an Arrays with an Animate instance, e.g. [Animate]\r\n     *     // Note: the `options` animation option can only handle one Animate instance in an Array and that is alway the first element in the Array\r\n     *     animate({\r\n     *         options,\r\n     *         opacity: [1, 0],\r\n     *     });\r\n     *\r\n     *     console.log(options); //= [Animate]\r\n     * })();\r\n     *\r\n     * // or\r\n     * (async () => {\r\n     *     let options = {\r\n     *         target: \".div\",\r\n     *         opacity: [0, 1],\r\n     *     };\r\n     *\r\n     *     await animate(options);\r\n     *     animate({\r\n     *         options,\r\n     *         opacity: [1, 0],\r\n     *     });\r\n     *\r\n     *     console.log(options); //= { ... }\r\n     * })();\r\n     * ```\r\n     */\r\n    options?: IAnimationOptions,\r\n\r\n    /**\r\n     * Contols the starting point of certain parts of an animation\r\n     *\r\n     * @remark\r\n     * The offset of the keyframe specified as a number between `0.0` and `1.0` inclusive or null. This is equivalent to specifying start and end states in percentages in CSS stylesheets using @keyframes. If this value is null or missing, the keyframe will be evenly spaced between adjacent keyframes.\r\n     *\r\n     * Read more on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Keyframe_Formats)\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * animate({\r\n     *      duration: 2000,\r\n     *      opacity: [ 0, 0.9, 1 ],\r\n     *      easing: [ 'ease-in', 'ease-out' ],\r\n     *\r\n     *      offset: [ \"from\", 0.8 ], // Shorthand for [ 0, 0.8, 1 ]\r\n     *      // or\r\n     *      offset: [ 0, \"80%\", \"to\" ], // Shorthand for [ 0, 0.8, 1 ]\r\n     *      // or\r\n     *      offset: [ \"0\", \"0.8\", \"to\" ], // Shorthand for [ 0, 0.8, 1 ]\r\n     * });\r\n     * ```\r\n     */\r\n    offset?: (number | string)[] | TypeCallback,\r\n\r\n    /**\r\n     * Represents the timeline of animation. It exists to pass timeline features to Animations (default is [DocumentTimeline](https://developer.mozilla.org/en-US/docs/Web/API/DocumentTimeline)).\r\n     *\r\n     * As of right now it doesn't contain any features but in the future when other timelines like the [ScrollTimeline](https://drafts.csswg.org/scroll-animations-1/#scrolltimeline), read the Google Developer article for [examples and demos of ScrollTimeLine](https://developers.google.com/web/updates/2018/10/animation-worklet#hooking_into_the_space-time_continuum_scrolltimeline)\r\n     */\r\n    timeline?: AnimationTimeline,\r\n\r\n    /**\r\n     * Allows you to manually set keyframes using a `keyframe` array\r\n     *\r\n     * Read more on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/setKeyframes)\r\n     *\r\n     * @remark\r\n     * An `array` of objects (keyframes) consisting of properties and values to iterate over. This is the canonical format returned by the [getKeyframes()](https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/getKeyframes) method.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * element.animate([\r\n     *   { // from\r\n     *     opacity: 0,\r\n     *     color: \"#fff\"\r\n     *   },\r\n     *   { // to\r\n     *     opacity: 1,\r\n     *     color: \"#000\"\r\n     *   }\r\n     * ], 2000);\r\n     * ```\r\n     *\r\n     * Offsets for each keyframe can be specified by providing an `offset` value.\r\n\r\n     * @example\r\n     * ```ts\r\n     * element.animate([ { opacity: 1 },\r\n     *                   { opacity: 0.1, offset: 0.7 },\r\n     *                   { opacity: 0 } ],\r\n     *                 2000);\r\n     * ```\r\n     *\r\n     * _**Note**: `offset` values, if provided, must be between 0.0 and 1.0 (inclusive) and arranged in ascending order._\r\n     *\r\n     * It is not necessary to specify an offset for every keyframe. Keyframes without a specified offset will be evenly spaced between adjacent keyframes.\r\n     *\r\n     * ---\r\n     *\r\n     * The easing to apply between keyframes can be specified by providing an easing `value` as illustrated below.\r\n     *\r\n     * _**Note**: the values for easing in keyframes are limited to \"ease\", \"ease-in\", \"ease-out\", \"ease-in-out\", \"linear\", \"steps(...)\", and \"cubic-bezier(...)\", to get access to the predefined {@link EASINGS | easings}, you will need to use the function {@link GetEase}._\r\n\r\n     * @example\r\n     * ```ts\r\n     * element.animate([ { opacity: 1, easing: 'ease-out' },\r\n     *                   { opacity: 0.1, easing: 'ease-in' },\r\n     *                   { opacity: 0 } ],\r\n     *                 2000);\r\n     * ```\r\n     *\r\n     * In this example, the specified easing only applies from the keyframe where it is specified until the next keyframe. Any easing value specified on the options argument, however, applies across a single iteration of the animation \u2014 for the entire duration.\r\n     *\r\n     *\r\n     * `@okikio/animate` also offers another format called `CSSLikeKeyframe`,\r\n     * it basically functions the same way CSS `@keyframe` functions\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * animate({\r\n     *      keyframes: {\r\n     *          \"from, 50%, to\": {\r\n     *              opacity: 1\r\n     *          },\r\n     *\r\n     *          \"25%, 0.7\": {\r\n     *              opacity: 0\r\n     *          }\r\n     *      }\r\n     * })\r\n     * // Results in a keyframe array like this\r\n     * //= [\r\n     * //=   { opacity: 1, offset: 0 },\r\n     * //=   { opacity: 0, offset: 0.25 },\r\n     * //=   { opacity: 1, offset: 0.5 },\r\n     * //=   { opacity: 0, offset: 0.7 },\r\n     * //=   { opacity: 1, offset: 1 }\r\n     * //= ]\r\n     * ```\r\n     */\r\n    keyframes?: TypeCSSLikeKeyframe | ICSSComputedTransformableProperties[] & Keyframe[] | object[] | TypeCallback,\r\n\r\n    /**\r\n     * The properties of the `extend` animation option are not interperted or computed, they are given directly to the `Web Animation API`, as way to access features that haven't been implemented in `@okikio/animate`, for example, `iterationStart`.\r\n     *\r\n     * `extend` is supposed to future proof the library if new features are added to the `Web Animation API` that you want to use, but that has not been implemented yet.\r\n     *\r\n     * _**Note**: it doesn't allow for declaring actual animation keyframes; it's just for animation timing options, and it overrides all other animation timing options that accomplish the same goal, e.g. `loop` & `iterations`, if `iterations` is a property of `extend` then `iterations` will override `loop`._\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * animate({\r\n     *     target: \".div\",\r\n     *     opacity: [0, 1],\r\n     *     loop: 5,\r\n     *     extend: {\r\n     *         iterationStart: 0.5,\r\n     *         // etc...\r\n     *         fill: \"both\", // This overrides fillMode\r\n     *         iteration: 2, // This overrides loop\r\n     *         composite: \"add\"\r\n     *     }\r\n     * });\r\n     * ```\r\n     */\r\n    extend?: KeyframeEffectOptions | TypeCallback,\r\n\r\n    /**\r\n     * Theses are the CSS properties to be animated as Keyframes\r\n     *\r\n     * Read more on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/setKeyframes)\r\n     *\r\n     * @remark\r\n     * An `object` containing key-value pairs consisting of the property to animate and an `array` of values to iterate over.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * element.animate({\r\n     *   opacity: [ 0, 1 ],          // [ from, to ]\r\n     *   color:   [ \"#fff\", \"#000\" ] // [ from, to ]\r\n     * }, 2000);\r\n     * ```\r\n     *\r\n     * Using this format, the number of elements in each array does not need to be equal. The provided values will be spaced out independently.\r\n\r\n     * @example\r\n     * ```ts\r\n     * element.animate({\r\n     *   opacity: [ 0, 1 ], // offset: 0, 1\r\n     *   backgroundColor: [ \"red\", \"yellow\", \"green\" ], // offset: 0, 0.5, 1\r\n     * }, 2000);\r\n     * ```\r\n     *\r\n     * The special keys `offset`, `easing`, and `composite` (described below) may be specified alongside the property values.\r\n\r\n     * @example\r\n     * ```ts\r\n     * element.animate({\r\n     *   opacity: [ 0, 0.9, 1 ],\r\n     *   offset: [ 0, 0.8 ], // Shorthand for [ 0, 0.8, 1 ]\r\n     *   easing: [ 'ease-in', 'ease-out' ],\r\n     * }, 2000);\r\n     * ```\r\n     *\r\n     * After generating a suitable set of keyframes from the property value lists, each supplied offset is applied to the corresponding keyframe. If there are insufficient values, or if the list contains `null` values, the keyframes without specified offsets will be evenly spaced as with the array format described above.\r\n     *\r\n     * If there are too few `easing` or `composite` values, the corresponding list will be repeated as needed.\r\n     *\r\n     * _**Note**: to use `composite` you will need to add it to the {@link AnimationOptions.extend | extend} object as an option_\r\n     */\r\n    [property: string]: TypeAnimationOptionTypes,\r\n};\r\n\r\n/**\r\n * CSS properties\r\n */\r\nexport interface ICSSProperties {\r\n    [key: string]: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty>\r\n};\r\n\r\n/**\r\n * After being computed as an animation option\r\n */\r\nexport interface ICSSComputedTransformableProperties extends ICSSProperties {\r\n    perspective?: TypeSingleValueCSSProperty,\r\n    rotate?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty>,\r\n    rotate3d?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty>,\r\n    rotateX?: TypeSingleValueCSSProperty,\r\n    rotateY?: TypeSingleValueCSSProperty,\r\n    rotateZ?: TypeSingleValueCSSProperty,\r\n    translate?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty>,\r\n    translate3d?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty>,\r\n    translateX?: TypeSingleValueCSSProperty,\r\n    translateY?: TypeSingleValueCSSProperty,\r\n    translateZ?: TypeSingleValueCSSProperty,\r\n    scale?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty>,\r\n    scale3d?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty>,\r\n    scaleX?: TypeSingleValueCSSProperty,\r\n    scaleY?: TypeSingleValueCSSProperty,\r\n    scaleZ?: TypeSingleValueCSSProperty,\r\n    skew?: TypeSingleValueCSSProperty | Array<TypeSingleValueCSSProperty>,\r\n    skewX?: TypeSingleValueCSSProperty,\r\n    skewY?: TypeSingleValueCSSProperty,\r\n}\r\n\r\n/**\r\n * The default options for every Animate instance\r\n *\r\n * ```ts\r\n * {\r\n *   keyframes: [],\r\n *\r\n *   loop: 1,\r\n *   delay: 0,\r\n *   speed: 1,\r\n *   endDelay: 0,\r\n *   easing: \"ease\",\r\n *   autoplay: true,\r\n *   duration: 1000,\r\n *   fillMode: \"none\",\r\n *   direction: \"normal\",\r\n *   padEndDelay: false,\r\n *   extend: {}\r\n * }\r\n * ```\r\n */\r\nexport const DefaultAnimationOptions: IAnimationOptions = {\r\n    keyframes: [],\r\n    offset: [],\r\n\r\n    loop: 1,\r\n    delay: 0,\r\n    speed: 1,\r\n    endDelay: 0,\r\n    easing: \"ease\",\r\n    timelineOffset: 0,\r\n    autoplay: true,\r\n    duration: 1000,\r\n    fillMode: \"none\",\r\n    direction: \"normal\",\r\n    padEndDelay: false,\r\n    extend: {}\r\n};\r\n\r\nexport type TypeAnimationEvents = \"update\" | \"play\" | \"pause\" | \"begin\" | \"cancel\" | \"finish\" | \"error\" | \"stop\" | \"playstate-change\";\r\nexport type TypePlayStates = \"idle\" | \"running\" | \"paused\" | \"finished\";\r\n\r\nexport const parseOptions = (options: IAnimationOptions): IAnimationOptions => {\r\n    let { options: animation, ...rest } = options;\r\n    let oldOptions = animation instanceof Animate ? animation.getOptions() : (Array.isArray(animation) ? animation?.[0]?.getOptions() : animation);\r\n    return Object.assign({}, oldOptions, rest);\r\n}\r\n\r\n/**\r\n * Returns a closure Function, which adds a unit to numbers but simply returns strings with no edits assuming the value has a unit if it's a string\r\n *\r\n * @param unit - the default unit to give the CSS Value\r\n * @returns\r\n * if value already has a unit (we assume the value has a unit if it's a string), we return it;\r\n * else return the value plus the default unit\r\n */\r\nexport const addCSSUnit = (unit: string = \"\") => {\r\n    return (value: string | number) => typeof value == \"string\" ? value : `${value}${unit}`;\r\n}\r\n\r\n/** Function doesn't add any units by default */\r\nexport const UnitLess = addCSSUnit();\r\n\r\n/** Function adds \"px\" unit to numbers */\r\nexport const UnitPX = addCSSUnit(\"px\");\r\n\r\n/** Function adds \"deg\" unit to numbers */\r\nexport const UnitDEG = addCSSUnit(\"deg\");\r\n\r\n/**\r\n * Convert the input to an array\r\n * For strings split them at commas\r\n * For array do nothing\r\n * For everything else wrap the input in an array\r\n */\r\nexport const toArr = (input: any): any[] => {\r\n    if (Array.isArray(input) || typeof input == \"string\") {\r\n        if (typeof input == \"string\") input = input.split(\",\");\r\n        return input;\r\n    }\r\n\r\n    return [input];\r\n}\r\n\r\n/**\r\n * Checks if value is valid/truthy; it counts empty arrays and strings as falsey,\r\n * as well as null and undefined everything else is valid\r\n *\r\n * _**Note:** 0 counts as valid_\r\n *\r\n * @param value - anything\r\n * @returns true or false\r\n */\r\nexport const isValid = (value: any) => {\r\n    if (Array.isArray(value) || typeof value == \"string\")\r\n        return Boolean(value.length);\r\n    return value != null && value != undefined;\r\n}\r\n\r\n/**\r\n * Returns a closure function, which adds units to numbers, strings or arrays of both\r\n *\r\n * @param unit - a unit function to use to add units to {@link TypeSingleValueCSSProperty | TypeSingleValueCSSProperty's }\r\n * @returns\r\n * if input is a string split it into an array at the comma's, and add units\r\n * else if the input is a number add the default units\r\n * otherwise if the input is an array of both add units according to {@link addCSSUnit}\r\n */\r\nexport const CSSValue = (unit: typeof UnitLess) => {\r\n    return (input: TypeSingleValueCSSProperty) => {\r\n        return isValid(input) ? toArr(input).map(val => {\r\n            if (typeof val != \"number\" && typeof val != \"string\")\r\n                return val;\r\n\r\n            // Basically if you can convert it to a number try to,\r\n            // otherwise just return whatever you can\r\n            let num = Number(val);\r\n            let value = Number.isNaN(num) ? (typeof val == \"string\" ? val.trim() : val) : num;\r\n            return unit(value); // Add the default units\r\n        }) : [];\r\n    };\r\n}\r\n\r\n/**\r\n * Flips the rows and columns of 2-dimensional arrays\r\n *\r\n * Read more on [underscorejs.org](https://underscorejs.org/#zip) & [lodash.com](https://lodash.com/docs/4.17.15#zip)\r\n *\r\n * @example\r\n * ```ts\r\n * transpose(\r\n *      ['moe', 'larry', 'curly'],\r\n *      [30, 40, 50],\r\n *      [true, false, false]\r\n * );\r\n * // [\r\n * //     [\"moe\", 30, true],\r\n * //     [\"larry\", 40, false],\r\n * //     [\"curly\", 50, false]\r\n * // ]\r\n * ```\r\n * @param [...args] - the arrays to process as a set of arguments\r\n * @returns\r\n * returns the new array of grouped elements\r\n */\r\nexport const transpose = (...args: TypeSingleValueCSSProperty[] | TypeSingleValueCSSProperty[][]) => {\r\n    let largestArrLen = 0;\r\n    args = args.map(arr => {\r\n        // Convert all values in arrays to an array\r\n        // This ensures that `arrays` is an array of arrays\r\n        let result = toArr(arr);\r\n\r\n        // Finds the largest array\r\n        let len = result.length;\r\n        if (len > largestArrLen) largestArrLen = len;\r\n        return result;\r\n    });\r\n\r\n    // Flip the rows and columns of arrays\r\n    let result = [];\r\n    let len = args.length;\r\n    for (let col = 0; col < largestArrLen; col++) {\r\n        result[col] = [];\r\n\r\n        for (let row = 0; row < len; row++) {\r\n            let val = args[row][col];\r\n            if (isValid(val))\r\n                result[col][row] = val;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Takes `TypeSingleValueCSSProperty` or an array of `TypeSingleValueCSSProperty` and adds units approriately\r\n *\r\n * @param arr - array of numbers, strings and/or an array of array of both e.g. ```[[25, \"50px\", \"60%\"], \"25, 35, 60%\", 50]```\r\n * @param unit - a unit function to use to add units to {@link TypeSingleValueCSSProperty | TypeSingleValueCSSProperty's }\r\n * @returns\r\n * an array of an array of strings with units\r\n * e.g.\r\n * ```ts\r\n * [\r\n *      [ '25px', '35px', ' 60%' ],\r\n *      [ '50px', '60px', '70px' ]\r\n * ]\r\n * ```\r\n */\r\nexport const CSSArrValue = (arr: TypeSingleValueCSSProperty | TypeSingleValueCSSProperty[], unit: typeof UnitLess) => {\r\n    // This is for the full varients of the transform function as well as the 3d varients\r\n    // zipping the `CSSValue` means if a user enters a string, it will treat each value (seperated by a comma) in that\r\n    // string as a seperate transition state\r\n    return toArr(arr).map(CSSValue(unit)) as TypeSingleValueCSSProperty[];\r\n}\r\n\r\nexport const TransformFunctionNames = [\r\n    \"translate\",\r\n    \"translate3d\",\r\n    \"translateX\",\r\n    \"translateY\",\r\n    \"translateZ\",\r\n    \"rotate\",\r\n    \"rotate3d\",\r\n    \"rotateX\",\r\n    \"rotateY\",\r\n    \"rotateZ\",\r\n    \"scale\",\r\n    \"scale3d\",\r\n    \"scaleX\",\r\n    \"scaleY\",\r\n    \"scaleZ\",\r\n    \"skew\",\r\n    \"skewX\",\r\n    \"skewY\",\r\n    \"perspective\"\r\n];\r\n\r\n/**\r\n * Creates the transform property text\r\n */\r\nexport const createTransformProperty = (arr) => {\r\n    let result = \"\";\r\n    let len = TransformFunctionNames.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let name = TransformFunctionNames[i];\r\n        let value = arr[i];\r\n        if (isValid(value))\r\n            result += `${name}(${Array.isArray(value) ? value.join(\", \") : value}) `;\r\n    }\r\n\r\n    return result.trim();\r\n}\r\n\r\n/** Parses CSSValues without adding any units */\r\nexport const UnitLessCSSValue = CSSValue(UnitLess);\r\n\r\n/** Parses CSSValues and adds the \"px\" unit if required */\r\nexport const UnitPXCSSValue = CSSValue(UnitPX);\r\n\r\n/** Parses CSSValues and adds the \"deg\" unit if required */\r\nexport const UnitDEGCSSValue = CSSValue(UnitDEG);\r\n\r\n/**\r\n * Wrap non array CSS property values in an array\r\n */\r\nexport const CSSPropertiesToArr = (properties: ICSSProperties) => {\r\n    for (let [key, value] of Object.entries(properties)) {\r\n        // Wrap non array values in arrays\r\n        properties[key] = [].concat(value).map(value => `` + value);\r\n    }\r\n\r\n    return properties;\r\n};\r\n\r\n/**\r\n * Removes the need for the full transform statement in order to use translate, rotate, scale, skew, or perspective including their X, Y, Z, and 3d varients\r\n * Also, adds the ability to use single string or number values for transform functions\r\n *\r\n * _**Note**: the `transform` animation option will override all transform function properties_\r\n *\r\n * @param properties - the CSS properties to transform\r\n *\r\n * @example\r\n * ```ts\r\n * ParseTransformableCSSProperties({\r\n *      // It will automatically add the \"px\" units for you, or you can write a string with the units you want\r\n *      translate3d: [\r\n *          \"25, 35, 60%\",\r\n *          [50, \"60px\", 70],\r\n *          [\"70\", 50]\r\n *      ],\r\n *      translate: \"25, 35, 60%\",\r\n *      translateX: [50, \"60px\", \"70\"],\r\n *      translateY: [\"50, 60\", \"60\"], // Note: this will actually result in an error, make sure to pay attention to where you are putting strings and commas\r\n *      translateZ: 0,\r\n *      perspective: 0,\r\n *      opacity: \"0, 5\",\r\n *      scale: [\r\n *          [1, \"2\"],\r\n *          [\"2\", 1]\r\n *      ],\r\n *      rotate3d: [\r\n *          [1, 2, 5, \"3deg\"], // The last value in the array must be a string with units for rotate3d\r\n *          [2, \"4\", 6, \"45turn\"],\r\n *          [\"2\", \"4\", \"6\", \"-1rad\"]\r\n *      ]\r\n * })\r\n *\r\n * //= {\r\n * //=   transform: [\r\n * //=       // `translateY(50, 60)` will actually result in an error\r\n * //=       'translate(25px) translate3d(25px, 35px, 60%) translateX(50px) translateY(50, 60) translateZ(0px) rotate3d(1, 2, 5, 3deg) scale(1, 2) perspective(0px)',\r\n * //=       'translate(35px) translate3d(50px, 60px, 70px) translateX(60px) translateY(60px) rotate3d(2, 4, 6, 45turn) scale(2, 1)',\r\n * //=       'translate(60%) translate3d(70px, 50px) translateX(70px) rotate3d(2, 4, 6, -1rad)'\r\n * //=   ],\r\n * //=   opacity: [ '0', '5' ]\r\n * //= }\r\n * ```\r\n *\r\n * @returns\r\n * an object with a properly formatted `transform` and `opactity`, as well as other unformatted CSS properties\r\n * ```\r\n */\r\nexport const ParseTransformableCSSProperties = (properties: ICSSComputedTransformableProperties) => {\r\n    let {\r\n        perspective,\r\n        rotate,\r\n        rotate3d,\r\n        rotateX,\r\n        rotateY,\r\n        rotateZ,\r\n        translate,\r\n        translate3d,\r\n        translateX,\r\n        translateY,\r\n        translateZ,\r\n        scale,\r\n        scale3d,\r\n        scaleX,\r\n        scaleY,\r\n        scaleZ,\r\n        skew,\r\n        skewX,\r\n        skewY,\r\n        ...rest\r\n    } = properties;\r\n\r\n    translate = CSSArrValue(translate, UnitPX);\r\n    translate3d = CSSArrValue(translate3d, UnitPX);\r\n    translateX = UnitPXCSSValue(translateX);\r\n    translateY = UnitPXCSSValue(translateY);\r\n    translateZ = UnitPXCSSValue(translateZ);\r\n\r\n    rotate = CSSArrValue(rotate, UnitDEG);\r\n    rotate3d = CSSArrValue(rotate3d, UnitLess);\r\n    rotateX = UnitDEGCSSValue(rotateX);\r\n    rotateY = UnitDEGCSSValue(rotateY);\r\n    rotateZ = UnitDEGCSSValue(rotateZ);\r\n\r\n    scale = CSSArrValue(scale, UnitLess);\r\n    scale3d = CSSArrValue(scale3d, UnitLess);\r\n    scaleX = UnitLessCSSValue(scaleX);\r\n    scaleY = UnitLessCSSValue(scaleY);\r\n    scaleZ = UnitLessCSSValue(scaleZ);\r\n\r\n    skew = CSSArrValue(skew, UnitDEG);\r\n    skewX = UnitDEGCSSValue(skewX);\r\n    skewY = UnitDEGCSSValue(skewY);\r\n\r\n    perspective = UnitPXCSSValue(perspective);\r\n\r\n    let transform = transpose(\r\n        translate, translate3d, translateX, translateY, translateZ,\r\n        rotate, rotate3d, rotateX, rotateY, rotateZ,\r\n        scale, scale3d, scaleX, scaleY, scaleZ,\r\n        skew, skewX, skewY,\r\n        perspective\r\n    ).map(createTransformProperty);\r\n\r\n    rest = CSSPropertiesToArr(rest);\r\n    return Object.assign({},\r\n        isValid(transform) ? { transform } : null,\r\n        rest);\r\n}\r\n\r\n/**\r\n * Similar to {@link ParseTransformableCSSProperties} except it transforms the CSS properties in each Keyframe\r\n * @param keyframes - an array of keyframes with transformable CSS properties\r\n * @returns\r\n * an array of keyframes, with transformed CSS properties\r\n */\r\nexport const ParseTransformableCSSKeyframes = (keyframes: ICSSComputedTransformableProperties[]) => {\r\n    return keyframes.map(properties => {\r\n        let {\r\n            translate,\r\n            translate3d,\r\n            translateX,\r\n            translateY,\r\n            translateZ,\r\n            rotate,\r\n            rotate3d,\r\n            rotateX,\r\n            rotateY,\r\n            rotateZ,\r\n            scale,\r\n            scale3d,\r\n            scaleX,\r\n            scaleY,\r\n            scaleZ,\r\n            skew,\r\n            skewX,\r\n            skewY,\r\n            perspective,\r\n            ...rest\r\n        } = properties;\r\n\r\n        translate = UnitPXCSSValue(translate as TypeSingleValueCSSProperty);\r\n        translate3d = UnitPXCSSValue(translate3d as TypeSingleValueCSSProperty);\r\n        translateX = UnitPXCSSValue(translateX)[0];\r\n        translateY = UnitPXCSSValue(translateY)[0];\r\n        translateZ = UnitPXCSSValue(translateZ)[0];\r\n\r\n        rotate = UnitDEGCSSValue(rotate as TypeSingleValueCSSProperty);\r\n        rotate3d = UnitLessCSSValue(rotate3d as TypeSingleValueCSSProperty);\r\n        rotateX = UnitDEGCSSValue(rotateX)[0];\r\n        rotateY = UnitDEGCSSValue(rotateY)[0];\r\n        rotateZ = UnitDEGCSSValue(rotateZ)[0];\r\n\r\n        scale = UnitLessCSSValue(scale as TypeSingleValueCSSProperty);\r\n        scale3d = UnitLessCSSValue(scale3d as TypeSingleValueCSSProperty);\r\n        scaleX = UnitLessCSSValue(scaleX)[0];\r\n        scaleY = UnitLessCSSValue(scaleY)[0];\r\n        scaleZ = UnitLessCSSValue(scaleZ)[0];\r\n\r\n        skew = UnitDEGCSSValue(skew as TypeSingleValueCSSProperty);\r\n        skewX = UnitDEGCSSValue(skewX)[0];\r\n        skewY = UnitDEGCSSValue(skewY)[0];\r\n\r\n        perspective = UnitPXCSSValue(perspective)[0];\r\n\r\n        return [\r\n            rest,\r\n            translate, translate3d, translateX, translateY, translateZ,\r\n            rotate, rotate3d, rotateX, rotateY, rotateZ,\r\n            scale, scale3d, scaleX, scaleY, scaleZ,\r\n            skew, skewX, skewY,\r\n            perspective\r\n        ];\r\n    }).map(([rest, ...transformFunctions]) => {\r\n        let transform = createTransformProperty(transformFunctions);\r\n        rest = CSSPropertiesToArr(rest as ICSSProperties);\r\n        return Object.assign({},\r\n            isValid(transform) ? { transform } : null,\r\n            rest);\r\n    });\r\n}\r\n\r\n/**\r\n * An animation library for the modern web, which. Inspired by animate plus, and animejs, [@okikio/animate](https://www.skypack.dev/view/@okikio/animate) is a Javascript animation library focused on performance and ease of use.\r\n *\r\n * You can check it out here: <https://codepen.io/okikio/pen/qBbdGaW?editors=0011>\r\n */\r\nexport class Animate {\r\n    /**\r\n     * Stores the options for the current animation\r\n     *\r\n     * @inheritDoc DefaultAnimationOptions\r\n     */\r\n    public options: IAnimationOptions = {};\r\n\r\n    /**\r\n     * The list of Elements to Animate\r\n     */\r\n    public targets: Manager<number, Node> = new Manager();\r\n\r\n    /**\r\n     * The properties to animate\r\n     */\r\n    public properties: object = {};\r\n\r\n    /**\r\n     * A Manager of Animations\r\n     */\r\n    public animations: Manager<HTMLElement, Animation> = new Manager();\r\n\r\n    /**\r\n     * A Manager of KeyFrameEffects\r\n     */\r\n    public keyframeEffects: Manager<Animation, KeyframeEffect> = new Manager();\r\n\r\n    /**\r\n     * The total duration of all Animation's\r\n     */\r\n    public totalDuration: number = 0;\r\n\r\n    /**\r\n     * The smallest delay out of all Animation's\r\n     */\r\n    public minDelay: number = 0;\r\n\r\n    /**\r\n     * The largest speed out of all Animation's\r\n     */\r\n    public maxSpeed: number = 0;\r\n\r\n    /**\r\n     * The options for individual animations\r\n     *\r\n     * A Manager that stores all the fully calculated options for individual Animation instances.\r\n     *\r\n     * _**Note**: the computedOptions are changed to their proper Animation instance options, so, some of the names are different, and options that can't be computed are not present. E.g. fillMode in the animation options is now just fill in the computedOptions.*_\r\n     *\r\n     * _**Note**: keyframes are not included, both the array form and the object form; the options, speed, extend, padEndDelay, and autoplay animation options are not included_\r\n     */\r\n    public computedOptions: Manager<Animation, TypeComputedOptions> = new Manager();\r\n\r\n    /**\r\n     * The keyframes for individual animations\r\n     *\r\n     * A Manager that stores all the fully calculated keyframes for individual Animation instances.\r\n     *\r\n     * _**Note**: the computedKeyframes are changed to their proper Animation instance options, so, some of the names are different, and options that can't be computed are not present. E.g. translateX, skew, etc..., they've all been turned into the transform property.*_\r\n     */\r\n    public computedKeyframes: Manager<Animation, TypeKeyFrameOptionsType> = new Manager();\r\n\r\n    /**\r\n     * The Element the mainAnimation runs on\r\n     */\r\n    public mainElement: HTMLElement;\r\n\r\n    /**\r\n     * Stores an animation that runs on the total duration of all the `Animation` instances, and as such it's the main Animation.\r\n     */\r\n    public mainAnimation: Animation;\r\n\r\n    /**\r\n     * The Keyframe Effect for the mainAnimation\r\n     */\r\n    public mainkeyframeEffect: KeyframeEffect;\r\n\r\n    /**\r\n     * Stores request frame calls\r\n     */\r\n    public animationFrame: number;\r\n\r\n    /**\r\n     * An event emitter\r\n     */\r\n    public emitter: EventEmitter = new EventEmitter();\r\n\r\n    /**\r\n     * Returns a promise that is fulfilled when the mainAnimation is finished\r\n     */\r\n    public promise: Promise<Animate[]>;\r\n    constructor(options: IAnimationOptions) {\r\n        this.loop = this.loop.bind(this);\r\n        this.onVisibilityChange = this.onVisibilityChange.bind(this);\r\n        this.updateOptions(options);\r\n\r\n        this.visibilityPlayState = this.getPlayState();\r\n        if (Animate.pauseOnPageHidden) {\r\n            document.addEventListener('visibilitychange', this.onVisibilityChange);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells all animate instances to pause when the page is hidden\r\n     *\r\n     * @static\r\n     * @type {Boolean}\r\n     * @memberof Animate\r\n     */\r\n    static pauseOnPageHidden: Boolean = true;\r\n\r\n    /**\r\n     * Store the last remebered playstate before page was hidden\r\n     *\r\n     * @protected\r\n     * @type {TypePlayStates}\r\n     * @memberof Animate\r\n     */\r\n     protected visibilityPlayState: TypePlayStates;\r\n\r\n    /**\r\n     * document `visibilitychange` event handler\r\n     */\r\n    protected onVisibilityChange() {\r\n        if (document.hidden) {\r\n            this.visibilityPlayState = this.getPlayState();\r\n            if (this.is(\"running\")) {\r\n                this.loop();\r\n                this.pause();\r\n            }\r\n        } else {\r\n            if (this.visibilityPlayState == \"running\" && this.is(\"paused\"))\r\n                this.play();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new Promise that is resolved when the animation finishes\r\n     */\r\n    public newPromise(): Promise<Animate[]> {\r\n        this.promise = new Promise((resolve, reject) => {\r\n            /*\r\n                Note that the `this` keyword is in an Array when it is resolved,\r\n                this is due to Promises not wanting to resolve references,\r\n                so, you can't resolve `this` directly, so, I chose to resolve `this` in an\r\n                Array\r\n\r\n                Note: the `resolve` method by default will only run once so to avoid\r\n            */\r\n            this?.emitter?.once?.(\"finish\", () => resolve([this]));\r\n            this?.emitter?.once?.(\"error\", err => reject(err));\r\n        });\r\n\r\n        return this.promise;\r\n    }\r\n\r\n    /**\r\n     * Fulfills the `this.promise` Promise\r\n     */\r\n    public then(\r\n        onFulfilled?: (value?: any) => any,\r\n        onRejected?: (reason?: any) => any\r\n    ): Animate {\r\n        onFulfilled = onFulfilled?.bind(this);\r\n        onRejected = onRejected?.bind(this);\r\n        this?.promise?.then?.(onFulfilled, onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Catches error that occur in the `this.promise` Promise\r\n     */\r\n    public catch(onRejected: (reason?: any) => any): Animate {\r\n        onRejected = onRejected?.bind(this);\r\n        this.promise?.catch?.(onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * If you don't care if the `this.promise` Promise has either been rejected or resolved\r\n     */\r\n    public finally(onFinally: () => any): Animate {\r\n        onFinally = onFinally?.bind(this);\r\n        this.promise?.finally?.(onFinally);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Represents an Animation Frame Loop\r\n     */\r\n    public loop(): void {\r\n        this.stopLoop();\r\n        this.animationFrame = window.requestAnimationFrame(this.loop);\r\n        this.emit(\"update\", this.getProgress(), this);\r\n    }\r\n\r\n    /**\r\n     * Cancels animation frame\r\n     */\r\n    public stopLoop() {\r\n        window.cancelAnimationFrame(this.animationFrame);\r\n    }\r\n\r\n    /**\r\n     * Calls a method that affects all animations **excluding** the mainAnimation; the method only allows the animation parameter\r\n    */\r\n    public allAnimations(method: (animation?: Animation, target?: HTMLElement) => void) {\r\n        this.animations.forEach(method);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calls a method that affects all animations **including** the mainAnimation; the method only allows the animation parameter\r\n    */\r\n    public all(method: (animation?: Animation, target?: HTMLElement) => void) {\r\n        this.mainAnimation && method(this.mainAnimation, this.mainElement);\r\n        this.allAnimations(method);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register the begin event\r\n     */\r\n    protected beginEvent() {\r\n        if (this.getProgress() == 0)\r\n            this.emit(\"begin\", this);\r\n    }\r\n\r\n    /**\r\n     * Play Animation\r\n     */\r\n    public play(): Animate {\r\n        let playstate = this.getPlayState();\r\n        this.beginEvent();\r\n        this.all(anim => anim.play());\r\n        this.emit(\"play\", playstate, this);\r\n        if (!this.is(playstate))\r\n            this.emit(\"playstate-change\", playstate, this);\r\n        this.loop();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause Animation\r\n     */\r\n    public pause(): Animate {\r\n        let playstate = this.getPlayState();\r\n        this.all(anim => anim.pause());\r\n        this.emit(\"pause\", playstate, this);\r\n        if (!this.is(playstate))\r\n            this.emit(\"playstate-change\", playstate, this);\r\n        this.stopLoop();\r\n        this.animationFrame = undefined;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverse Animation\r\n     */\r\n    public reverse() {\r\n        this.all(anim => anim.reverse());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all Animations\r\n     */\r\n    public reset() {\r\n        this.setProgress(0);\r\n\r\n        if (this.options.autoplay) this.play();\r\n        else this.pause();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels all Animations\r\n     */\r\n    public cancel() {\r\n        this.all(anim => anim.cancel());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force complete all Animations\r\n     */\r\n    public finish() {\r\n        this.all(anim => anim.finish());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels & Clears all Animations\r\n     */\r\n    public stop() {\r\n        this.cancel();\r\n\r\n        if (Animate.pauseOnPageHidden) {\r\n            document.removeEventListener('visibilitychange', this.onVisibilityChange);\r\n        }\r\n\r\n        this.computedOptions.clear();\r\n        this.animations.clear();\r\n        this.keyframeEffects.clear();\r\n        this.targets.clear();\r\n\r\n        this.mainkeyframeEffect = undefined;\r\n        this.mainAnimation = undefined;\r\n        this.mainElement = undefined;\r\n\r\n        this.emit(\"stop\");\r\n        this.emitter.clear();\r\n\r\n        this.promise = undefined;\r\n        this.computedOptions = undefined;\r\n        this.animations = undefined;\r\n        this.keyframeEffects = undefined;\r\n        this.emitter = undefined;\r\n        this.targets = undefined;\r\n        this.options = undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns an Manager instance for targets\r\n     */\r\n    public getTargets() {\r\n        return this.targets.values();\r\n    }\r\n\r\n    /**\r\n     * Get a specific Animation from an Animate instance\r\n     */\r\n    public getAnimation(element: HTMLElement): Animation {\r\n        return this.animations.get(element);\r\n    }\r\n\r\n    /**\r\n     * Get a specific Animation's KeyframeEffect from an Animate instance\r\n     */\r\n    public getKeyframeEffect(animation: Animation): KeyframeEffect {\r\n        return this.keyframeEffects.get(animation);\r\n    }\r\n\r\n    /**\r\n     * Returns the timings of an Animation, given a target\r\n     * E.g. { duration, endDelay, delay, iterations, iterationStart, direction, easing, fill, etc... }\r\n     */\r\n    public getTiming(target: HTMLElement | Animation): TypeComputedAnimationOptions {\r\n        let animation = target instanceof Animation ? target : this.getAnimation(target);\r\n        let keyframeOptions = this.computedOptions.get(animation) ?? {};\r\n        let timings = this.getKeyframeEffect(animation).getTiming?.() ?? {};\r\n        let options = this.getOptions();\r\n\r\n        return { ...DefaultAnimationOptions, ...options, ...timings, ...keyframeOptions };\r\n    }\r\n\r\n    /**\r\n     * Returns the total duration of Animation\r\n     */\r\n    public getTotalDuration(): number {\r\n        return this.totalDuration;\r\n    }\r\n\r\n    /**\r\n     * Returns the current time of the Main Animation\r\n     */\r\n    public getCurrentTime(): number {\r\n        return this.mainAnimation.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Returns the Animation progress as a fraction of the current time / duration * 100\r\n     */\r\n    public getProgress() {\r\n        return (this.getCurrentTime() / this.totalDuration) * 100;\r\n    }\r\n\r\n    /**\r\n     * Return the playback speed of the animation\r\n     */\r\n    public getSpeed(): number {\r\n        return this.mainAnimation.playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Returns the current playing state\r\n     */\r\n    public getPlayState(): TypePlayStates {\r\n        return this.mainAnimation.playState;\r\n    }\r\n\r\n    /**\r\n     * Get the options of an Animate instance\r\n     */\r\n    public getOptions(): IAnimationOptions {\r\n        return this.options;\r\n    }\r\n\r\n    /**\r\n     * Get the computed options object for a specific target\r\n     */\r\n    public getComputedOption(target: HTMLElement | Animation): IAnimationOptions {\r\n        let animation = target instanceof Animation ? target : this.getAnimation(target);\r\n        return this.computedOptions.get(animation);\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean determining if the `animate` instances playstate is equal to the `playstate` parameter.\r\n     */\r\n    public is(playstate: TypePlayStates) {\r\n        return this.getPlayState() == playstate;\r\n    }\r\n\r\n    /**\r\n     * Set the current time of the Main Animation\r\n     */\r\n    public setCurrentTime(time: number): Animate {\r\n        this.all(anim => { anim.currentTime = time; });\r\n        this.emit(\"update\", this.getProgress());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the Animation progress as a value from 0 to 100\r\n     */\r\n    public setProgress(percent: number): Animate {\r\n        let time = (percent / 100) * this.totalDuration;\r\n        this.setCurrentTime(time);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the playback speed of an Animation\r\n     */\r\n    public setSpeed(speed: number = 1): Animate {\r\n        this.maxSpeed = speed;\r\n        this.all(anim => {\r\n            if (anim.updatePlaybackRate)\r\n                anim.updatePlaybackRate(speed);\r\n            else anim.playbackRate = speed;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the options for all targets set in the constructor\r\n     *\r\n     * _**Note**: `KeyframeEffect` support is really low, so, I am suggest that you avoid using the `updateOptions` method, until browser support for `KeyframeEffect.updateTiming(...)` and `KeyframeEffefct.setKeyframes(...)` is better_\r\n     *\r\n     * @beta\r\n     */\r\n    public updateOptions(options: IAnimationOptions = {}) {\r\n        try {\r\n            this.options = Object.assign({}, DefaultAnimationOptions, this.options, parseOptions(options));\r\n\r\n            let {\r\n                loop,\r\n                delay,\r\n                speed,\r\n                easing,\r\n                timelineOffset,\r\n                endDelay,\r\n                duration,\r\n                direction,\r\n                fillMode,\r\n                onfinish,\r\n                oncancel,\r\n                keyframes,\r\n                autoplay,\r\n                target,\r\n                targets: _targets,\r\n                padEndDelay,\r\n                extend,\r\n\r\n                /**\r\n                 * Theses are the CSS properties to be animated as Keyframes\r\n                 */\r\n                ...properties\r\n            } = this.options;\r\n\r\n            let targets = new Set([...this.getTargets(), ...getTargets(_targets), ...getTargets(target)]);\r\n            this.targets = new Manager();\r\n            this.properties = properties;\r\n\r\n            targets.forEach(value => this.targets.add(value));\r\n\r\n            let delayArr = [];\r\n            let speedArr = [];\r\n            let len = this.targets.size;\r\n            let listofComputedOptions = [];\r\n            let oldTotalDuration = this.totalDuration;\r\n            let animationOptions: IAnimationOptions = {\r\n                easing: typeof easing == \"string\" ? GetEase(easing) : easing,\r\n                iterations: loop === true ? Infinity : (loop as number),\r\n                direction,\r\n                endDelay,\r\n                duration,\r\n                speed,\r\n                delay,\r\n                timelineOffset,\r\n                fill: fillMode,\r\n                ...extend\r\n            };\r\n\r\n            this.targets.forEach((target: HTMLElement, i) => {\r\n                // Allows the use of functions as the values, for both the keyframes and the animation object\r\n                // It adds the capability of advanced stagger animation, similar to the animejs stagger functions\r\n                let computedOptions = mapAnimationOptions(animationOptions, [i, len, target], this);\r\n\r\n                // Add timelineOffset to delay, this is future proofing;\r\n                // if you want to create a custom timeline similar to animejs this will help you\r\n                // I don't intend to make a timeline function for this project\r\n                let { timelineOffset, ...remainingComputedOptions } = computedOptions;\r\n\r\n                (remainingComputedOptions.delay as number) += timelineOffset as number;\r\n                remainingComputedOptions.tempDurations = +remainingComputedOptions.delay +\r\n                    (+remainingComputedOptions.duration * +remainingComputedOptions.iterations) +\r\n                    +remainingComputedOptions.endDelay;\r\n\r\n                // Set the Animate class's duration to be the Animation with the largest totalDuration\r\n                if (this.totalDuration < +remainingComputedOptions.tempDurations) {\r\n                    this.totalDuration = +remainingComputedOptions.tempDurations;\r\n                }\r\n\r\n                listofComputedOptions[i] = remainingComputedOptions;\r\n                delayArr.push(remainingComputedOptions.delay);\r\n                speedArr.push(remainingComputedOptions.speed);\r\n            });\r\n\r\n            this.targets.forEach((target: HTMLElement, i) => {\r\n                let { speed: $speed, tempDurations, ...computedOptions }: IAnimationOptions = listofComputedOptions[i];\r\n                let animationKeyframe: TypeKeyFrameOptionsType;\r\n                let computedKeyframes: Keyframe[] | PropertyIndexedKeyframes;\r\n\r\n                // You cannot use the `padEndDelay` option and set a value for `endDelay`, the `endDelay` value will\r\n                // replace the padded endDelay\r\n\r\n                // This ensures all `animations` match up to the total duration, and don't finish too early,\r\n                // if animations finish too early, when the `.play()` method is called, some animations\r\n                // that are finished will restart, while the rest will continue playing.\r\n                // This is mostly for progress control, but depending on your usage may truly benefit you\r\n                if (padEndDelay && computedOptions.endDelay == 0 && Math.abs(+computedOptions.iterations) != Math.abs(Infinity)) {\r\n                    computedOptions.endDelay = this.totalDuration - (tempDurations as number);\r\n                }\r\n\r\n                // Accept keyframes as a keyframes Object, or a method,\r\n                // if there are no animations in the keyframes array,\r\n                // uses css properties from the options object\r\n                let arrKeyframes = computeOption(keyframes, [i, len, target], this) as (Keyframe[] | TypeCSSLikeKeyframe);\r\n                if (typeof arrKeyframes == \"object\")\r\n                    arrKeyframes = KeyframeParse(arrKeyframes);\r\n                animationKeyframe = isValid(arrKeyframes) ? arrKeyframes as Keyframe[] : (properties as PropertyIndexedKeyframes);\r\n\r\n                // If keyframes isn't defined as an animation option, use CSS properties as keyframes\r\n                if (!Array.isArray(animationKeyframe)) {\r\n                    let { offset, ...CSSProperties } = mapAnimationOptions(animationKeyframe as IAnimationOptions, [i, len, target], this);\r\n                    let $offset = offset as (string | number)[];\r\n\r\n                    // transform, is often used so, to make them easier to use we parse them for strings, number, and/or arrays of both;\r\n                    // for transform we parse the translate, skew, scale, and perspective functions (including all their varients) as CSS properties;\r\n                    // it then turns these properties into valid `PropertyIndexedKeyframes`\r\n                    // Read the documentation for `ParseTransformableCSSProperties`\r\n                    CSSProperties = ParseTransformableCSSProperties(CSSProperties as ICSSComputedTransformableProperties);\r\n                    computedKeyframes = Object.assign({},\r\n                        // Remove the offset effect option if it's not valid\r\n                        isValid($offset) ? { offset: $offset.map(parseOffset) } : null,\r\n                        CSSProperties\r\n                    ) as PropertyIndexedKeyframes;\r\n                } else {\r\n                    // Validate keyframe effect options\r\n                    computedKeyframes = animationKeyframe.map((keyframe: Keyframe & { loop: boolean | number }) => {\r\n                        let { speed, loop, easing, offset, ...rest } = keyframe; // Remove `speed`, it's not a valid CSS property\r\n\r\n                        return {\r\n                            easing: typeof easing == \"string\" ? GetEase(easing) : easing,\r\n                            iterations: (loop as boolean) === true ? Infinity : (loop as number),\r\n                            offset: parseOffset(offset),\r\n                            ...rest\r\n                        };\r\n                    });\r\n\r\n                    // Transform transformable CSS properties in each keyframe of the keyframe array\r\n                    computedKeyframes = ParseTransformableCSSKeyframes(computedKeyframes) as Keyframe[];\r\n                }\r\n\r\n                let animation: Animation, keyFrameEffect: KeyframeEffect;\r\n                if (!this.animations.has(target)) {\r\n                    // Create animation and add it to the Animations Set\r\n                    keyFrameEffect = new KeyframeEffect(target, computedKeyframes, computedOptions as KeyframeAnimationOptions);\r\n                    animation = new Animation(keyFrameEffect, computedOptions.timeline);\r\n\r\n                    this.animations.set(target, animation);\r\n                    this.keyframeEffects.set(animation, keyFrameEffect);\r\n                } else {\r\n                    // Update the animation\r\n                    animation = this.getAnimation(target);\r\n                    keyFrameEffect = this.getKeyframeEffect(animation);\r\n\r\n                    keyFrameEffect?.setKeyframes?.(computedKeyframes);\r\n                    keyFrameEffect?.updateTiming?.(computedOptions as KeyframeAnimationOptions);\r\n                }\r\n\r\n                animation.playbackRate = $speed as number;\r\n\r\n                // Support for on finish\r\n                animation.onfinish = () => {\r\n                    typeof onfinish == \"function\" && onfinish.call(this, target, i, len, animation);\r\n                };\r\n\r\n                // Support for on cancel\r\n                animation.oncancel = () => {\r\n                    typeof oncancel == \"function\" && oncancel.call(this, target, i, len, animation);\r\n                };\r\n\r\n                // Set the calculated options & keyframes for each individual animation\r\n                this.computedOptions.set(animation, computedOptions);\r\n                this.computedKeyframes.set(animation, computedKeyframes);\r\n            });\r\n\r\n            if (!this.mainAnimation) {\r\n                this.mainkeyframeEffect = new KeyframeEffect(this.mainElement, [\r\n                    { opacity: \"0\" },\r\n                    { opacity: \"1\" }\r\n                ], {\r\n                    // Why waste performance on an animation no one can see?\r\n                    duration: this.totalDuration,\r\n                    easing: \"linear\"\r\n                });\r\n\r\n                this.mainAnimation = new Animation(this.mainkeyframeEffect, this.options.timeline);\r\n                this.mainAnimation.onfinish = () => {\r\n                    let playstate = this.getPlayState();\r\n                    this.emit(\"finish\", playstate, this);\r\n                    if (!this.is(playstate))\r\n                        this.emit(\"playstate-change\", playstate, this);\r\n                    this.stopLoop();\r\n                };\r\n\r\n                this.mainAnimation.oncancel = () => {\r\n                    let playstate = this.getPlayState();\r\n                    this.emit(\"cancel\", playstate, this);\r\n                    if (!this.is(playstate))\r\n                        this.emit(\"playstate-change\", playstate, this);\r\n                    this.stopLoop();\r\n                };\r\n            } else if (oldTotalDuration !== this.totalDuration) {\r\n                this.mainkeyframeEffect?.updateTiming?.({\r\n                    duration: this.totalDuration\r\n                });\r\n\r\n                if (!this.mainkeyframeEffect.setKeyframes || !this.mainkeyframeEffect.updateTiming)\r\n                    console.error(\"@okikio/animate - `KeyframeEffect.setKeyframes` and/or `KeyframeEffect.updateTiming` are not supported in this browser.\");\r\n            }\r\n\r\n            this.minDelay = Math.min(...delayArr);\r\n            this.maxSpeed = Math.min(...speedArr);;\r\n            this.mainAnimation.playbackRate = this.maxSpeed;\r\n\r\n            if (autoplay) {\r\n                // By the time events are registered the animation would have started and there wouldn't have be a `begin` event listener to actually emit\r\n                // So, this defers the emitting for a 0ms time allowing the rest of the js to run, the `begin` event to be registered thus\r\n                // the `begin` event can be emitter\r\n                let timer: number | void = window.setTimeout(() => {\r\n                    this.emit(\"begin\", this);\r\n                    timer = window.clearTimeout(timer as number);\r\n                }, 0);\r\n\r\n                this.play();\r\n            } else this.pause();\r\n\r\n            this.newPromise();\r\n        } catch (err) {\r\n            this.emit(\"error\", err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     */\r\n    public on(events: TypeAnimationEvents[] | TypeAnimationEvents | TypeEventInput, callback?: TypeListenerCallback | object, scope?: object): Animate {\r\n        this?.emitter?.on(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     */\r\n    public off(events: TypeAnimationEvents[] | TypeAnimationEvents | TypeEventInput, callback?: TypeListenerCallback | object, scope?: object): Animate {\r\n        this?.emitter?.off(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     */\r\n    public emit(events: TypeAnimationEvents[] | TypeAnimationEvents | string | any[], ...args: any): Animate {\r\n        this?.emitter?.emit(events, ...args);\r\n        return this;\r\n    }\r\n\r\n    /** Returns the Animate options, as JSON  */\r\n    public toJSON(): IAnimationOptions {\r\n        return this.getOptions();\r\n    }\r\n\r\n    /**\r\n     * The Symbol.toStringTag well-known symbol is a string valued property that is used\r\n     * in the creation of the default string description of an object.\r\n     * It is accessed internally by the Object.prototype.toString() method.\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return `Animate`;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new Animate instance\r\n *\r\n * @remark\r\n * `@okikio/animate` create animations by creating instances of `Animate`, a class that acts as a wrapper around the Web Animation API. To create new instances of the `Animate` class, you can either import the `Animate` class and do this, `new Animate({ ... })` or import the `animate` (lowercase) method and do this, `animate({ ... })`. The `animate` method creates new instances of the `Animate` class and passes the options it recieves as arguments to the `Animate` class.\r\n *\r\n * The `Animate` class recieves a set of targets to animate, it then creates a list of Web Animation API `Animation` instances, along side a main animation, which is small `Animation` instance that is set to animate the opacity of a non visible element, the `Animate` class then plays each `Animation` instances keyframes including the main animation.\r\n\r\n * The main animation is there to ensure accuracy in different browser vendor implementation of the Web Animation API. The main animation is stored in `Animate.prototype.mainAnimation: Animation`, the other `Animation` instances are stored in a `Manager` (from [@okikio/manager](https://www.npmjs.com/package/@okikio/manager)) `Animate.prototype.animations: Manager<HTMLElement, Animation>`.\r\n\r\n * @example\r\n * ```ts\r\n * import animate from \"@okikio/animate\";\r\n *\r\n * // Do note, on the web you need to do this, if you installed it via the script tag:\r\n * // const { animate } = window.animate;\r\n *\r\n * (async () => {\r\n *     let [options] = await animate({\r\n *         target: \".div\",\r\n *         // NOTE: If you turn this on you have to comment out the transform property. The keyframes property is a different format for animation you cannot you both styles of formatting in the same animation\r\n *         // keyframes: [\r\n *         //     { transform: \"translateX(0px)\" },\r\n *         //     { transform: \"translateX(300px)\" }\r\n *         // ],\r\n *         transform: [\"translateX(0px)\", \"translateX(300px)\"],\r\n *         easing: \"out\",\r\n *         duration(i) {\r\n *             return (i + 1) * 500;\r\n *         },\r\n *         loop: 1,\r\n *         speed: 2,\r\n *         fillMode: \"both\",\r\n *         direction: \"normal\",\r\n *         autoplay: true,\r\n *         delay(i) {\r\n *             return (i + 1) * 100;\r\n *         },\r\n *         endDelay(i) {\r\n *             return (i + 1) * 100;\r\n *         },\r\n *     });\r\n *\r\n *     animate({\r\n *         options,\r\n *         transform: [\"translateX(300px)\", \"translateX(0px)\"],\r\n *     });\r\n * })();\r\n *\r\n * // or you can use the .then() method\r\n * animate({\r\n *     target: \".div\",\r\n *     // NOTE: If you turn this on you have to comment out the transform property. The keyframes property is a different format for animation you cannot you both styles of formatting in the same animation\r\n *     // keyframes: [\r\n *     //     { transform: \"translateX(0px)\" },\r\n *     //     { transform: \"translateX(300px)\" }\r\n *     // ],\r\n *     transform: [\"translateX(0px)\", \"translateX(300px)\"],\r\n *     easing: \"out\",\r\n *     duration(i) {\r\n *         return (i + 1) * 500;\r\n *     },\r\n *     loop: 1,\r\n *     speed: 2,\r\n *     fillMode: \"both\",\r\n *     direction: \"normal\",\r\n *     delay(i) {\r\n *         return (i + 1) * 100;\r\n *     },\r\n *     autoplay: true,\r\n *     endDelay(i) {\r\n *         return (i + 1) * 100;\r\n *     }\r\n * }).then((options) => {\r\n *     animate({\r\n *         options,\r\n *         transform: [\"translateX(300px)\", \"translateX(0px)\"]\r\n *     });\r\n * });\r\n * ```\r\n *\r\n * [Preview this example &#8594;](https://codepen.io/okikio/pen/mdPwNbJ?editors=0010)\r\n *\r\n * @packageDocumentation\r\n */\r\nexport const animate = (options: IAnimationOptions = {}): Animate => {\r\n    return new Animate(options);\r\n};\r\n\r\nexport * from \"./builtin-effects\";\r\nexport default animate;\r\n", "import { animate, IAnimationOptions, methodCall } from \"@okikio/native\";\r\n\r\nlet playbackFn = (containerSel, anims) => {\r\n    let playstateEl = document.querySelector(`${containerSel} #playstate-toggle`) as HTMLInputElement;\r\n    let progressEl = document.querySelector(`${containerSel} #progress`) as HTMLInputElement;\r\n\r\n    let progressOutputEl = document.querySelector(`${containerSel} #progress-output`);\r\n    let oldState: AnimationPlayState;\r\n\r\n    let updatePlayState = () => {\r\n        oldState = anims[0].getPlayState();\r\n        playstateEl.setAttribute(\"data-playstate\", oldState);\r\n    };\r\n\r\n    anims[0]\r\n        .on(\"finish begin\", updatePlayState)\r\n        .on(\"update\", (progress) => {\r\n            progressEl.value = `` + progress.toFixed(2);\r\n            progressOutputEl.textContent = `${Math.round(progress)}%`;\r\n        });\r\n\r\n    playstateEl.addEventListener(\"click\", () => {\r\n        if (anims[0].is(\"running\")) methodCall(anims, \"pause\");\r\n        else if (anims[0].is(\"finished\")) methodCall(anims, \"reset\");\r\n        else methodCall(anims, \"play\");\r\n\r\n        updatePlayState();\r\n    });\r\n\r\n    progressEl.addEventListener(\"input\", (e) => {\r\n        let percent = +progressEl.value;\r\n        methodCall(anims, \"pause\");\r\n        methodCall(anims, \"setProgress\", percent);\r\n    });\r\n\r\n    progressEl.addEventListener(\"change\", () => {\r\n        oldState !== \"paused\" ? methodCall(anims, \"play\") : methodCall(anims, \"pause\");\r\n\r\n        updatePlayState();\r\n    });\r\n\r\n}\r\n\r\nlet random = (min: number, max: number) => Math.floor(Math.random() * (max - min + 1)) + min;\r\n\r\n/* Properties Section */\r\n// Playback Controls Demo\r\n(() => {\r\n    let containerSel = \".playback-demo\";\r\n\r\n    let DOMNodes = document.querySelectorAll(`${containerSel} .el`);\r\n    let anim = animate({\r\n        target: DOMNodes,\r\n\r\n        // keyframes(index, total) {\r\n        //     return [\r\n        //         { transform: \"translateX(0px)\", opacity: 0.1 },\r\n        //         { transform: \"translateX(400px)\", opacity: 0.2 + ((index + 1) / total) }\r\n        //     ]\r\n        // },\r\n        // keyframes(index, total) {\r\n        //     return {\r\n        //         \"from\": {\r\n        //             // transform: \"translateX(0px)\",\r\n        //             // translateX: 0,\r\n        //             opacity: 0.1,\r\n        //         },\r\n        //         \"to\": {\r\n        //             // transform: \"translateX(400px)\",\r\n        //             // translate: 400,\r\n        //             translateX: 400,\r\n        //             opacity: 0.2 + ((index + 1) / total)\r\n        //         }\r\n        //     };\r\n        // },\r\n\r\n        // transform: [\"translateX(0px)\", \"translateX(300px)\"],\r\n        // translateX: 300,\r\n\r\n        translateX: (index) => [170, 80, 270][index],\r\n        translateY(index) {\r\n            return 50 + (-50 * index);\r\n        },\r\n        scale(index, total) {\r\n            return (total - index) + 0.25;\r\n        },\r\n        opacity(index, total) {\r\n            return [0.5, 0.5 + Math.min((index + 1) / total, 0.5)];\r\n        },\r\n        rotate: () => random(-360, 360),\r\n        borderRadius: () => `${random(10, 35)}%`,\r\n        duration: () => random(1200, 1800),\r\n        delay: () => random(0, 400),\r\n\r\n        // delay(index) {\r\n        //     return ((index + 1) * 500) / 2;\r\n        // },\r\n        // duration(index: number) {\r\n        //     return (index + 1) * 500;\r\n        // },\r\n\r\n        // It is best to use the onfinish() method, but in this situation fillMode works best\r\n        fillMode: \"both\",\r\n        // onfinish(element, index, total) {\r\n        //     element.style.opacity = `${((index + 1) / total)}`;\r\n        //     element.style.transform = \"translateX(300px)\";\r\n        // },\r\n\r\n        easing: \"in-out-back\",\r\n        loop: 2,\r\n        speed: 1.5,\r\n        direction: \"alternate\",\r\n\r\n        padEndDelay: true,\r\n        autoplay: true\r\n    });\r\n\r\n    setTimeout(() => {\r\n        console.log(\"updateOptions\");\r\n\r\n        anim.updateOptions({\r\n            backgroundColor: \"red\",\r\n            speed: (i) => 1.5 - (i * 0.125),\r\n        });\r\n    }, 500)\r\n\r\n    playbackFn(containerSel, [anim]);\r\n})();\r\n\r\n(() => {\r\n    let options: IAnimationOptions = {\r\n        padEndDelay: true,\r\n        easing: \"linear\",\r\n        duration: 2000,\r\n        loop: 4,\r\n        speed: 1,\r\n    };\r\n\r\n    let containerSel = \".motion-path-demo\";\r\n    let el = document.querySelector('.motion-path .el-1') as HTMLElement;\r\n    let motionPath = animate({\r\n        target: el,\r\n        \"offsetDistance\": [\"0%\", \"100%\"],\r\n        ...options\r\n    });\r\n\r\n    let path = document.querySelector('.motion-path path') as SVGPathElement;\r\n    let el2 = document.querySelector('.motion-path .el-2') as HTMLElement;\r\n\r\n    let pts: Set<number[]> = new Set();\r\n    let rotateArr: number[] = [];\r\n    let len = path.getTotalLength();\r\n\r\n    let ptAtZero = path.getPointAtLength(0);\r\n    for (var i = 0; i < len; i++) {\r\n        let { x, y } = path.getPointAtLength(i);\r\n        pts.add([x, y]);\r\n\r\n        let { x: x0, y: y0 } = i - 1 >= 1 ? path.getPointAtLength(i - 1) : ptAtZero;\r\n        let { x: x1, y: y1 } = i + 1 >= 1 ? path.getPointAtLength(i + 1) : ptAtZero;\r\n        let calc = +(Math.atan2(y1 - y0, x1 - x0) * 180 / Math.PI);\r\n        rotateArr.push(calc);\r\n    }\r\n\r\n    let getTotalLength = animate({\r\n        target: el2,\r\n        translate: [...pts],\r\n        rotate: rotateArr,\r\n        fillMode: \"both\",\r\n        ...options\r\n    });\r\n\r\n    playbackFn(containerSel, [motionPath, getTotalLength]);\r\n})();\r\n"],
  "mappings": "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",
  "names": []
}
