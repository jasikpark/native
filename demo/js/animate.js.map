{
  "version": 3,
  "sources": ["packages/manager/src/api.ts", "packages/native/src/page.ts", "packages/emitter/src/api.ts", "packages/animate/src/api.ts", "build/ts/animate.ts"],
  "sourcesContent": ["/** Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data */\r\nexport class Manager<K, V> {\r\n\t/** The complex list of named data, to which the Manager controls */\r\n\tpublic map: Map<K, V>;\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/** Returns the Manager classes base Map */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/** Get a value stored in the Manager */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/** Returns the keys of all items stored in the Manager as an Array */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\t/** Returns the values of all items stored in the Manager as an Array */\r\n\tpublic values(): Array<V> {\r\n\t\treturn Array.from(this.map.values());\r\n\t}\r\n\r\n\t/** Set a value to the Manager using a key */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\tlet size = this.size;\r\n\t\t// @ts-ignore\r\n\t\tlet num: K = size as K;\r\n\t\tthis.set(num, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Returns the total number of items stored in the Manager */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** An alias for size */\r\n\tpublic get length(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** Returns the last item in the Manager who's index is a certain distance from the last item in the Manager */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns true if an element in the Map object existed and has been removed, or false if the element does not exist */\r\n\tpublic delete(key: K): boolean {\r\n\t\treturn this.map.delete(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns the Manager class, allowing for chains */\r\n\tpublic remove(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Clear the Manager of all its contents */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Checks if the Manager contains a certain key */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/** Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order. */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/** Iterates through the Managers contents, calling a callback function every iteration */\r\n\tpublic forEach(\r\n\t\tcallback: (value?: V, key?: K, map?: Map<K, V>) => void,\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Allows for iteration via for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators] */\r\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\r\n\t\treturn this.entries();\r\n\t}\r\n}\r\n\r\n/**\r\n * Calls the method of a certain name for all items that are currently installed\r\n */\r\nexport const methodCall = (manager: Manager<any, any>, method: string, ...args: any): void => {\r\n\tmanager.forEach((item) => {\r\n\t\t// @ts-ignore\r\n\t\titem[method](...args);\r\n\t});\r\n};\r\n\r\n/**\r\n * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n */\r\nexport const asyncMethodCall = async (manager: Manager<any, any>, method: string, ...args: any): Promise<void> => {\r\n\tfor (let [, item] of manager) {\r\n\t\t// @ts-ignore\r\n\t\tawait item[method](...args);\r\n\t}\r\n};\r\n\r\nexport default Manager;\r\n", "import { Manager, ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { equal, newURL } from \"./url\";\r\nimport { getConfig } from \"./config\";\r\nimport { Service } from \"./service\";\r\n\r\nexport interface IPage extends ManagerItem {\r\n    dom: Document,\r\n    wrapper: HTMLElement,\r\n    title: string,\r\n    head: Element,\r\n    body: Element,\r\n    url: URL,\r\n    data: string,\r\n    wrapperAttr: string,\r\n\r\n    build(): any,\r\n    install(): void,\r\n    uninstall(): any,\r\n}\r\n\r\n/**\r\n * Parses strings to DOM\r\n */\r\nexport const PARSER: DOMParser = new DOMParser();\r\n\r\n/** A page represents the DOM elements that create each page */\r\nexport class Page extends ManagerItem implements IPage {\r\n    /** Holds the DOM of the current page */\r\n    public dom: Document;\r\n\r\n    /** Holds the wrapper element to be swapped out of each Page */\r\n    public wrapper: HTMLElement;\r\n\r\n    /** Holds the title of each page */\r\n    public title: string;\r\n\r\n    /** Holds the head element of each page */\r\n    public head: Element;\r\n\r\n    /** Holds the body element of each page */\r\n    public body: Element;\r\n\r\n    /** The URL of the current page */\r\n    public url: URL;\r\n\r\n    /** The payload of a page request */\r\n    public data: string;\r\n\r\n    /** Attr that identifies the wrapper */\r\n    public wrapperAttr: string;\r\n\r\n    constructor(url: URL = newURL(), dom: string | Document = document) {\r\n        super();\r\n        this.url = url;\r\n\r\n        if (typeof dom === \"string\") {\r\n            this.data = dom;\r\n        } else this.dom = dom || document;\r\n    }\r\n\r\n    /** Builds the page's dom, and sets the title, head, body, and wrapper properties of the Page class */\r\n    public build() {\r\n        if (!(this.dom instanceof Node)) {\r\n            this.dom = PARSER.parseFromString(this.data, \"text/html\");\r\n        }\r\n\r\n        if (!(this.body instanceof Node)) {\r\n            let { title, head, body } = this.dom;\r\n            this.title = title;\r\n            this.head = head;\r\n            this.body = body;\r\n            this.wrapper = this.body.querySelector(this.wrapperAttr);\r\n        }\r\n    }\r\n\r\n    public install() {\r\n        this.wrapperAttr = getConfig(this.config, \"wrapperAttr\");\r\n    }\r\n\r\n    public uninstall() {\r\n        this.url = undefined;\r\n        this.title = undefined;\r\n        this.head = undefined;\r\n        this.body = undefined;\r\n        this.dom = undefined;\r\n        this.wrapper = undefined;\r\n        this.data = undefined;\r\n        this.wrapperAttr = undefined;\r\n    }\r\n}\r\n\r\nexport interface IPageManager extends Service {\r\n    loading: Manager<string, Promise<string>>,\r\n    pages: AdvancedManager<string, Page>;\r\n\r\n    install(): any,\r\n\r\n    get(key): Page,\r\n    add(value): PageManager,\r\n    set(key, value): PageManager,\r\n    remove(key): PageManager,\r\n    has(key): boolean,\r\n    clear(): PageManager,\r\n    size: number,\r\n    keys(): any[],\r\n\r\n    load(_url: URL | string): Promise<Page>,\r\n    request(url: string): Promise<string>,\r\n}\r\n\r\n/** Controls which page to load */\r\nexport class PageManager extends Service implements IPageManager {\r\n    /** Stores all fetch requests that are currently loading */\r\n    public loading: Manager<string, Promise<string>> = new Manager();\r\n\r\n    pages: AdvancedManager<string, Page>;\r\n\r\n    /** Instantiate pages, and add the current page to pages */\r\n    install() {\r\n        this.pages = new AdvancedManager(this.app);\r\n\r\n        let URLString = newURL().pathname;\r\n        this.set(URLString, new Page());\r\n        URLString = undefined;\r\n    }\r\n\r\n    get(key) { return this.pages.get(key); }\r\n    add(value) { this.pages.add(value); return this; }\r\n    set(key, value) { this.pages.set(key, value); return this; }\r\n    remove(key) { this.pages.remove(key); return this; }\r\n    has(key) { return this.pages.has(key); }\r\n    clear() { this.pages.clear(); return this; }\r\n    get size() { return this.pages.size; }\r\n    keys() { return this.pages.keys(); }\r\n\r\n    /** Load from cache or by requesting URL via a fetch request, avoid requesting for the same thing twice by storing the fetch request in \"this.loading\" */\r\n    public async load(_url: URL | string = newURL()): Promise<Page> {\r\n        let url: URL = newURL(_url);\r\n        let urlString: string = url.pathname;\r\n        let page: Page, request: Promise<string>;\r\n\r\n        if (this.has(urlString)) {\r\n            page = this.get(urlString);\r\n            return Promise.resolve(page);\r\n        }\r\n\r\n        if (!this.loading.has(urlString)) {\r\n            request = this.request(urlString);\r\n            this.loading.set(urlString, request);\r\n        } else request = this.loading.get(urlString);\r\n\r\n        let response = await request;\r\n        this.loading.remove(urlString);\r\n\r\n        page = new Page(url, response);\r\n        this.set(urlString, page);\r\n\r\n        if (this.size > getConfig(this.config, \"maxPages\")) {\r\n            let currentUrl = newURL();\r\n            let keys = this.keys();\r\n            let first = equal(currentUrl, keys[0]) ? keys[1] : keys[0];\r\n            let page = this.get(first);\r\n            page.unregister();\r\n            page = undefined;\r\n            keys = undefined;\r\n            currentUrl = undefined;\r\n            first = undefined;\r\n        }\r\n\r\n        return page;\r\n    }\r\n\r\n    /** Starts a fetch request */\r\n    public async request(url: string): Promise<string> {\r\n        const headers = new Headers(getConfig(this.config, \"headers\"));\r\n        const timeout = window.setTimeout(() => {\r\n            window.clearTimeout(timeout);\r\n            throw \"Request Timed Out!\";\r\n        }, getConfig(this.config, \"timeout\"));\r\n\r\n        try {\r\n            let response = await fetch(url, {\r\n                mode: 'same-origin',\r\n                method: \"GET\",\r\n                headers,\r\n                cache: \"default\",\r\n                credentials: \"same-origin\",\r\n            });\r\n\r\n            window.clearTimeout(timeout);\r\n            if (response.status >= 200 && response.status < 300) {\r\n                return await response.text();\r\n            }\r\n\r\n            const err = new Error(response.statusText || \"\" + response.status);\r\n            throw err;\r\n        } catch (err) {\r\n            window.clearTimeout(timeout);\r\n            throw err;\r\n        }\r\n    }\r\n}\r\n", "import { Manager, methodCall } from \"@okikio/manager\";\r\n\r\nexport type ListenerCallback = ((...args: any) => void);\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/** Represents a new event listener consisting of properties like: callback, scope, name */\r\nexport const newListener = ({\r\n    callback = () => { },\r\n    scope = null,\r\n    name = \"event\",\r\n}: IListener): IListener => ({ callback, scope, name });\r\n\r\n/** Represents a new event  */\r\nexport class Event extends Manager<number, IListener> {\r\n    /** The name of the event */\r\n    public name: string;\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An Event Emitter\r\n * */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /** Gets event, if event doesn't exist create a new one */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Creates a listener and adds it to an event */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(newListener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n    /** Adds a listener to a given event */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Removes a listener from an event */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let listener = newListener({ name, callback, scope });\r\n\r\n            event.forEach((value: IListener, i: number) => {\r\n                if (\r\n                    value.callback === listener.callback &&\r\n                    value.scope === listener.scope\r\n                ) {\r\n                    return event.remove(i);\r\n                }\r\n            });\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Remove a listener from a given event, or just completely remove an event */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            if (typeof _callback === \"function\") {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.remove(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Call all listeners within an event */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: IListener) => {\r\n                    let { callback, scope } = listener;\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Clears events and event listeners */\r\n    public clear() {\r\n        methodCall(this, \"clear\");\r\n        super.clear();\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default EventEmitter;\r\n", "import { EventEmitter, EventInput, ListenerCallback } from \"@okikio/emitter\";\r\nimport { Manager } from \"@okikio/manager\";\r\n\r\n// DOM\r\nexport type AnimationTarget = string | Node | NodeList | HTMLCollection | HTMLElement[] | AnimationTarget[];\r\nexport const getElements = (selector: string | Node): Node[] => {\r\n    return typeof selector === \"string\" ? Array.from(document.querySelectorAll(selector as string)) : [selector];\r\n};\r\n\r\nconst flatten = (arr: AnimationTarget[]) => [].concat(...arr);\r\nexport const getTargets = (targets: AnimationTarget): Node[] => {\r\n    if (Array.isArray(targets)) {\r\n        return flatten((targets as AnimationTarget[]).map(getTargets));\r\n    }\r\n    if (typeof targets == \"string\" || targets instanceof Node)\r\n        return getElements(targets);\r\n    if (targets instanceof NodeList || targets instanceof HTMLCollection)\r\n        return Array.from(targets);\r\n    return [];\r\n};\r\n\r\n// VALUES\r\nexport type closureArgs = [number, number, HTMLElement];\r\nexport type closure = ((index?: number, total?: number, element?: HTMLElement) => (genericTypes[] | void)) | any;\r\nexport const computeValue = (value: closure, args: closureArgs, context: Animate) => {\r\n    if (typeof value === \"function\") {\r\n        return value.apply(context, args);\r\n    } else { return value; }\r\n};\r\n\r\nexport const mapObject = (obj: object, args: closureArgs, options: Animate): any => {\r\n    let key: string, value: any, result = {};\r\n    let keys = Object.keys(obj);\r\n    for (let i = 0, len = keys.length; i < len; i++) {\r\n        key = keys[i];\r\n        value = obj[key];\r\n        result[key] = computeValue(value, args, options);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/** From: [https://easings.net] */\r\nexport const easings = {\r\n    \"in\": \"ease-in\",\r\n    \"out\": \"ease-out\",\r\n    \"in-out\": \"ease-in-out\",\r\n\r\n    // Sine\r\n    \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n    \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n    \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n\r\n    // Quad\r\n    \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n    \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n    \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n\r\n    // Cubic\r\n    \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n    \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n    \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n\r\n    // Quart\r\n    \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n    \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n    \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n\r\n    // Quint\r\n    \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n    \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n    \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n\r\n    // Expo\r\n    \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n    \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n    \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n\r\n    // Circ\r\n    \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n    \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n    \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n\r\n    // Back\r\n    \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n    \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n    \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n};\r\n\r\nexport const getEase = (ease: string) => {\r\n    return /^(in|out)/.test(ease) ? easings[ease] : ease;\r\n};\r\n\r\nexport type genericTypes = genericTypes[] | boolean | object | string | number | closure | null | undefined;\r\nexport interface AnimationOptions {\r\n    target?: AnimationTarget,\r\n\r\n    speed?: number,\r\n    autoplay?: boolean,\r\n    options?: AnimationOptions,\r\n    delay?: number | closure,\r\n    easing?: string | closure,\r\n    endDelay?: number | closure,\r\n    duration?: number | closure,\r\n    keyframes?: Keyframe[] | object[] | closure,\r\n    loop?: number | boolean | closure, // iterations: number,\r\n    onfinish?: (element?: HTMLElement, index?: number, total?: number, animation?: Animation) => any,\r\n    fillMode?: \"none\" | \"forwards\" | \"backwards\" | \"both\" | \"auto\" | closure,\r\n    direction?: \"normal\" | \"reverse\" | \"alternate\" | \"alternate-reverse\" | closure,\r\n    extend?: EffectTiming,\r\n    [property: string]: genericTypes;\r\n};\r\n\r\nexport const DefaultAnimationOptions: AnimationOptions = {\r\n    keyframes: [],\r\n\r\n    loop: 1, // iterations: number,\r\n    delay: 0,\r\n    speed: 1,\r\n    endDelay: 0,\r\n    easing: \"ease\",\r\n    autoplay: true,\r\n    duration: 1000,\r\n    fillMode: \"auto\",\r\n    direction: \"normal\",\r\n    extend: {}\r\n};\r\n\r\nexport type AnimationEvents = \"update\" | \"play\" | \"pause\" | \"start\" | \"begin\" | \"complete\" | \"finish\" | \"error\" | \"stop\";\r\n\r\n/** You can check it out here: https://codepen.io/okikio/pen/qBbdGaW?editors=0011 */\r\nexport class Animate {\r\n    /**\r\n     * Stores the options for the current animation\r\n     */\r\n    public options: AnimationOptions = {};\r\n\r\n    /**\r\n     * The Array of Elements to Animate\r\n     */\r\n    public targets: Node[] = [];\r\n\r\n    /**\r\n     * The properties to animate\r\n     */\r\n    public properties: object = {};\r\n\r\n    /**\r\n     * A Manager of Animations\r\n     */\r\n    public animations: Manager<HTMLElement, Animation> = new Manager();\r\n\r\n    /**\r\n     * The total duration of all Animation's\r\n     */\r\n    public totalDuration: number = 0;\r\n\r\n    /**\r\n     * The smallest delay out of all Animation's\r\n     */\r\n    public minDelay: number = 0;\r\n\r\n    /**\r\n     * The options for individual animations\r\n     */\r\n    public computedOptions: Manager<Animation, AnimationOptions> = new Manager();\r\n\r\n    /**\r\n     * The Element the main animation uses\r\n     */\r\n    public mainElement: HTMLElement;\r\n\r\n    /**\r\n     * Stores an animation that runs on the total duration of the all other Animations, and as such it's the main Animation\r\n     */\r\n    public mainAnimation: Animation;\r\n\r\n    /**\r\n     * Stores request frame calls\r\n     */\r\n    public animationFrame: number;\r\n\r\n    /**\r\n     * An event emitter\r\n     */\r\n    public emitter: EventEmitter = new EventEmitter();\r\n\r\n    /**\r\n     * Returns a promise that is fulfilled when the mainAnimation is finished\r\n     */\r\n    public promise: Promise<AnimationOptions>;\r\n    constructor(options: AnimationOptions = {}) {\r\n        try {\r\n            let { options: animation, ...rest } = options;\r\n            let oldOptions = animation instanceof Animate ? animation.getOptions() : (Array.isArray(animation) ? animation?.[0]?.getOptions() : animation);\r\n            this.options = Object.assign({}, DefaultAnimationOptions, oldOptions, rest);\r\n            this.loop = this.loop.bind(this);\r\n\r\n            let {\r\n                loop,\r\n                delay,\r\n                speed,\r\n                easing,\r\n                endDelay,\r\n                duration,\r\n                direction,\r\n                fillMode,\r\n                onfinish,\r\n                target,\r\n                keyframes,\r\n                autoplay,\r\n                extend,\r\n                ...properties\r\n            } = this.options;\r\n\r\n            this.mainElement = document.createElement(\"div\");\r\n            this.targets = getTargets(target);\r\n            this.properties = properties;\r\n\r\n            let delays = [];\r\n            let len = this.targets.length;\r\n            let animationKeyframe: Keyframe[] | PropertyIndexedKeyframes;\r\n            for (let i = 0; i < len; i++) {\r\n                let target = this.targets[i] as HTMLElement;\r\n                let animationOptions: AnimationOptions = {\r\n                    easing: typeof easing == \"string\" ? getEase(easing) : easing,\r\n                    iterations: loop === true ? Infinity : (loop as number),\r\n                    direction,\r\n                    endDelay,\r\n                    duration,\r\n                    delay,\r\n                    fill: fillMode,\r\n                    ...extend\r\n                };\r\n\r\n                // Accept keyframes as a keyframes Object, or a method,\r\n                // if there are no animations in the keyframes array,\r\n                // uses css properties from the options object\r\n                let arrKeyframes = computeValue((keyframes as Keyframe[]), [i, len, target], this);\r\n                animationKeyframe = arrKeyframes.length ? arrKeyframes :\r\n                    (this.properties as PropertyIndexedKeyframes);\r\n\r\n                // Allows the use of functions as the values, for both the keyframes and the animation object\r\n                // It adds the capability of advanced stagger animation, similar to the anime js stagger functions\r\n                animationOptions = mapObject(animationOptions, [i, len, target], this);\r\n                if (!(arrKeyframes.length > 0))\r\n                    animationKeyframe = mapObject(animationKeyframe, [i, len, target], this);\r\n\r\n                // Set the Animate classes duration to be the Animation with the largest totalDuration\r\n                let tempDurations = animationOptions.delay +\r\n                    (animationOptions.duration * animationOptions.iterations) +\r\n                    animationOptions.endDelay;\r\n                if (this.totalDuration < tempDurations) this.totalDuration = tempDurations;\r\n\r\n                // Add animation to the Animations Set\r\n                let animation = target.animate(animationKeyframe, animationOptions as KeyframeAnimationOptions);\r\n\r\n                // Support for on finish\r\n                animation.onfinish = () => {\r\n                    typeof onfinish == \"function\" && onfinish.call(this, target, i, len, animation);\r\n                    this.emit(\"finish\", target, i, len, animation);\r\n                };\r\n\r\n                // The calculated options for each individual option\r\n                this.computedOptions.set(animation, animationOptions);\r\n                this.animations.set(target, animation);\r\n                delays.push(animationOptions.delay);\r\n            }\r\n\r\n            this.mainAnimation = this.mainElement.animate([\r\n                { opacity: \"0\" },\r\n                { opacity: \"1\" }\r\n            ], {\r\n                // Why waste performance on an animation no one can see?\r\n                duration: this.totalDuration,\r\n                easing: \"linear\"\r\n            });\r\n\r\n            this.minDelay = Math.min(...delays);\r\n            this.setSpeed(speed);\r\n            if (autoplay) this.play();\r\n            else this.pause();\r\n\r\n            this.promise = this.newPromise();\r\n            this.mainAnimation.onfinish = () => {\r\n                this.emit(\"complete\", this);\r\n                this.stopLoop();\r\n            };\r\n        } catch (err) {\r\n            this.emit(\"error\", err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new Promise that is resolve when this.finish is called\r\n     */\r\n    public newPromise(): Promise<AnimationOptions> {\r\n        return new Promise((resolve, reject) => {\r\n            /*\r\n                Note that the `this` keyword is in an Array when it is resolved,\r\n                this is due to Promises not wanting to resolve references,\r\n                so, you can't resolve `this` directly, so, I chose to resolve `this` in an\r\n                Array\r\n            */\r\n            this.on(\"complete\", () => resolve([this]));\r\n            this.on(\"error\", err => reject(err));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fulfills the this.promise Promise\r\n     */\r\n    public then(\r\n        onFulfilled?: (value?: any) => any,\r\n        onRejected?: (reason?: any) => any\r\n    ): Animate {\r\n        onFulfilled = onFulfilled?.bind(this);\r\n        onRejected = onRejected?.bind(this);\r\n        this.promise.then(onFulfilled, onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Catches error that occur in the this.promise Promise\r\n     */\r\n    public catch(onRejected: (reason?: any) => any): Animate {\r\n        onRejected = onRejected?.bind(this);\r\n        this.promise.catch(onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * If you don't care if the this.promise Promise has either been rejected or resolved\r\n     */\r\n    public finally(onFinally: () => any): Animate {\r\n        onFinally = onFinally?.bind(this);\r\n        this.promise.finally(onFinally);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Represents an Animation Frame Loop\r\n     */\r\n    public loop(): void {\r\n        this.stopLoop();\r\n        this.emit(\"update\", this.getProgress(), this);\r\n        this.animationFrame = window.requestAnimationFrame(this.loop);\r\n    }\r\n\r\n    /**\r\n     * Cancels animation frame\r\n     */\r\n    public stopLoop() {\r\n        window.cancelAnimationFrame(this.animationFrame);\r\n    }\r\n\r\n    /**\r\n     * Calls a method that affects all animations including the mainAnimation; the method only allows the animation parameter\r\n    */\r\n    public all(method: (animation?: Animation, target?: HTMLElement) => void) {\r\n        method(this.mainAnimation, this.mainElement);\r\n        this.animations.forEach(method);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register the begin event\r\n     */\r\n    protected beginEvent() {\r\n        if (this.getProgress() == 0) {\r\n            let timer: number | void = window.setTimeout(() => {\r\n                this.emit(\"begin\", this);\r\n                timer = window.clearTimeout(timer as number);\r\n            }, this.minDelay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Play Animation\r\n     */\r\n    public play(): Animate {\r\n        let playstate = this.getPlayState();\r\n        this.beginEvent();\r\n        this.all(anim => anim.play());\r\n        this.emit(\"play\", playstate, this);\r\n        this.loop();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause Animation\r\n     */\r\n    public pause(): Animate {\r\n        let playstate = this.getPlayState();\r\n        this.all(anim => anim.pause());\r\n        this.emit(\"pause\", playstate, this);\r\n        this.stopLoop();\r\n        this.animationFrame = undefined;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all Animations\r\n     */\r\n    public reset() {\r\n        this.setProgress(0);\r\n        this.beginEvent();\r\n\r\n        if (this.options.autoplay) this.play();\r\n        else this.pause();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels all Animations\r\n     */\r\n    public cancel() {\r\n        this.all(anim => anim.cancel());\r\n        this.stopLoop();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force complete all Animations\r\n     */\r\n    public finish() {\r\n        this.all(anim => anim.finish());\r\n        this.stopLoop();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels & Clears all Animations\r\n     */\r\n    public stop() {\r\n        this.cancel();\r\n        this.animations.clear();\r\n        while (this.targets.length) this.targets.pop();\r\n        this.mainElement = undefined;\r\n        this.emit(\"stop\");\r\n    }\r\n\r\n    /**\r\n     * Returns an Array of targets\r\n     */\r\n    public getTargets(): Node[] {\r\n        return this.targets;\r\n    }\r\n\r\n    /**\r\n     * Get a specific Animation from an Animate instance\r\n     */\r\n    public getAnimation(element: HTMLElement): Animation {\r\n        return this.animations.get(element);\r\n    }\r\n\r\n    /**\r\n     * Returns the timings of an Animation, given a target\r\n     * E.g. { duration, endDelay, delay, iterations, iterationStart, direction, easing, fill, etc... }\r\n     */\r\n    public getTiming(target: HTMLElement | Animation): AnimationOptions & EffectTiming {\r\n        let animation = target instanceof Animation ? target : this.getAnimation(target);\r\n        let keyframeOptions = this.computedOptions.get(animation) ?? {};\r\n        let timings = animation.effect?.getTiming() ?? {};\r\n        let options = this.getOptions();\r\n\r\n        return { ...DefaultAnimationOptions, ...options, ...timings, ...keyframeOptions };\r\n    }\r\n\r\n    /**\r\n     * Returns the total duration of Animation\r\n     */\r\n    public getTotalDuration(): number {\r\n        return this.totalDuration;\r\n    }\r\n\r\n    /**\r\n     * Returns the current time of the Main Animation\r\n     */\r\n    public getCurrentTime(): number {\r\n        return this.mainAnimation.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Returns the Animation progress as a fraction of the current time / duration * 100\r\n     */\r\n    public getProgress() {\r\n        return (this.getCurrentTime() / this.totalDuration) * 100;\r\n    }\r\n\r\n    /**\r\n     * Return the playback speed of the animation\r\n     */\r\n    public getSpeed(): number {\r\n        return this.mainAnimation.playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Returns the current playing state\r\n     */\r\n    public getPlayState(): \"idle\" | \"running\" | \"paused\" | \"finished\" {\r\n        return this.mainAnimation.playState;\r\n    }\r\n\r\n    /**\r\n     * Get the options of an Animate instance\r\n     */\r\n    public getOptions(): AnimationOptions {\r\n        return this.options;\r\n    }\r\n\r\n    /**\r\n     * Set the current time of the Main Animation\r\n     */\r\n    public setCurrentTime(time: number): Animate {\r\n        this.all(anim => { anim.currentTime = time; });\r\n        this.emit(\"update\", this.getProgress());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the Animation progress as a value from 0 to 100\r\n     */\r\n    public setProgress(percent: number): Animate {\r\n        let time = (percent / 100) * this.totalDuration;\r\n        this.setCurrentTime(time);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the playback speed of an Animation\r\n     */\r\n    public setSpeed(speed: number = 1): Animate {\r\n        this.all(anim => { anim.playbackRate = speed; });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     */\r\n    public on(events: AnimationEvents | EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.on(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     */\r\n    public off(events: AnimationEvents | EventInput, callback?: ListenerCallback, scope?: object): Animate {\r\n        this.emitter.off(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     */\r\n    public emit(events: AnimationEvents | string | any[], ...args: any): Animate {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n\r\n\r\n    /** Returns the Animate options, as JSON  */\r\n    public toJSON(): AnimationOptions {\r\n        return this.getOptions();\r\n    }\r\n\r\n    /**\r\n     * The Symbol.toStringTag well-known symbol is a string valued property that is used\r\n     * in the creation of the default string description of an object.\r\n     * It is accessed internally by the Object.prototype.toString() method.\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return `Animate`;\r\n    }\r\n}\r\n\r\n/** Creates a new Animate instance */\r\nexport const animate = (options: AnimationOptions = {}): Animate => {\r\n    return new Animate(options);\r\n};\r\n\r\nexport class Timeline extends Animate {\r\n    /**\r\n     * A Manager of Animations\r\n     */\r\n    public animations: Manager<HTMLElement, Animation> = new Manager();\r\n    constructor(options: AnimationOptions = {}) {\r\n        super();\r\n        try {\r\n            let { options: animation, ...rest } = options;\r\n            let oldOptions = animation instanceof Animate ? animation.getOptions() : (Array.isArray(animation) ? animation?.[0]?.getOptions() : animation);\r\n            this.options = Object.assign({}, DefaultAnimationOptions, oldOptions, rest);\r\n            this.loop = this.loop.bind(this);\r\n\r\n            let {\r\n                loop,\r\n                delay,\r\n                speed,\r\n                easing,\r\n                endDelay,\r\n                duration,\r\n                direction,\r\n                fillMode,\r\n                onfinish,\r\n                target,\r\n                keyframes,\r\n                autoplay,\r\n                extend,\r\n                ...properties\r\n            } = this.options;\r\n\r\n            this.mainElement = document.createElement(\"div\");\r\n            this.targets = getTargets(target);\r\n            this.properties = properties;\r\n\r\n            let delays = [];\r\n            let len = this.targets.length;\r\n            let animationKeyframe: Keyframe[] | PropertyIndexedKeyframes;\r\n            for (let i = 0; i < len; i++) {\r\n                let target = this.targets[i] as HTMLElement;\r\n                let animationOptions: AnimationOptions = {\r\n                    easing: typeof easing == \"string\" ? getEase(easing) : easing,\r\n                    iterations: loop === true ? Infinity : (loop as number),\r\n                    direction,\r\n                    endDelay,\r\n                    duration,\r\n                    delay,\r\n                    fill: fillMode,\r\n                    ...extend\r\n                };\r\n\r\n                // Accept keyframes as a keyframes Object, or a method,\r\n                // if there are no animations in the keyframes array,\r\n                // uses css properties from the options object\r\n                let arrKeyframes = computeValue((keyframes as Keyframe[]), [i, len, target], this);\r\n                animationKeyframe = arrKeyframes.length ? arrKeyframes :\r\n                    (this.properties as PropertyIndexedKeyframes);\r\n\r\n                // Allows the use of functions as the values, for both the keyframes and the animation object\r\n                // It adds the capability of advanced stagger animation, similar to the anime js stagger functions\r\n                animationOptions = mapObject(animationOptions, [i, len, target], this);\r\n                if (!(arrKeyframes.length > 0))\r\n                    animationKeyframe = mapObject(animationKeyframe, [i, len, target], this);\r\n\r\n                // Set the Animate classes duration to be the Animation with the largest totalDuration\r\n                let tempDurations = animationOptions.delay +\r\n                    (animationOptions.duration * animationOptions.iterations) +\r\n                    animationOptions.endDelay;\r\n                if (this.totalDuration < tempDurations) this.totalDuration = tempDurations;\r\n\r\n                // Add animation to the Animations Set\r\n                let animation = target.animate(animationKeyframe, animationOptions as KeyframeAnimationOptions);\r\n\r\n                // Support for on finish\r\n                animation.onfinish = () => {\r\n                    typeof onfinish == \"function\" && onfinish.call(this, target, i, len, animation);\r\n                    this.emit(\"finish\", target, i, len, animation);\r\n                };\r\n\r\n                // The calculated options for each individual option\r\n                this.computedOptions.set(animation, animationOptions);\r\n                this.animations.set(target, animation);\r\n                delays.push(animationOptions.delay);\r\n            }\r\n\r\n            this.mainAnimation = this.mainElement.animate([\r\n                { opacity: \"0\" },\r\n                { opacity: \"1\" }\r\n            ], {\r\n                // Why waste performance on an animation no one can see?\r\n                duration: this.totalDuration,\r\n                easing: \"linear\"\r\n            });\r\n\r\n            this.minDelay = Math.min(...delays);\r\n            this.setSpeed(speed);\r\n            if (autoplay) this.play();\r\n            else this.pause();\r\n\r\n            this.promise = this.newPromise();\r\n            this.mainAnimation.onfinish = () => {\r\n                this.emit(\"complete\", this);\r\n                this.stopLoop();\r\n            };\r\n        } catch (err) {\r\n            this.emit(\"error\", err);\r\n        }\r\n    }\r\n    public add(options: AnimationOptions) {\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default animate;", "import { animate } from \"@okikio/native\";\r\nlet anim = animate({\r\n    target: \".div\",\r\n    keyframes(index, total) {\r\n        return [\r\n            { transform: \"translateX(0px)\", opacity: 0.1 },\r\n            { transform: \"translateX(300px)\", opacity: 0.2 + ((index + 1) / total) }\r\n        ]\r\n    },\r\n    // transform: [\"translateX(0px)\", \"translateX(300px)\"],\r\n    // opacity(index, total, element) {\r\n    //     return [0, ((index + 1) / total)];\r\n    // },\r\n\r\n    // It is best to use the onfinish() method, but in this situation fillMode works best\r\n    fillMode: \"both\",\r\n    // onfinish(element, index, total) {\r\n    //     element.style.opacity = `${((index + 1) / total)}`;\r\n    //     element.style.transform = \"translateX(300px)\";\r\n    // },\r\n\r\n    easing: \"out-cubic\",\r\n    duration(index: number) {\r\n        return (index + 1) * 500;\r\n    },\r\n    loop: 5,\r\n    speed: 1.5,\r\n    direction: \"alternate\",\r\n    delay(index: number) {\r\n        return ((index + 1) * 500) / 2;\r\n    },\r\n    autoplay: true\r\n});\r\n\r\nlet el: HTMLElement = document.querySelector(\".info\");\r\nlet backupInfo = el.textContent;\r\nlet info = backupInfo;\r\nanim.on({\r\n    begin() {\r\n        if (el) {\r\n            info = backupInfo;\r\n            el.textContent = info;\r\n            el.style.color = \"initial\";\r\n        }\r\n    }\r\n})\r\nanim.on(\"complete\", () => {\r\n    if (el) {\r\n        info = \"Done.\";\r\n        el.textContent = info;\r\n        el.style.color = \"red\";\r\n\r\n        console.log(info);\r\n    }\r\n});\r\n\r\nlet scrub = document.getElementById('scrub') as HTMLInputElement;\r\nscrub.addEventListener('input', e => {\r\n    var percent = +(e.target as HTMLInputElement).value;\r\n    anim.setProgress(percent);\r\n    anim.pause();\r\n});\r\n\r\nlet progressSpan = document.querySelector(\".progress\");\r\nanim.on(\"update\", progress => {\r\n    scrub.value = `` + progress;\r\n    progressSpan && (progressSpan.textContent = `${Math.round(progress)}%`);\r\n});\r\n\r\nscrub.addEventListener('change', () => {\r\n    let progress = anim.getProgress();\r\n    anim.all((a) => {\r\n        if (a.playState != \"finished\" && progress < 100) {\r\n            console.log({ playstate: a.playState, currentTime: a.currentTime, progress });\r\n            console.log(a.timeline);\r\n        }\r\n    })\r\n    // if (Math.round(anim.getProgress()) >= 100) {\r\n    //     anim.finish();\r\n    //     return false;\r\n    // }\r\n    // anim.play();\r\n});\r\n\r\n\r\nlet playtoggle = document.querySelector(\".playtoggle\");\r\nif (playtoggle) {\r\n    playtoggle.addEventListener(\"click\", () => {\r\n        let state = anim.getPlayState();\r\n        if (state === \"running\") anim.pause();\r\n        else if (state === \"finished\") anim.reset();\r\n        else {\r\n            anim.play();\r\n        }\r\n        console.log(state);\r\n    });\r\n}\r\n\r\n/* Target Section */\r\n// CSS Selector Demo\r\n(() => {\r\n    let containerSel = \".css-selector-demo\";\r\n    let anim = animate({\r\n        target: `${containerSel} .el`,\r\n        transform: [\"translateX(0px)\", \"translateX(250px)\"],\r\n        onfinish(element) {\r\n            element.style.transform = \"translateX(250px)\";\r\n        },\r\n        duration: 500,\r\n        autoplay: false\r\n    });\r\n\r\n    let container = document.querySelector(containerSel);\r\n    container.addEventListener(\"click\", () => {\r\n        anim.reset();\r\n        anim.play();\r\n    });\r\n})();\r\n\r\n// DOM Node / Nodelist Demo\r\n(() => {\r\n    let containerSel = \".dom-node-demo\";\r\n    let DOMNodes = document.querySelectorAll(`${containerSel} .el`);\r\n    let anim = animate({\r\n        target: DOMNodes,\r\n        transform: [\"translateX(0px)\", \"translateX(250px)\"],\r\n        onfinish(element) {\r\n            element.style.transform = \"translateX(250px)\";\r\n        },\r\n        duration: 500,\r\n        autoplay: false\r\n    });\r\n\r\n    let container = document.querySelector(containerSel);\r\n    container.addEventListener(\"click\", () => {\r\n        anim.reset();\r\n        anim.play();\r\n    });\r\n})();\r\n\r\n\r\n// Array Demo\r\n(() => {\r\n    let containerSel = \".array-demo\";\r\n    let el = (num: number) => `${containerSel} .el-0${num}`;\r\n    let anim = animate({\r\n        target: [`${containerSel} .el-01`, el(2), el(3),\r\n        // These two elements don't exist, so, @okikio/animate ignores theme\r\n        el(4), el(5)],\r\n        transform: [\"translateX(0px)\", \"translateX(250px)\"],\r\n        onfinish(element) {\r\n            element.style.transform = \"translateX(250px)\";\r\n        },\r\n        autoplay: false\r\n    });\r\n\r\n    let container = document.querySelector(containerSel);\r\n    container.addEventListener(\"click\", () => {\r\n        anim.reset();\r\n        anim.play();\r\n    });\r\n})();\r\n\r\n\r\n\r\n/* Properties Section */\r\n// CSS Properties Demo\r\n(() => {\r\n    let containerSel = \".css-properties-demo\";\r\n    let anim = animate({\r\n        target: `${containerSel} .el`,\r\n        backgroundColor: [\"#616aff\", \"#fff\"],\r\n        left: [\"0px\", \"240px\"],\r\n        borderRadius: ['0%', '50%'],\r\n        onfinish(element) {\r\n            let { style } = element;\r\n            style.backgroundColor = \"#fff\";\r\n            style.left = \"240px\";\r\n            style.borderRadius = '50%';\r\n        },\r\n        easing: \"in-out-quad\",\r\n        autoplay: false\r\n    });\r\n\r\n    let container = document.querySelector(containerSel);\r\n    container.addEventListener(\"click\", () => {\r\n        anim.reset();\r\n        anim.play();\r\n    });\r\n})();\r\n\r\n// CSS Transforms Demo\r\n(() => {\r\n    let containerSel = \".css-transform-demo\";\r\n    let anim = animate({\r\n        target: `${containerSel} .el`,\r\n        transform: [`translateX(0) scale(1) rotate(0)`, `translateX(250px) scale(2) rotate(1turn)`],\r\n        onfinish(element) {\r\n            element.style.transform = `translateX(250px) scale(2) rotate(1turn)`;\r\n        },\r\n        easing: \"in-out-quad\",\r\n        autoplay: false\r\n    });\r\n\r\n    let container = document.querySelector(containerSel);\r\n    container.addEventListener(\"click\", () => {\r\n        anim.reset();\r\n        anim.play();\r\n    });\r\n})();\r\n\r\n\r\n// SVG Attributes Demo\r\n(() => {\r\n    let containerSel = \".svg-attributes-demo\";\r\n    var pathEl = document.querySelector(`${containerSel} path`);\r\n\r\n    let anim = animate({\r\n        target: pathEl,\r\n        strokeDashoffset: [4000, 0],\r\n        loop: true,\r\n        direction: \"alternate\",\r\n        easing: \"in-out-expo\",\r\n        autoplay: false\r\n    });\r\n\r\n    let container = document.querySelector(containerSel);\r\n    container.addEventListener(\"click\", () => {\r\n        // anim.reset(); // You can't reset an infinitely looped animation\r\n        if (anim.getPlayState() === \"running\") anim.pause();\r\n        else anim.play();\r\n    });\r\n\r\n    anim.on(\"update\", () => {\r\n        console.log(\"Go\")\r\n    });\r\n})();\r\n"],
  "mappings": "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",
  "names": []
}
