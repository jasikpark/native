{
  "version": 3,
  "sources": ["packages/manager/src/api.ts", "packages/emitter/src/api.ts", "packages/animate/src/builtin-effects.ts", "packages/animate/src/css-properties.ts", "packages/animate/src/api.ts", "packages/native/src/config.ts", "packages/native/src/manager.ts", "packages/native/src/url.ts", "packages/native/src/service.ts", "packages/native/src/history.ts", "node_modules/.pnpm/path-to-regexp@6.2.0/node_modules/path-to-regexp/src/index.ts", "packages/native/src/page.ts", "packages/native/src/transition.ts", "packages/native/src/app.ts", "packages/native/src/pjax.ts", "packages/native/src/router.ts", "build/ts/transitions/Fade.ts", "build/ts/transitions/BigTransition.ts", "build/ts/transitions/Slide.ts", "build/ts/services/Navbar.ts", "build/ts/animate.ts", "build/ts/main.ts"],
  "sourcesContent": ["/**\r\n * Acts as an enhanced version of the Map class with new features and changed behavior for convenience\r\n *\r\n * @typeParam K - the type of keys to store use to store values\r\n * @typeParam V - the type of values to store\r\n * */\r\nexport class Manager<K, V> {\r\n\t/** For backward compatability and performance reasons Manager use Map to store data */\r\n\tpublic map: Map<K, V>;\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/** Returns the Manager classes base Map */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/** Get a value stored in the Manager */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/** Returns the keys of all items stored in the Manager as an Array */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\t/** Returns the values of all items stored in the Manager as an Array */\r\n\tpublic values(): Array<V> {\r\n\t\treturn Array.from(this.map.values());\r\n\t}\r\n\r\n\t/** Set a value to the Manager using a key */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\tlet size = this.size;\r\n\t\t// @ts-ignore\r\n\t\tlet num: K = size as K;\r\n\t\tthis.set(num, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Returns the total number of items stored in the Manager */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** An alias for size */\r\n\tpublic get length(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\t/** Returns the last item in the Manager who's index is a certain distance from the last item in the Manager */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns true if an element in the Map object existed and has been removed, or false if the element does not exist */\r\n\tpublic delete(key: K): boolean {\r\n\t\treturn this.map.delete(key);\r\n\t}\r\n\r\n\t/** Removes a value stored in the Manager via a key, returns the Manager class, allowing for chains */\r\n\tpublic remove(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Clear the Manager of all its contents */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Checks if the Manager contains a certain key */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/** Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order. */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/** Iterates through the Managers contents, calling a callback function every iteration */\r\n\tpublic forEach(\r\n\t\tcallback: (value?: V, key?: K, map?: Map<K, V>) => void,\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Allows for iteration via for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators] */\r\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\r\n\t\treturn this.entries();\r\n\t}\r\n}\r\n\r\n/**\r\n * Calls the method of a certain name for all items that are currently installed\r\n */\r\nexport const methodCall = (manager: Manager<any, any>, method: string, ...args: any): void => {\r\n\tmanager.forEach((item) => {\r\n\t\t// @ts-ignore\r\n\t\titem[method](...args);\r\n\t});\r\n};\r\n\r\n/**\r\n * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n */\r\nexport const asyncMethodCall = async (manager: Manager<any, any>, method: string, ...args: any): Promise<void> => {\r\n\tfor (let [, item] of manager) {\r\n\t\t// @ts-ignore\r\n\t\tawait item[method](...args);\r\n\t}\r\n};\r\n\r\nexport default Manager;\r\n", "import { Manager, methodCall } from \"@okikio/manager\";\r\n\r\n/**\r\n * Represents a listener callback function\r\n */\r\nexport type TypeListenerCallback = ((...args: any) => void);\r\n\r\n/** Represents a new event listener consisting of properties like: callback, scope, name */\r\nexport interface IListener {\r\n    readonly callback: TypeListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Creates a new listener based on {@link IListener | IListener}\r\n */\r\nexport const newListener = ({\r\n    callback = () => { },\r\n    scope = null,\r\n    name = \"event\",\r\n}: IListener): IListener => ({ callback, scope, name });\r\n\r\n/** Represents a new event  */\r\nexport class Event extends Manager<number, IListener> {\r\n    /** The name of the event */\r\n    public name: string;\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\n/**\r\n * The types of values `EventEmitter.prototype.on(...), EventEmitter.prototype.once(...), and EventEmitter.prototype.off(...)` accept\r\n */\r\nexport type TypeEventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An Event Emitter\r\n * */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /** Gets event, if event doesn't exist create a new one */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Creates a listener and adds it to an event */\r\n    public newListener(\r\n        name: string,\r\n        callback: TypeListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(newListener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n    /** Adds a listener to a given event */\r\n    public on(\r\n        events: TypeEventInput,\r\n        callback?: TypeListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (\r\n            typeof events == \"undefined\" ||\r\n            events == null\r\n        ) return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: TypeListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as TypeListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            _name = isObject ? key : events[key];\r\n            if (isObject) _callback = events[key];\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Removes a listener from an event */\r\n    public removeListener(\r\n        name: string,\r\n        callback: TypeListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let listener = newListener({ name, callback, scope });\r\n            event.forEach((value: IListener, i: number) => {\r\n                if (\r\n                    value.callback === listener.callback &&\r\n                    value.scope === listener.scope\r\n                ) return event.remove(i);\r\n            });\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n    /** Remove a listener from a given event, or just completely remove an event */\r\n    public off(\r\n        events: TypeEventInput,\r\n        callback?: TypeListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (\r\n            typeof events == \"undefined\" ||\r\n            events == null\r\n        ) return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: TypeListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as TypeListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            _name = isObject ? key : events[key];\r\n            if (isObject) _callback = events[key];\r\n\r\n            if (typeof _callback === \"function\") {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.remove(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a one time event listener for an event\r\n     */\r\n    public once(\r\n        events: TypeEventInput,\r\n        callback?: TypeListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (\r\n            typeof events == \"undefined\" ||\r\n            events == null\r\n        ) return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            let _name: string = isObject ? key : events[key];\r\n            let _callback: TypeListenerCallback = isObject ? events[key] : (callback as TypeListenerCallback);\r\n            let _scope: object = isObject ? callback : scope;\r\n            let onceFn: TypeListenerCallback = (...args) => {\r\n                _callback.apply(_scope, args);\r\n                this.removeListener(_name, onceFn, _scope);\r\n            };\r\n\r\n            this.newListener(_name, onceFn, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Call all listeners within an event */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (\r\n            typeof events == \"undefined\" ||\r\n            events == null\r\n        ) return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: IListener) => {\r\n                    let { callback, scope } = listener;\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n    /** Clears events and event listeners */\r\n    public clear() {\r\n        methodCall(this, \"clear\");\r\n        super.clear();\r\n        return this;\r\n    }\r\n}\r\n\r\nexport default EventEmitter;\r\n", "/**\r\n * Convert the words \"from\", and \"to\" as well as percentage or numbers to offset value between 0 and 1\r\n */\r\nexport const parseOffset = (input: string | number): number => {\r\n    if (typeof input == \"string\") {\r\n        if (input.includes(\"%\"))\r\n            return parseFloat(input) / 100;\r\n        else if (input == \"from\")\r\n            return 0;\r\n        else if (input == \"to\")\r\n            return 1;\r\n        else\r\n            return parseFloat(input);\r\n    }\r\n\r\n    return input;\r\n};\r\n\r\n/**\r\n * Allows you to quickly convert CSS like JSON into keyframes\r\n *\r\n * @param input - CSS style JSON; check the example to understand what I mean\r\n *\r\n * @example\r\n * ```typescript\r\n * let keyframes = KeyframeParse({\r\n *     \"from, 50%, to\": {\r\n *         opacity: 1\r\n *     },\r\n *\r\n *     \"25%, 0.7\": {\r\n *         opacity: 0\r\n *     }\r\n * });\r\n *\r\n * console.log(keyframes);\r\n * //= [\r\n * //=   { opacity: 1, offset: 0 },\r\n * //=   { opacity: 0, offset: 0.25 },\r\n * //=   { opacity: 1, offset: 0.5 },\r\n * //=   { opacity: 0, offset: 0.7 },\r\n * //=   { opacity: 1, offset: 1 }\r\n * //= ]\r\n * ```\r\n */\r\nexport const KeyframeParse = (input: object): Keyframe[] => {\r\n    // Set removes duplicate Keyframes for the same offset\r\n    let results = new Set<Keyframe>();\r\n    let keys = Object.keys(input);\r\n    let len = keys.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let key = \"\" + keys[i];\r\n        let value = input[key];\r\n        let offsets = key.split(\",\");\r\n        let offsetLen = offsets.length;\r\n\r\n        for (let j = 0; j < offsetLen; j++) {\r\n            let offset = parseOffset(offsets[j]);\r\n            results.add({ ...value, offset });\r\n        }\r\n    }\r\n\r\n    return [...results].sort((a, b) => {\r\n        return a.offset - b.offset;\r\n    });\r\n};\r\n\r\n/**\r\n * I don't really want to put in the effort to create a complete list, so instead just look through the `animate.css` github and copy and paste the effects you need, into using a CSS Keyframe style JSON object, make sure to read the documentation for {@link KeyframeParse}\r\n *\r\n * or\r\n *\r\n * if you just need some quick effects go to [github.com/wellyshen/use-web-animations/](https://github.com/wellyshen/use-web-animations/tree/master/src/animations) and copy the `keyframes` array for the effect you want, remember to say thank you to @wellyshen for all his hardwork, \uD83D\uDE02\r\n *\r\n * @internal\r\n*/\r\nexport const EFFECTS = {};\r\n", "import { mapObject } from \"./api\";\r\nimport { TypeSingleValueCSSProperty, ICSSComputedTransformableProperties } from \"./types\";\r\n\r\n/**\r\n * Returns a closure Function, which adds a unit to numbers but simply returns strings with no edits assuming the value has a unit if it's a string\r\n *\r\n * @param unit - the default unit to give the CSS Value\r\n * @returns\r\n * if value already has a unit (we assume the value has a unit if it's a string), we return it;\r\n * else return the value plus the default unit\r\n */\r\n export const addCSSUnit = (unit: string = \"\") => {\r\n    return (value: string | number) => typeof value == \"string\" ? value : `${value}${unit}`;\r\n}\r\n\r\n/** Function doesn't add any units by default */\r\nexport const UnitLess = addCSSUnit();\r\n\r\n/** Function adds \"px\" unit to numbers */\r\nexport const UnitPX = addCSSUnit(\"px\");\r\n\r\n/** Function adds \"deg\" unit to numbers */\r\nexport const UnitDEG = addCSSUnit(\"deg\");\r\n\r\n/**\r\n * Convert the input to an array\r\n * For strings split them at commas\r\n * For array do nothing\r\n * For everything else wrap the input in an array\r\n */\r\nexport const toArr = (input: any): any[] => {\r\n    if (Array.isArray(input) || typeof input == \"string\") {\r\n        if (typeof input == \"string\") input = input.split(\",\");\r\n        return input;\r\n    }\r\n\r\n    return [input];\r\n}\r\n\r\n/**\r\n * Checks if value is valid/truthy; it counts empty arrays and strings as falsey,\r\n * as well as null and undefined everything else is valid\r\n *\r\n * _**Note:** 0 counts as valid_\r\n *\r\n * @param value - anything\r\n * @returns true or false\r\n */\r\nexport const isValid = (value: any) => {\r\n    if (Array.isArray(value) || typeof value == \"string\")\r\n        return Boolean(value.length);\r\n    return value != null && value != undefined;\r\n}\r\n\r\n/**\r\n * Returns a closure function, which adds units to numbers, strings or arrays of both\r\n *\r\n * @param unit - a unit function to use to add units to {@link TypeSingleValueCSSProperty | TypeSingleValueCSSProperty's }\r\n * @returns\r\n * if input is a string split it into an array at the comma's, and add units\r\n * else if the input is a number add the default units\r\n * otherwise if the input is an array of both add units according to {@link addCSSUnit}\r\n */\r\nexport const CSSValue = (unit: typeof UnitLess) => {\r\n    return (input: TypeSingleValueCSSProperty) => {\r\n        return isValid(input) ? toArr(input).map(val => {\r\n            if (typeof val != \"number\" && typeof val != \"string\")\r\n                return val;\r\n\r\n            // Basically if you can convert it to a number try to,\r\n            // otherwise just return whatever you can\r\n            let num = Number(val);\r\n            let value = Number.isNaN(num) ? (typeof val == \"string\" ? val.trim() : val) : num;\r\n            return unit(value); // Add the default units\r\n        }) : [];\r\n    };\r\n}\r\n\r\n/**\r\n * Flips the rows and columns of 2-dimensional arrays\r\n *\r\n * Read more on [underscorejs.org](https://underscorejs.org/#zip) & [lodash.com](https://lodash.com/docs/4.17.15#zip)\r\n *\r\n * @example\r\n * ```ts\r\n * transpose(\r\n *      ['moe', 'larry', 'curly'],\r\n *      [30, 40, 50],\r\n *      [true, false, false]\r\n * );\r\n * // [\r\n * //     [\"moe\", 30, true],\r\n * //     [\"larry\", 40, false],\r\n * //     [\"curly\", 50, false]\r\n * // ]\r\n * ```\r\n * @param [...args] - the arrays to process as a set of arguments\r\n * @returns\r\n * returns the new array of grouped elements\r\n */\r\nexport const transpose = (...args: TypeSingleValueCSSProperty[] | TypeSingleValueCSSProperty[][]) => {\r\n    let largestArrLen = 0;\r\n    args = args.map(arr => {\r\n        // Convert all values in arrays to an array\r\n        // This ensures that `arrays` is an array of arrays\r\n        let result = toArr(arr);\r\n\r\n        // Finds the largest array\r\n        let len = result.length;\r\n        if (len > largestArrLen) largestArrLen = len;\r\n        return result;\r\n    });\r\n\r\n    // Flip the rows and columns of arrays\r\n    let result = [];\r\n    let len = args.length;\r\n    for (let col = 0; col < largestArrLen; col++) {\r\n        result[col] = [];\r\n\r\n        for (let row = 0; row < len; row++) {\r\n            let val = args[row][col];\r\n            if (isValid(val))\r\n                result[col][row] = val;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Takes `TypeSingleValueCSSProperty` or an array of `TypeSingleValueCSSProperty` and adds units approriately\r\n *\r\n * @param arr - array of numbers, strings and/or an array of array of both e.g. ```[[25, \"50px\", \"60%\"], \"25, 35, 60%\", 50]```\r\n * @param unit - a unit function to use to add units to {@link TypeSingleValueCSSProperty | TypeSingleValueCSSProperty's }\r\n * @returns\r\n * an array of an array of strings with units\r\n * e.g.\r\n * ```ts\r\n * [\r\n *      [ '25px', '35px', ' 60%' ],\r\n *      [ '50px', '60px', '70px' ]\r\n * ]\r\n * ```\r\n */\r\nexport const CSSArrValue = (arr: TypeSingleValueCSSProperty | TypeSingleValueCSSProperty[], unit: typeof UnitLess) => {\r\n    // This is for the full varients of the transform function as well as the 3d varients\r\n    // zipping the `CSSValue` means if a user enters a string, it will treat each value (seperated by a comma) in that\r\n    // string as a seperate transition state\r\n    return toArr(arr).map(CSSValue(unit)) as TypeSingleValueCSSProperty[];\r\n}\r\n\r\nexport const TransformFunctionNames = [\r\n    \"translate\",\r\n    \"translate3d\",\r\n    \"translateX\",\r\n    \"translateY\",\r\n    \"translateZ\",\r\n    \"rotate\",\r\n    \"rotate3d\",\r\n    \"rotateX\",\r\n    \"rotateY\",\r\n    \"rotateZ\",\r\n    \"scale\",\r\n    \"scale3d\",\r\n    \"scaleX\",\r\n    \"scaleY\",\r\n    \"scaleZ\",\r\n    \"skew\",\r\n    \"skewX\",\r\n    \"skewY\",\r\n    \"perspective\"\r\n];\r\n\r\n/**\r\n * Creates the transform property text\r\n */\r\nexport const createTransformProperty = (arr) => {\r\n    let result = \"\";\r\n    let len = TransformFunctionNames.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let name = TransformFunctionNames[i];\r\n        let value = arr[i];\r\n        if (isValid(value))\r\n            result += `${name}(${Array.isArray(value) ? value.join(\", \") : value}) `;\r\n    }\r\n\r\n    return result.trim();\r\n}\r\n\r\n/** Parses CSSValues without adding any units */\r\nexport const UnitLessCSSValue = CSSValue(UnitLess);\r\n\r\n/** Parses CSSValues and adds the \"px\" unit if required */\r\nexport const UnitPXCSSValue = CSSValue(UnitPX);\r\n\r\n/** Parses CSSValues and adds the \"deg\" unit if required */\r\nexport const UnitDEGCSSValue = CSSValue(UnitDEG);\r\n\r\n/**\r\n * Removes the need for the full transform statement in order to use translate, rotate, scale, skew, or perspective including their X, Y, Z, and 3d varients\r\n * Also, adds the ability to use single string or number values for transform functions\r\n *\r\n * _**Note**: the `transform` animation option will override all transform function properties_\r\n *\r\n * @param properties - the CSS properties to transform\r\n *\r\n * @example\r\n * ```ts\r\n * ParseTransformableCSSProperties({\r\n *      // It will automatically add the \"px\" units for you, or you can write a string with the units you want\r\n *      translate3d: [\r\n *          \"25, 35, 60%\",\r\n *          [50, \"60px\", 70],\r\n *          [\"70\", 50]\r\n *      ],\r\n *      translate: \"25, 35, 60%\",\r\n *      translateX: [50, \"60px\", \"70\"],\r\n *      translateY: [\"50, 60\", \"60\"], // Note: this will actually result in an error, make sure to pay attention to where you are putting strings and commas\r\n *      translateZ: 0,\r\n *      perspective: 0,\r\n *      opacity: \"0, 5\",\r\n *      scale: [\r\n *          [1, \"2\"],\r\n *          [\"2\", 1]\r\n *      ],\r\n *      rotate3d: [\r\n *          [1, 2, 5, \"3deg\"], // The last value in the array must be a string with units for rotate3d\r\n *          [2, \"4\", 6, \"45turn\"],\r\n *          [\"2\", \"4\", \"6\", \"-1rad\"]\r\n *      ]\r\n * })\r\n *\r\n * //= {\r\n * //=   transform: [\r\n * //=       // `translateY(50, 60)` will actually result in an error\r\n * //=       'translate(25px) translate3d(25px, 35px, 60%) translateX(50px) translateY(50, 60) translateZ(0px) rotate3d(1, 2, 5, 3deg) scale(1, 2) perspective(0px)',\r\n * //=       'translate(35px) translate3d(50px, 60px, 70px) translateX(60px) translateY(60px) rotate3d(2, 4, 6, 45turn) scale(2, 1)',\r\n * //=       'translate(60%) translate3d(70px, 50px) translateX(70px) rotate3d(2, 4, 6, -1rad)'\r\n * //=   ],\r\n * //=   opacity: [ '0', '5' ]\r\n * //= }\r\n * ```\r\n *\r\n * @returns\r\n * an object with a properly formatted `transform` and `opactity`, as well as other unformatted CSS properties\r\n * ```\r\n */\r\nexport const ParseTransformableCSSProperties = (properties: ICSSComputedTransformableProperties) => {\r\n    let {\r\n        perspective,\r\n        rotate,\r\n        rotate3d,\r\n        rotateX,\r\n        rotateY,\r\n        rotateZ,\r\n        translate,\r\n        translate3d,\r\n        translateX,\r\n        translateY,\r\n        translateZ,\r\n        scale,\r\n        scale3d,\r\n        scaleX,\r\n        scaleY,\r\n        scaleZ,\r\n        skew,\r\n        skewX,\r\n        skewY,\r\n        ...rest\r\n    } = properties;\r\n\r\n    translate = CSSArrValue(translate, UnitPX);\r\n    translate3d = CSSArrValue(translate3d, UnitPX);\r\n    translateX = UnitPXCSSValue(translateX);\r\n    translateY = UnitPXCSSValue(translateY);\r\n    translateZ = UnitPXCSSValue(translateZ);\r\n\r\n    rotate = CSSArrValue(rotate, UnitDEG);\r\n    rotate3d = CSSArrValue(rotate3d, UnitLess);\r\n    rotateX = UnitDEGCSSValue(rotateX);\r\n    rotateY = UnitDEGCSSValue(rotateY);\r\n    rotateZ = UnitDEGCSSValue(rotateZ);\r\n\r\n    scale = CSSArrValue(scale, UnitLess);\r\n    scale3d = CSSArrValue(scale3d, UnitLess);\r\n    scaleX = UnitLessCSSValue(scaleX);\r\n    scaleY = UnitLessCSSValue(scaleY);\r\n    scaleZ = UnitLessCSSValue(scaleZ);\r\n\r\n    skew = CSSArrValue(skew, UnitDEG);\r\n    skewX = UnitDEGCSSValue(skewX);\r\n    skewY = UnitDEGCSSValue(skewY);\r\n\r\n    perspective = UnitPXCSSValue(perspective);\r\n\r\n    let transform = transpose(\r\n        translate, translate3d, translateX, translateY, translateZ,\r\n        rotate, rotate3d, rotateX, rotateY, rotateZ,\r\n        scale, scale3d, scaleX, scaleY, scaleZ,\r\n        skew, skewX, skewY,\r\n        perspective\r\n    ).map(createTransformProperty);\r\n\r\n    // Wrap non array CSS property values in an array\r\n    rest = mapObject(rest, value => [].concat(value).map(v => `` + v));\r\n    return Object.assign({},\r\n        isValid(transform) ? { transform } : null,\r\n        rest);\r\n}\r\n\r\n/**\r\n * Similar to {@link ParseTransformableCSSProperties} except it transforms the CSS properties in each Keyframe\r\n * @param keyframes - an array of keyframes with transformable CSS properties\r\n * @returns\r\n * an array of keyframes, with transformed CSS properties\r\n */\r\nexport const ParseTransformableCSSKeyframes = (keyframes: ICSSComputedTransformableProperties[]) => {\r\n    return keyframes.map(properties => {\r\n        let {\r\n            translate,\r\n            translate3d,\r\n            translateX,\r\n            translateY,\r\n            translateZ,\r\n            rotate,\r\n            rotate3d,\r\n            rotateX,\r\n            rotateY,\r\n            rotateZ,\r\n            scale,\r\n            scale3d,\r\n            scaleX,\r\n            scaleY,\r\n            scaleZ,\r\n            skew,\r\n            skewX,\r\n            skewY,\r\n            perspective,\r\n\r\n            easing,\r\n            iterations,\r\n            offset,\r\n            ...rest\r\n        } = properties;\r\n\r\n        translate = UnitPXCSSValue(translate as TypeSingleValueCSSProperty);\r\n        translate3d = UnitPXCSSValue(translate3d as TypeSingleValueCSSProperty);\r\n        translateX = UnitPXCSSValue(translateX)[0];\r\n        translateY = UnitPXCSSValue(translateY)[0];\r\n        translateZ = UnitPXCSSValue(translateZ)[0];\r\n\r\n        rotate = UnitDEGCSSValue(rotate as TypeSingleValueCSSProperty);\r\n        rotate3d = UnitLessCSSValue(rotate3d as TypeSingleValueCSSProperty);\r\n        rotateX = UnitDEGCSSValue(rotateX)[0];\r\n        rotateY = UnitDEGCSSValue(rotateY)[0];\r\n        rotateZ = UnitDEGCSSValue(rotateZ)[0];\r\n\r\n        scale = UnitLessCSSValue(scale as TypeSingleValueCSSProperty);\r\n        scale3d = UnitLessCSSValue(scale3d as TypeSingleValueCSSProperty);\r\n        scaleX = UnitLessCSSValue(scaleX)[0];\r\n        scaleY = UnitLessCSSValue(scaleY)[0];\r\n        scaleZ = UnitLessCSSValue(scaleZ)[0];\r\n\r\n        skew = UnitDEGCSSValue(skew as TypeSingleValueCSSProperty);\r\n        skewX = UnitDEGCSSValue(skewX)[0];\r\n        skewY = UnitDEGCSSValue(skewY)[0];\r\n\r\n        perspective = UnitPXCSSValue(perspective)[0];\r\n\r\n        return [\r\n            rest,\r\n            translate, translate3d, translateX, translateY, translateZ,\r\n            rotate, rotate3d, rotateX, rotateY, rotateZ,\r\n            scale, scale3d, scaleX, scaleY, scaleZ,\r\n            skew, skewX, skewY,\r\n            perspective\r\n        ];\r\n    }).map(([rest, ...transformFunctions]) => {\r\n        let transform = createTransformProperty(transformFunctions);\r\n        return Object.assign({},\r\n            isValid(transform) ? { transform } : null,\r\n            rest);\r\n    });\r\n}", "import { EventEmitter, TypeEventInput, TypeListenerCallback } from \"@okikio/emitter\";\r\nimport { Manager } from \"@okikio/manager\";\r\n\r\nimport { TypeAnimationTarget, TypeAnimationOptionTypes, TypeCallbackArgs, TypeComputedAnimationOptions, IAnimationOptions, TypeComputedOptions, TypeKeyFrameOptionsType, TypeCSSLikeKeyframe, ICSSComputedTransformableProperties, TypeAnimationEvents, TypePlayStates } from \"./types\";\r\nimport { KeyframeParse, parseOffset } from \"./builtin-effects\";\r\nimport { isValid, ParseTransformableCSSProperties, ParseTransformableCSSKeyframes } from \"./css-properties\";\r\n\r\nexport * from \"./types\";\r\nexport * from \"./builtin-effects\";\r\nexport * from \"./css-properties\";\r\n\r\n/* DOM */\r\nexport const getElements = (selector: string | Node): Node[] => {\r\n    return typeof selector === \"string\" ? Array.from(document.querySelectorAll(selector as string)) : [selector];\r\n};\r\n\r\nexport const flatten = (arr: TypeAnimationTarget[]) => [].concat(...arr);\r\nexport const getTargets = (targets: TypeAnimationTarget): Node[] => {\r\n    if (Array.isArray(targets)) {\r\n        return flatten((targets as TypeAnimationTarget[]).map(getTargets));\r\n    }\r\n    if (typeof targets == \"string\" || targets instanceof Node)\r\n        return getElements(targets);\r\n    if (targets instanceof NodeList || targets instanceof HTMLCollection)\r\n        return Array.from(targets);\r\n    return [];\r\n};\r\n\r\n/* VALUES */\r\nexport const computeOption = (value: TypeAnimationOptionTypes, args: TypeCallbackArgs, context: Animate): TypeComputedAnimationOptions => {\r\n    if (typeof value === \"function\") {\r\n        return value.apply(context, args);\r\n    } else return value;\r\n};\r\n\r\n/**\r\n * Acts like array.map(...) but for functions\r\n */\r\nexport const mapObject = (obj: object, fn: (value, key, obj) => any) => {\r\n    let keys = Object.keys(obj);\r\n    let key, value, result = {};\r\n    for (let i = 0, len = keys.length; i < len; i++) {\r\n        key = keys[i];\r\n        value = obj[key];\r\n        result[key] = fn(value, key, obj);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nexport const mapAnimationOptions = (options: IAnimationOptions, args: TypeCallbackArgs, animate: Animate): TypeComputedOptions => {\r\n    return mapObject(options, (value) => computeOption(value, args, animate));\r\n};\r\n\r\n/**\r\n * From: [https://easings.net]\r\n *\r\n * Read More about easings on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/easing)\r\n *\r\n * ```ts\r\n * {\r\n *     \"in\": \"ease-in\",\r\n *     \"out\": \"ease-out\",\r\n *     \"in-out\": \"ease-in-out\",\r\n *\r\n *     // Sine\r\n *     \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n *     \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n *     \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n *\r\n *     // Quad\r\n *     \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n *     \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n *     \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n *\r\n *     // Cubic\r\n *     \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n *     \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n *     \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n *\r\n *     // Quart\r\n *     \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n *     \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n *     \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n *\r\n *     // Quint\r\n *     \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n *     \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n *     \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n *\r\n *     // Expo\r\n *     \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n *     \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n *     \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n *\r\n *     // Circ\r\n *     \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n *     \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n *     \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n *\r\n *     // Back\r\n *     \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n *     \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n *     \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n * }\r\n * ```\r\n */\r\nexport const EASINGS = {\r\n    \"in\": \"ease-in\",\r\n    \"out\": \"ease-out\",\r\n    \"in-out\": \"ease-in-out\",\r\n\r\n    // Sine\r\n    \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\r\n    \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\r\n    \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\r\n\r\n    // Quad\r\n    \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\r\n    \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\r\n    \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\r\n\r\n    // Cubic\r\n    \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\r\n    \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\r\n    \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\r\n\r\n    // Quart\r\n    \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\r\n    \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\r\n    \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\r\n\r\n    // Quint\r\n    \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\r\n    \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\r\n    \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\r\n\r\n    // Expo\r\n    \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\r\n    \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\r\n    \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\r\n\r\n    // Circ\r\n    \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\r\n    \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\r\n    \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\r\n\r\n    // Back\r\n    \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\r\n    \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\r\n    \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\r\n};\r\n\r\n/**\r\n * The keys of {@link EASINGS}\r\n *\r\n * @remark\r\n * \"in\", \"out\", \"in-out\", \"in-sine\", \"out-sine\", \"in-out-sine\", \"in-quad\", \"out-quad\", \"in-out-quad\", \"in-cubic\", \"out-cubic\", \"in-out-cubic\", \"in-quart\", \"out-quart\", \"in-out-quart\", \"in-quint\", \"out-quint\", \"in-out-quint\", \"in-expo\", \"out-expo\", \"in-out-expo\", \"in-circ\", \"out-circ\", \"in-out-circ\", \"in-back\", \"out-back\", \"in-out-back\"\r\n */\r\nexport const EasingKeys = Object.keys(EASINGS);\r\n\r\n/**\r\n * Converts users input into a usable easing function\r\n *\r\n * @param ease - easing functions; {@link EasingKeys}, cubic-bezier, steps, linear, etc...\r\n * @returns an easing function that `KeyframeEffect` can accept\r\n */\r\nexport const GetEase = (ease: keyof typeof EASINGS | string): string => {\r\n    let search = ease.replace(/^ease-/, \"\"); // Remove the \"ease-\" keyword\r\n    return EasingKeys.includes(search) ? EASINGS[search] : ease;\r\n};\r\n/**\r\n * The default options for every Animate instance\r\n *\r\n * ```ts\r\n * {\r\n *   keyframes: [],\r\n *\r\n *   loop: 1,\r\n *   delay: 0,\r\n *   speed: 1,\r\n *   endDelay: 0,\r\n *   easing: \"ease\",\r\n *   autoplay: true,\r\n *   duration: 1000,\r\n *   fillMode: \"none\",\r\n *   direction: \"normal\",\r\n *   padEndDelay: false,\r\n *   extend: {}\r\n * }\r\n * ```\r\n */\r\nexport const DefaultAnimationOptions: IAnimationOptions = {\r\n    keyframes: [],\r\n    offset: [],\r\n\r\n    loop: 1,\r\n    delay: 0,\r\n    speed: 1,\r\n    endDelay: 0,\r\n    easing: \"ease\",\r\n    timelineOffset: 0,\r\n    autoplay: true,\r\n    duration: 1000,\r\n    fillMode: \"none\",\r\n    direction: \"normal\",\r\n    padEndDelay: false,\r\n    extend: {}\r\n};\r\n\r\n\r\nexport const parseOptions = (options: IAnimationOptions): IAnimationOptions => {\r\n    let { options: animation, ...rest } = options;\r\n    let oldOptions = animation instanceof Animate ? animation.options : (Array.isArray(animation) ? animation?.[0]?.options : animation);\r\n    return Object.assign({}, oldOptions, rest);\r\n}\r\n\r\n/**\r\n * Return a copy of the object without the keys specified in the keys argument\r\n *\r\n * @param keys - arrays of keys to remove from the object\r\n * @param obj - the object in question\r\n * @returns\r\n * a copy of the object without certain key\r\n */\r\nexport const omit = (keys: string[], obj: { [key: string]: any }) => {\r\n    let rest = { ...obj };\r\n    while (keys.length) {\r\n        let { [keys.pop()]: omitted, ...remaining } = rest;\r\n        rest = remaining;\r\n    }\r\n    return rest;\r\n}\r\n\r\n/**\r\n * An animation library for the modern web, which. Inspired by animate plus, and animejs, [@okikio/animate](https://www.skypack.dev/view/@okikio/animate) is a Javascript animation library focused on performance and ease of use.\r\n *\r\n * You can check it out here: <https://codepen.io/okikio/pen/qBbdGaW?editors=0011>\r\n */\r\nexport class Animate {\r\n    /**\r\n     * Stores the options for the current animation\r\n     *\r\n     * @inheritDoc DefaultAnimationOptions\r\n     */\r\n    public options: IAnimationOptions = {};\r\n\r\n    /**\r\n     * The properties to animate\r\n     */\r\n    public properties: object = {};\r\n\r\n    /**\r\n     * The total duration of all Animation's\r\n     */\r\n    public totalDuration: number = 0;\r\n\r\n    /**\r\n     * The smallest delay out of all Animation's\r\n     */\r\n    public minDelay: number;\r\n\r\n    /**\r\n     * The smallest speed out of all Animation's\r\n     */\r\n    public maxSpeed: number;\r\n\r\n    /**\r\n     * The Element the mainAnimation runs on\r\n     */\r\n    public mainElement: HTMLElement;\r\n\r\n    /**\r\n     * Stores an animation that runs on the total duration of all the `Animation` instances, and as such it's the main Animation.\r\n     */\r\n    public mainAnimation: Animation;\r\n\r\n    /**\r\n     * The Keyframe Effect for the mainAnimation\r\n     */\r\n    public mainkeyframeEffect: KeyframeEffect;\r\n\r\n    /**\r\n     * Stores request frame calls\r\n     */\r\n    public animationFrame: number;\r\n\r\n    /**\r\n     * An event emitter\r\n     */\r\n    public emitter: EventEmitter = new EventEmitter();\r\n\r\n    /**\r\n     * Returns a promise that is fulfilled when the mainAnimation is finished\r\n     */\r\n    public promise: Promise<Animate[]>;\r\n\r\n    /**\r\n     * The list of Elements to Animate\r\n     */\r\n    public targets: Manager<number, Node> = new Manager();\r\n\r\n    /**\r\n     * The indexs of target Elements in Animate\r\n     */\r\n    public targetIndexes: WeakMap<Node, number> = new WeakMap();\r\n\r\n    /**\r\n     * A WeakMap of KeyFrameEffects\r\n     */\r\n    public keyframeEffects: WeakMap<HTMLElement, KeyframeEffect> = new WeakMap();\r\n\r\n    /**\r\n     * The options for individual animations\r\n     *\r\n     * A WeakMap that stores all the fully calculated options for individual Animation instances.\r\n     *\r\n     * _**Note**: the computedOptions are changed to their proper Animation instance options, so, some of the names are different, and options that can't be computed are not present. E.g. fillMode in the animation options is now just fill in the computedOptions.*_\r\n     *\r\n     * _**Note**: keyframes are not included, both the array form and the object form; the options, speed, extend, padEndDelay, and autoplay animation options are not included_\r\n     */\r\n    public computedOptions: WeakMap<HTMLElement, TypeComputedOptions> = new WeakMap();\r\n\r\n    /**\r\n     * A WeakMap of Animations\r\n     */\r\n    public animations: WeakMap<KeyframeEffect, Animation> = new WeakMap();\r\n\r\n    /**\r\n     * The keyframes for individual animations\r\n     *\r\n     * A WeakMap that stores all the fully calculated keyframes for individual Animation instances.\r\n     *\r\n     * _**Note**: the computedKeyframes are changed to their proper Animation instance options, so, some of the names are different, and options that can't be computed are not present. E.g. translateX, skew, etc..., they've all been turned into the transform property.*_\r\n     */\r\n    public computedKeyframes: WeakMap<HTMLElement, TypeKeyFrameOptionsType> = new WeakMap();\r\n    constructor(options: IAnimationOptions) {\r\n        this.loop = this.loop.bind(this);\r\n        this.onVisibilityChange = this.onVisibilityChange.bind(this);\r\n        this.on(\"error\", (err) => console.error(err));\r\n        this.updateOptions(options);\r\n\r\n        this.visibilityPlayState = this.getPlayState();\r\n        if (Animate.pauseOnPageHidden) {\r\n            document.addEventListener('visibilitychange', this.onVisibilityChange, false);\r\n        }\r\n\r\n        this.newPromise();\r\n    }\r\n\r\n    /**\r\n     * Tells all animate instances to pause when the page is hidden\r\n     *\r\n     * @static\r\n     * @type {Boolean}\r\n     * @memberof Animate\r\n     */\r\n    static pauseOnPageHidden: Boolean = true;\r\n\r\n    /**\r\n     * Store the last remebered playstate before page was hidden\r\n     *\r\n     * @protected\r\n     * @type {TypePlayStates}\r\n     * @memberof Animate\r\n     */\r\n    protected visibilityPlayState: TypePlayStates;\r\n\r\n    /**\r\n     * document `visibilitychange` event handler\r\n     */\r\n    protected onVisibilityChange() {\r\n        if (document.hidden) {\r\n            this.visibilityPlayState = this.getPlayState();\r\n            if (this.is(\"running\")) {\r\n                this.loop();\r\n                this.pause();\r\n            }\r\n        } else {\r\n            if (this.visibilityPlayState == \"running\" && this.is(\"paused\"))\r\n                this.play();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new Promise that is resolved when the animation finishes\r\n     */\r\n    public newPromise(): Promise<Animate[]> {\r\n        this.promise = new Promise((resolve, reject) => {\r\n            /*\r\n                Note that the `this` keyword is in an Array when it is resolved,\r\n                this is due to Promises not wanting to resolve references,\r\n                so, you can't resolve `this` directly, so, I chose to resolve `this` in an\r\n                Array\r\n\r\n                Note: the `resolve` method by default will only run once so to avoid\r\n            */\r\n            this?.emitter?.once?.(\"finish\", () => resolve([this]));\r\n            this?.emitter?.once?.(\"error\", err => reject(err));\r\n        });\r\n\r\n        return this.promise;\r\n    }\r\n\r\n    /**\r\n     * Fulfills the `this.promise` Promise\r\n     */\r\n    public then(\r\n        onFulfilled?: (value?: any) => any,\r\n        onRejected?: (reason?: any) => any\r\n    ): Animate {\r\n        onFulfilled = onFulfilled?.bind(this);\r\n        onRejected = onRejected?.bind(this);\r\n        this?.promise?.then?.(onFulfilled, onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Catches error that occur in the `this.promise` Promise\r\n     */\r\n    public catch(onRejected: (reason?: any) => any): Animate {\r\n        onRejected = onRejected?.bind(this);\r\n        this.promise?.catch?.(onRejected);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * If you don't care if the `this.promise` Promise has either been rejected or resolved\r\n     */\r\n    public finally(onFinally: () => any): Animate {\r\n        onFinally = onFinally?.bind(this);\r\n        this.promise?.finally?.(onFinally);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Represents an Animation Frame Loop\r\n     */\r\n    public loop(): void {\r\n        this.stopLoop();\r\n        this.animationFrame = window.requestAnimationFrame(this.loop);\r\n        this.emit(\"update\", this.getProgress(), this);\r\n    }\r\n\r\n    /**\r\n     * Cancels animation frame\r\n     */\r\n    public stopLoop() {\r\n        window.cancelAnimationFrame(this.animationFrame);\r\n    }\r\n\r\n    /**\r\n     * Calls a method that affects all animations **excluding** the mainAnimation; the method only allows the animation parameter\r\n    */\r\n    public allAnimations(method: (animation?: Animation, target?: HTMLElement) => void) {\r\n        this.targets.forEach((target: HTMLElement) => {\r\n            let keyframeEffect = this.keyframeEffects.get(target);\r\n            let animation = this.animations.get(keyframeEffect);\r\n            return method(animation, target);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calls a method that affects all animations **including** the mainAnimation; the method only allows the animation parameter\r\n    */\r\n    public all(method: (animation?: Animation, target?: HTMLElement) => void) {\r\n        this.mainAnimation && method(this.mainAnimation, this.mainElement);\r\n        this.allAnimations(method);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register the begin event\r\n     */\r\n    protected beginEvent() {\r\n        if (this.getProgress() == 0)\r\n            this.emit(\"begin\", this);\r\n    }\r\n\r\n    /**\r\n     * Play Animation\r\n     */\r\n    public play(): Animate {\r\n        let playstate = this.getPlayState();\r\n        this.beginEvent();\r\n        this.all(anim => anim.play());\r\n        this.emit(\"play\", playstate, this);\r\n        if (!this.is(playstate))\r\n            this.emit(\"playstate-change\", playstate, this);\r\n        this.loop();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause Animation\r\n     */\r\n    public pause(): Animate {\r\n        let playstate = this.getPlayState();\r\n        this.all(anim => anim.pause());\r\n        this.emit(\"pause\", playstate, this);\r\n        if (!this.is(playstate))\r\n            this.emit(\"playstate-change\", playstate, this);\r\n        this.stopLoop();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverse Animation\r\n     */\r\n    public reverse() {\r\n        this.all(anim => anim.reverse());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all Animations\r\n     */\r\n    public reset() {\r\n        this.setProgress(0);\r\n\r\n        if (this.options.autoplay) this.play();\r\n        else this.pause();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels all Animations\r\n     */\r\n    public cancel() {\r\n        this.all(anim => anim.cancel());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force complete all Animations\r\n     */\r\n    public finish() {\r\n        this.all(anim => anim.finish());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels & Clears all Animations\r\n     */\r\n    public stop() {\r\n        this.cancel();\r\n        this.stopLoop();\r\n        document.removeEventListener('visibilitychange', this.onVisibilityChange, false);\r\n\r\n        this.targets.forEach((target: HTMLElement) => this.removeTarget(target));\r\n\r\n        this.emit(\"stop\");\r\n        this.emitter.clear();\r\n\r\n        this.mainkeyframeEffect = null;\r\n        this.mainAnimation = null;\r\n        this.mainElement = null;\r\n\r\n        this.promise = null;\r\n        this.computedOptions = null;\r\n        this.animations = null;\r\n        this.keyframeEffects = null;\r\n        this.emitter = null;\r\n        this.targets = null;\r\n        this.options = null;\r\n        this.properties = null;\r\n    }\r\n\r\n    /**\r\n     * Get a specific Animation from an Animate instance\r\n     */\r\n    public getAnimation(target: HTMLElement) {\r\n        let keyframeEffect = this.keyframeEffects.get(target);\r\n        return this.animations.get(keyframeEffect);\r\n    }\r\n\r\n    /**\r\n     * Returns the timings of an Animation, given a target\r\n     * E.g. { duration, endDelay, delay, iterations, iterationStart, direction, easing, fill, etc... }\r\n     */\r\n    public getTiming(target: HTMLElement): TypeComputedAnimationOptions {\r\n        let keyframeOptions = this.computedOptions.get(target) ?? {};\r\n        let timings = this.keyframeEffects.get(target).getTiming?.() ?? {};\r\n\r\n        return { ...keyframeOptions, ...timings };\r\n    }\r\n\r\n    /**\r\n     * Returns the current time of the Main Animation\r\n     */\r\n    public getCurrentTime(): number {\r\n        return this.mainAnimation.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Returns the Animation progress as a fraction of the current time / duration * 100\r\n     */\r\n    public getProgress() {\r\n        return (this.getCurrentTime() / this.totalDuration) * 100;\r\n    }\r\n\r\n    /**\r\n     * Return the playback speed of the animation\r\n     */\r\n    public getSpeed(): number {\r\n        return this.mainAnimation.playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Returns the current playing state\r\n     */\r\n    public getPlayState(): TypePlayStates {\r\n        return this.mainAnimation.playState;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean determining if the `animate` instances playstate is equal to the `playstate` parameter.\r\n     */\r\n    public is(playstate: TypePlayStates) {\r\n        return this.getPlayState() == playstate;\r\n    }\r\n\r\n    /**\r\n     * Set the current time of the Main Animation\r\n     */\r\n    public setCurrentTime(time: number): Animate {\r\n        this.all(anim => (anim.currentTime = time));\r\n        this.emit(\"update\", this.getProgress());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the Animation progress as a value from 0 to 100\r\n     */\r\n    public setProgress(percent: number): Animate {\r\n        let time = (percent / 100) * this.totalDuration;\r\n        this.setCurrentTime(time);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the playback speed of an Animation\r\n     */\r\n    public setSpeed(speed: number = 1): Animate {\r\n        this.maxSpeed = speed;\r\n        this.all(anim => {\r\n            if (anim.updatePlaybackRate)\r\n                anim.updatePlaybackRate(speed);\r\n            else anim.playbackRate = speed;\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of computed options\r\n     */\r\n    protected createArrayOfComputedOptions(optionsFromParam: IAnimationOptions, len: number) {\r\n        let result: TypeComputedAnimationOptions = [];\r\n        this.targets.forEach((target: HTMLElement, i) => {\r\n            // Basically if there is already a computedOption for the target element use it, but don't ovveride any new options\r\n            let oldComputedOptions: IAnimationOptions = this.computedOptions.get(target) ?? {};\r\n            let getOption = (key: string) => {\r\n                let computedKey = key;\r\n                if (key == \"loop\") computedKey = \"iterations\";\r\n                if (key == \"fillMode\") computedKey = \"fill\";\r\n                return optionsFromParam[key] ?? oldComputedOptions[computedKey] ?? this.options[key];\r\n            };\r\n\r\n            let animationOptions = Object.assign({\r\n                easing: getOption(\"easing\"),\r\n                iterations: getOption(\"loop\"),\r\n                direction: getOption(\"direction\"),\r\n                endDelay: getOption(\"endDelay\"),\r\n                duration: getOption(\"duration\"),\r\n                speed: getOption(\"speed\"),\r\n                delay: getOption(\"delay\"),\r\n                timelineOffset: getOption(\"timelineOffset\"),\r\n                keyframes: getOption(\"keyframes\"),\r\n            }, getOption(\"extend\") ?? {});\r\n\r\n            // let oldComputedOptions = this.computedOptions.get(target)\r\n            // Allows the use of functions as the values, for both the keyframes and the animation object\r\n            // It adds the capability of advanced stagger animation, similar to the animejs stagger functions\r\n            let computedOptions = mapAnimationOptions(animationOptions as IAnimationOptions, [i, len, target], this);\r\n\r\n            if (typeof computedOptions.easing == \"string\")\r\n                computedOptions.easing = GetEase(computedOptions.easing);\r\n\r\n            if (computedOptions.iterations === true)\r\n                computedOptions.iterations = Infinity;\r\n\r\n            computedOptions.fill = getOption(\"fillMode\");\r\n\r\n            // Add timelineOffset to delay, this is future proofing;\r\n            // if you want to create a custom timeline similar to animejs this will help you\r\n            // I don't intend to make a timeline function for this project\r\n            let {\r\n                timelineOffset,\r\n                speed,\r\n                endDelay,\r\n                delay,\r\n                duration,\r\n                iterations,\r\n                ...remainingComputedOptions\r\n            } = computedOptions;\r\n\r\n            iterations = Number(iterations);\r\n            duration = Number(duration);\r\n            endDelay = Number(endDelay);\r\n            speed = Number(speed);\r\n            delay = Number(delay) + Number(timelineOffset);\r\n\r\n            let tempDurations = delay + (duration * iterations) + endDelay;\r\n\r\n            // Set the totalDuration to be the Animation with the largest totalDuration\r\n            if (this.totalDuration < tempDurations)\r\n                this.totalDuration = tempDurations;\r\n\r\n            result[i] = {\r\n                ...remainingComputedOptions,\r\n                speed,\r\n                tempDurations,\r\n                endDelay,\r\n                delay,\r\n                duration,\r\n                iterations,\r\n            };\r\n\r\n            if (!isValid(this.minDelay) || delay < this.minDelay) this.minDelay = delay;\r\n            if (!isValid(this.maxSpeed) || speed < this.maxSpeed) this.maxSpeed = speed;\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates animations out of an array of computed options\r\n     */\r\n    protected createAnimations(param: { arrOfComputedOptions: any; padEndDelay: any; oldCSSProperties: any; onfinish: any; oncancel: any; }, len: number) {\r\n        let {\r\n            arrOfComputedOptions,\r\n            padEndDelay,\r\n            oldCSSProperties,\r\n            onfinish,\r\n            oncancel\r\n        } = param;\r\n\r\n        this.targets.forEach((target: HTMLElement, i) => {\r\n            let { speed, keyframes, tempDurations, ...computedOptions } = arrOfComputedOptions[i];\r\n\r\n            // You cannot use the `padEndDelay` option and set a value for `endDelay`, the `endDelay` value will\r\n            // replace the padded endDelay\r\n\r\n            // This ensures all `animations` match up to the total duration, and don't finish too early,\r\n            // if animations finish too early, when the `.play()` method is called, some animations\r\n            // that are finished will restart, while the rest will continue playing.\r\n            // This is mostly for progress control, but depending on your usage may truly benefit you\r\n            if (padEndDelay && computedOptions.endDelay == 0 &&\r\n                Math.abs(computedOptions.iterations) != Math.abs(Infinity)) {\r\n                computedOptions.endDelay = this.totalDuration - tempDurations;\r\n            }\r\n\r\n            let computedKeyframes: Keyframe[] | PropertyIndexedKeyframes;\r\n            let animationKeyframe: TypeKeyFrameOptionsType;\r\n\r\n            // Accept keyframes as a keyframes Object, or a method,\r\n            // if there are no animations in the keyframes array,\r\n            // uses css properties from the options object\r\n            let arrKeyframes = keyframes as (Keyframe[] | TypeCSSLikeKeyframe);\r\n            if (typeof arrKeyframes == \"object\") arrKeyframes = KeyframeParse(arrKeyframes);\r\n\r\n            // If `computedKeyframes` have been previously computed for this target element replace\r\n            // the old uncomputed CSS properties with it, otherwise, use the uncomputed property\r\n            let oldComputedKeyframe = this.computedKeyframes.get(target) ?? {};\r\n            let fullProperties = Object.assign({}, oldCSSProperties, oldComputedKeyframe);\r\n\r\n            // Replace old CSS properties with new CSS properties if there is a new value for the CSS property\r\n            // As in the new CSS property is not null or null\r\n            let properties = mapObject(fullProperties, (value, key) => (this.properties[key] ?? value));\r\n\r\n            // Prefer arrays of keyframes over pure CSS Properties\r\n            animationKeyframe = isValid(arrKeyframes) ? arrKeyframes : properties as PropertyIndexedKeyframes;\r\n\r\n            if (!Array.isArray(animationKeyframe)) {\r\n                // Remove `keyframes` animation option, it's not a valid CSS property\r\n                let remaining: IAnimationOptions = omit([\"keyframes\"], animationKeyframe);\r\n                let { offset, ...CSSProperties } = mapAnimationOptions(remaining, [i, len, target], this);\r\n\r\n                // transform, is often used so, to make them easier to use we parse them for strings, number, and/or arrays of both;\r\n                // for transform we parse the translate, skew, scale, and perspective functions (including all their varients) as CSS properties;\r\n                // it then turns these properties into valid `PropertyIndexedKeyframes`\r\n                // Read the documentation for `ParseTransformableCSSProperties`\r\n                CSSProperties = ParseTransformableCSSProperties(CSSProperties as ICSSComputedTransformableProperties);\r\n\r\n                let _offset = offset as (string | number)[];\r\n                computedKeyframes = Object.assign({},\r\n                    CSSProperties,\r\n                    !isValid(_offset) ? null : { offset: _offset.map(parseOffset) }\r\n                ) as PropertyIndexedKeyframes;\r\n            } else {\r\n                computedKeyframes = animationKeyframe.map((keyframe: Keyframe) => {\r\n                    // Remove `speed` & `loop`, they are not valid CSS properties\r\n                    let { easing, offset, ...remaining } = omit([\"speed\", \"loop\"], keyframe);\r\n\r\n                    return Object.assign({ },\r\n                        remaining,\r\n                        typeof easing == \"string\" ? { easing: GetEase(easing) } : null,\r\n                        typeof offset == \"string\" || typeof offset == \"number\"\r\n                            ? { offset: parseOffset(offset) } : null\r\n                    );\r\n                });\r\n\r\n                // Transform transformable CSS properties in each keyframe of the keyframe array\r\n                computedKeyframes = ParseTransformableCSSKeyframes(computedKeyframes) as Keyframe[];\r\n            }\r\n\r\n            let animation: Animation, keyFrameEffect: KeyframeEffect;\r\n            if (this.keyframeEffects.has(target)) {\r\n                // Update the animation, if the target already is already being animated\r\n                keyFrameEffect = this.keyframeEffects.get(target);\r\n                animation = this.animations.get(keyFrameEffect);\r\n\r\n                keyFrameEffect?.setKeyframes?.(computedKeyframes);\r\n                keyFrameEffect?.updateTiming?.(computedOptions as KeyframeAnimationOptions);\r\n            } else {\r\n                // Create animation and add it to the Animations Set\r\n                keyFrameEffect = new KeyframeEffect(target, computedKeyframes, computedOptions as KeyframeAnimationOptions);\r\n                animation = new Animation(keyFrameEffect, computedOptions.timeline);\r\n\r\n                this.keyframeEffects.set(target, keyFrameEffect);\r\n                this.animations.set(keyFrameEffect, animation);\r\n            }\r\n\r\n            animation.playbackRate = speed;\r\n\r\n            // Support for on finish\r\n            animation.onfinish = () => {\r\n                typeof onfinish == \"function\" && onfinish.call(this, target, i, len, animation);\r\n            };\r\n\r\n            // // Support for on cancel\r\n            animation.oncancel = () => {\r\n                typeof oncancel == \"function\" && oncancel.call(this, target, i, len, animation);\r\n            };\r\n\r\n            // Set the calculated options & keyframes for each individual animation\r\n            this.computedOptions.set(target, computedOptions);\r\n            this.computedKeyframes.set(target, computedKeyframes);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update the options for all targets\r\n     *\r\n     * _**Note**: `KeyframeEffect` support is really low, so, I am suggest that you avoid using the `updateOptions` method, until browser support for `KeyframeEffect.updateTiming(...)` and `KeyframeEffefct.setKeyframes(...)` is better_\r\n     *\r\n     * @beta\r\n     */\r\n    public updateOptions(options: IAnimationOptions = {}) {\r\n        try {\r\n            let optionsFromParam = parseOptions(options);\r\n            this.options = Object.assign({}, DefaultAnimationOptions, this.options, optionsFromParam);\r\n\r\n            // This removes all none CSS properties from `properties`\r\n            let sharedTimingKeys = [\"easing\", \"loop\", \"endDelay\", \"duration\", \"speed\", \"delay\", \"timelineOffset\", \"direction\", \"extend\", \"fillMode\", \"offset\"];\r\n            let {\r\n                // These values cannot be functions\r\n                padEndDelay,\r\n                onfinish,\r\n                oncancel,\r\n                autoplay,\r\n                target,\r\n                targets,\r\n\r\n                /**\r\n                 * Theses are the CSS properties to be animated as Keyframes\r\n                 */\r\n                ...oldCSSProperties\r\n            } = omit(sharedTimingKeys, this.options);\r\n\r\n            // This removes all none CSS properties from `optionsFromParam`\r\n            this.properties = omit([...sharedTimingKeys, \"keyframes\", \"padEndDelay\", \"onfinish\", \"oncancel\", \"autoplay\", \"target\", \"targets\"], optionsFromParam);\r\n\r\n            // Avoid duplicate elements\r\n            let oldTargets = this.targets.values();\r\n            let targetSet = [...new Set([...oldTargets, ...getTargets(targets), ...getTargets(target)])];\r\n            this.targets.clear();\r\n            targetSet.forEach((value, i) => {\r\n                this.targets.set(i, value);\r\n                this.targetIndexes.set(value, i);\r\n            });\r\n\r\n            let len = this.targets.size;\r\n            let arrOfComputedOptions = this.createArrayOfComputedOptions(optionsFromParam, len);\r\n            this.createAnimations({\r\n                arrOfComputedOptions,\r\n                padEndDelay,\r\n                oldCSSProperties,\r\n                onfinish,\r\n                oncancel\r\n            }, len);\r\n\r\n            this.maxSpeed = this.maxSpeed ?? this.options.speed as number;\r\n            this.minDelay = this.minDelay ??  this.options.delay as number;\r\n            this.totalDuration = this.totalDuration ?? this.options.duration as number;\r\n\r\n            if (!this.mainAnimation) {\r\n                this.mainkeyframeEffect = new KeyframeEffect(this.mainElement, [\r\n                    { opacity: \"0\" },\r\n                    { opacity: \"1\" }\r\n                ], {\r\n                    // Why waste performance on an animation no one can see?\r\n                    duration: this.totalDuration,\r\n                    easing: \"linear\"\r\n                });\r\n\r\n                this.mainAnimation = new Animation(this.mainkeyframeEffect, this.options.timeline);\r\n            } else {\r\n                this.mainkeyframeEffect?.updateTiming?.({\r\n                    duration: this.totalDuration\r\n                });\r\n\r\n                if (!this.mainkeyframeEffect.setKeyframes || !this.mainkeyframeEffect.updateTiming)\r\n                    console.warn(\"@okikio/animate - `KeyframeEffect.setKeyframes` and/or `KeyframeEffect.updateTiming` are not supported in this browser.\");\r\n            }\r\n\r\n            this.mainAnimation.playbackRate = this.maxSpeed;\r\n            this.mainAnimation.onfinish = () => {\r\n                this.emit(\"finish\", this);\r\n                if (this.mainAnimation) {\r\n                    let playstate = this.getPlayState();\r\n                    if (!this.is(playstate))\r\n                        this.emit(\"playstate-change\", playstate, this);\r\n                    this.stopLoop();\r\n                }\r\n            };\r\n\r\n            this.mainAnimation.oncancel = () => {\r\n                this.emit(\"cancel\", this);\r\n                if (this.mainAnimation) {\r\n                    let playstate = this.getPlayState();\r\n                    if (!this.is(playstate))\r\n                        this.emit(\"playstate-change\", playstate, this);\r\n                    this.stopLoop();\r\n                }\r\n            };\r\n\r\n            if (autoplay) {\r\n                // By the time events are registered the animation would have started and there wouldn't have be a `begin` event listener to actually emit\r\n                // So, this defers the emitting for a 0ms time allowing the rest of the js to run, the `begin` event to be registered thus\r\n                // the `begin` event can be emitter\r\n                let timer: number | void = window.setTimeout(() => {\r\n                    this.emit(\"begin\", this);\r\n                    timer = window.clearTimeout(timer as number);\r\n                }, 0);\r\n\r\n                this.play();\r\n            } else this.pause();\r\n        } catch (err) {\r\n            this.emit(\"error\", err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a target to the Animate instance, and update the animation options with the change\r\n     *\r\n     * _**Note**: `KeyframeEffect` support is really low, so, I am suggest that you avoid using the `add` method, until browser support for `KeyframeEffect.updateTiming(...)` and `KeyframeEffefct.setKeyframes(...)` is better_\r\n     *\r\n     * @beta\r\n     */\r\n    public add(target: HTMLElement) {\r\n        let progress = this.getProgress();\r\n        let running = this.is(\"running\");\r\n        let paused = this.is(\"paused\");\r\n\r\n        this.updateOptions({ target });\r\n        this.setProgress(progress);\r\n\r\n        if (running) this.play();\r\n        else if (paused) this.pause();\r\n    }\r\n\r\n    /**\r\n     * Removes a target from an Animate instance\r\n     *\r\n     * _**Note**: it doesn't update the current running options, you need to use the `Animate.prototype.remove(...)` method if you want to also update the running options_\r\n     */\r\n    public removeTarget(target: HTMLElement) {\r\n        let keyframeEffect = this.keyframeEffects.get(target);\r\n        this.animations.delete(keyframeEffect);\r\n        keyframeEffect = null;\r\n\r\n        this.computedKeyframes.delete(target);\r\n        this.computedOptions.delete(target);\r\n        this.keyframeEffects.delete(target);\r\n\r\n        let index = this.targetIndexes.get(target);\r\n        this.targets.delete(index);\r\n        this.targetIndexes.delete(target);\r\n    }\r\n\r\n    /**\r\n     * Removes a target from an Animate instance, and update the animation options with the change\r\n     *\r\n     * _**Note**: `KeyframeEffect` support is really low, so, I am suggest that you avoid using the `remove` method, until browser support for `KeyframeEffect.updateTiming(...)` and `KeyframeEffefct.setKeyframes(...)` is better_\r\n     *\r\n     * @beta\r\n     */\r\n    public remove(target: HTMLElement) {\r\n        this.removeTarget(target);\r\n\r\n        let targetSet = new Set([].concat(this.targets.values()));\r\n\r\n        this.options.target = [...targetSet];\r\n        this.options.targets = [];\r\n        targetSet.clear();\r\n        targetSet = null;\r\n\r\n        let progress = this.getProgress();\r\n        let running = this.is(\"running\");\r\n        let paused = this.is(\"paused\");\r\n\r\n        this.updateOptions();\r\n\r\n        if (running) this.play();\r\n        else if (paused) this.pause();\r\n\r\n        this.setProgress(progress);\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for a given event\r\n     */\r\n    public on(events: TypeAnimationEvents[] | TypeAnimationEvents | TypeEventInput, callback?: TypeListenerCallback | object, scope?: object): Animate {\r\n        this?.emitter?.on(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from an event\r\n     */\r\n    public off(events: TypeAnimationEvents[] | TypeAnimationEvents | TypeEventInput, callback?: TypeListenerCallback | object, scope?: object): Animate {\r\n        this?.emitter?.off(events, callback, scope ?? this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call all listeners within an event\r\n     */\r\n    public emit(events: TypeAnimationEvents[] | TypeAnimationEvents | string | any[], ...args: any): Animate {\r\n        this?.emitter?.emit(events, ...args);\r\n        return this;\r\n    }\r\n\r\n    /** Returns the Animate options, as JSON  */\r\n    public toJSON(): IAnimationOptions {\r\n        return this.options;\r\n    }\r\n\r\n    /**\r\n     * The Symbol.toStringTag well-known symbol is a string valued property that is used\r\n     * in the creation of the default string description of an object.\r\n     * It is accessed internally by the Object.prototype.toString() method.\r\n     */\r\n    get [Symbol.toStringTag]() {\r\n        return `Animate`;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new Animate instance\r\n *\r\n * @remark\r\n * `@okikio/animate` create animations by creating instances of `Animate`, a class that acts as a wrapper around the Web Animation API. To create new instances of the `Animate` class, you can either import the `Animate` class and do this, `new Animate({ ... })` or import the `animate` (lowercase) method and do this, `animate({ ... })`. The `animate` method creates new instances of the `Animate` class and passes the options it recieves as arguments to the `Animate` class.\r\n *\r\n * The `Animate` class recieves a set of targets to animate, it then creates a list of Web Animation API `Animation` instances, along side a main animation, which is small `Animation` instance that is set to animate the opacity of a non visible element, the `Animate` class then plays each `Animation` instances keyframes including the main animation.\r\n\r\n * The main animation is there to ensure accuracy in different browser vendor implementation of the Web Animation API. The main animation is stored in `Animate.prototype.mainAnimation: Animation`, the other `Animation` instances are stored in a `Manager` (from [@okikio/manager](https://www.npmjs.com/package/@okikio/manager)) `Animate.prototype.animations: Manager<HTMLElement, Animation>`.\r\n\r\n * @example\r\n * ```ts\r\n * import animate from \"@okikio/animate\";\r\n *\r\n * // Do note, on the web you need to do this, if you installed it via the script tag:\r\n * // const { animate } = window.animate;\r\n *\r\n * (async () => {\r\n *     let [options] = await animate({\r\n *         target: \".div\",\r\n *         // NOTE: If you turn this on you have to comment out the transform property. The keyframes property is a different format for animation you cannot you both styles of formatting in the same animation\r\n *         // keyframes: [\r\n *         //     { transform: \"translateX(0px)\" },\r\n *         //     { transform: \"translateX(300px)\" }\r\n *         // ],\r\n *         transform: [\"translateX(0px)\", \"translateX(300px)\"],\r\n *         easing: \"out\",\r\n *         duration(i) {\r\n *             return (i + 1) * 500;\r\n *         },\r\n *         loop: 1,\r\n *         speed: 2,\r\n *         fillMode: \"both\",\r\n *         direction: \"normal\",\r\n *         autoplay: true,\r\n *         delay(i) {\r\n *             return (i + 1) * 100;\r\n *         },\r\n *         endDelay(i) {\r\n *             return (i + 1) * 100;\r\n *         },\r\n *     });\r\n *\r\n *     animate({\r\n *         options,\r\n *         transform: [\"translateX(300px)\", \"translateX(0px)\"],\r\n *     });\r\n * })();\r\n *\r\n * // or you can use the .then() method\r\n * animate({\r\n *     target: \".div\",\r\n *     // NOTE: If you turn this on you have to comment out the transform property. The keyframes property is a different format for animation you cannot you both styles of formatting in the same animation\r\n *     // keyframes: [\r\n *     //     { transform: \"translateX(0px)\" },\r\n *     //     { transform: \"translateX(300px)\" }\r\n *     // ],\r\n *     transform: [\"translateX(0px)\", \"translateX(300px)\"],\r\n *     easing: \"out\",\r\n *     duration(i) {\r\n *         return (i + 1) * 500;\r\n *     },\r\n *     loop: 1,\r\n *     speed: 2,\r\n *     fillMode: \"both\",\r\n *     direction: \"normal\",\r\n *     delay(i) {\r\n *         return (i + 1) * 100;\r\n *     },\r\n *     autoplay: true,\r\n *     endDelay(i) {\r\n *         return (i + 1) * 100;\r\n *     }\r\n * }).then((options) => {\r\n *     animate({\r\n *         options,\r\n *         transform: [\"translateX(300px)\", \"translateX(0px)\"]\r\n *     });\r\n * });\r\n * ```\r\n *\r\n * [Preview this example &#8594;](https://codepen.io/okikio/pen/mdPwNbJ?editors=0010)\r\n *\r\n * @packageDocumentation\r\n */\r\nexport const animate = (options: IAnimationOptions = {}): Animate => {\r\n    return new Animate(options);\r\n};\r\n\r\nexport default animate;\r\n", "import { IgnoreURLsList } from \"./pjax\";\r\nimport { ITransition } from \"./transition\";\r\n\r\nexport interface ICONFIG {\r\n    /**\r\n     * The Prefix attached to data attributes\r\n     */\r\n    prefix?: string;\r\n\r\n    /**\r\n     * The attribute used to identify wrappers\r\n     * @default `wrapper` as in `data-wrapper`\r\n    */\r\n    wrapperAttr?: string;\r\n\r\n    /**\r\n     * Headers to attach to fetch requests done by the PageManager\r\n     * e.g. if you only want to load a partial output containing only the wrapper\r\n     *\r\n     * @default `[]`\r\n     * @example\r\n     * ```ts\r\n     * headers: [\r\n     *      [\"partial-output\", \"true\"]\r\n     * ]\r\n     * ```\r\n     */\r\n    headers?: string[][];\r\n\r\n    /**\r\n     * Attribute used to identify anchors that don't want PJAX enabled\r\n     * @default `prevent=\"self\"` as in `data-prevent=\"self\"`\r\n     */\r\n    preventSelfAttr?: string;\r\n\r\n    /**\r\n     * Attribute used to identify elements that don't want PJAX enabled for themeselves and their child elements\r\n     * @default `prevent=\"all\"` as in `data-prevent=\"all\"`\r\n     */\r\n    preventAllAttr?: string;\r\n\r\n    /**\r\n     * Attribute used to identify transition an anchor wants to use, the value you set will select the transition used by name\r\n     * _**Note**: transition names are case sensitive_\r\n     * @default `transition` as in `data-transition`\r\n     */\r\n    transitionAttr?: string;\r\n\r\n    /**\r\n     * The amount of time in milliseconds to wait before counting the PageManagers fetch requests as timed out\r\n     * @default `2000`\r\n     */\r\n    timeout?: number;\r\n\r\n    /**\r\n     * The maximum amount of pages to have in the cache at any moment in time;\r\n     * PageManager removes pages from the cache to ensure content doesn't become stale;\r\n     * and memory usage isn't too high\r\n     * @default `5`\r\n     */\r\n    maxPages?: number;\r\n\r\n    /**\r\n     * The resize event is debounced by this amount of time (in miliseconds)\r\n     * @default `100`\r\n     */\r\n    resizeDelay?: number;\r\n\r\n    /**\r\n     * Ignore extra clicks of an anchor element if a transition has already started\r\n     * by default PJAX will reload the page on multiple clicks but this allows you to stop extra clicks\r\n     * from affecting the current transition\r\n     * @default `true`\r\n     */\r\n    onTransitionPreventClick?: boolean;\r\n\r\n    /**\r\n     * Specifies which urls to always fetch from the web\r\n     * It also accepts boolean values:\r\n     * - `true` means always fetch from the web for all urls\r\n     * - `false` means always try to fetch from the cache\r\n     * @default `false`\r\n     */\r\n    cacheIgnore?: boolean | IgnoreURLsList;\r\n\r\n    /**\r\n     * Specifies which urls to not prefetch\r\n     * It also accepts boolean values:\r\n     * - `true` means don't prefetch any anchor\r\n     * - `false` means always prefetch all anchors\r\n     * @default `false`\r\n     */\r\n    prefetchIgnore?: boolean | IgnoreURLsList;\r\n\r\n    /**\r\n     * Specifies which urls to not use PJAX for\r\n     * @default `[]`\r\n     */\r\n    preventURLs?: boolean | IgnoreURLsList;\r\n\r\n    /**\r\n     * On page change (excluding popstate events, and hashes) keep current scroll position\r\n     * @default `false`\r\n     */\r\n    stickyScroll?: boolean;\r\n\r\n    /**\r\n     * Force load a page if an error occurs\r\n     * @default `true`\r\n     */\r\n    forceOnError?: boolean;\r\n\r\n    /**\r\n     * Don't do anything if the url has a hash\r\n     * @default `false`\r\n     */\r\n    ignoreHashAction?: boolean;\r\n\r\n    /**\r\n     * TransitionManagers regestered transitions\r\n     * @default `[]`\r\n     */\r\n    transitions?: Array<[string, ITransition]>;\r\n    [key: string]: any;\r\n}\r\n\r\nexport const CONFIG_DEFAULTS: ICONFIG = {\r\n    wrapperAttr: \"wrapper\",\r\n    headers: [],\r\n    preventSelfAttr: `prevent=\"self\"`,\r\n    preventAllAttr: `prevent=\"all\"`,\r\n    transitionAttr: \"transition\",\r\n\r\n    timeout: 2000,\r\n    maxPages: 5,\r\n    resizeDelay: 100,\r\n    onTransitionPreventClick: true,\r\n    cacheIgnore: false,\r\n    prefetchIgnore: false,\r\n    preventURLs: [],\r\n    stickyScroll: false,\r\n    forceOnError: true,\r\n    ignoreHashAction: false,\r\n    transitions: []\r\n};\r\n\r\nexport type ConfigKeys = keyof typeof CONFIG_DEFAULTS | string;\r\nexport const newConfig = (config: ICONFIG): ICONFIG => {\r\n    return Object.assign({ ...CONFIG_DEFAULTS }, config);\r\n};\r\n\r\n/** Converts config properties into properly formatted data attributes */\r\nexport const toAttr = (config: ICONFIG, value?: ConfigKeys, brackets: boolean = true): any => {\r\n    let { prefix } = config;\r\n    let prop = config[value];\r\n    let attr = `data${prefix ? \"-\" + prefix : \"\"}-${prop}`;\r\n    return brackets ? `[${attr}]` : attr;\r\n};\r\n", "import { Manager, methodCall } from \"@okikio/manager\";\r\nimport { ICONFIG } from \"./config\";\r\nimport { IApp } from \"./app\";\r\nimport { EventEmitter } from \"@okikio/emitter\";\r\n\r\nexport type IAdvancedManager = AdvancedManager<any, ManagerItem>;\r\n\r\n/** The base class for AdvancedManager items */\r\nexport class ManagerItem {\r\n    /** The AdvancedManager the ManagerItem is attached to */\r\n    public manager: IAdvancedManager;\r\n\r\n    /** The App the ManagerItem is attached to */\r\n    public app: IApp;\r\n\r\n    /** The Config of the App the ManagerItem is attached to */\r\n    public config: ICONFIG;\r\n\r\n    /** The EventEmitter of the App the ManagerItem is attached to */\r\n    public emitter: EventEmitter;\r\n\r\n    /** The key to where ManagerItem is stored in an AdvancedManager */\r\n    public key: any;\r\n\r\n    constructor() { }\r\n\r\n    /** Run after the Manager Item has been registered */\r\n    public install(): any { }\r\n\r\n    /** Register the current Manager Item's manager */\r\n    public register(manager: IAdvancedManager, key: any): ManagerItem {\r\n        this.manager = manager;\r\n        this.app = manager.app;\r\n        this.config = manager.config;\r\n        this.emitter = manager.emitter;\r\n        this.key = key;\r\n        this.install();\r\n        return this;\r\n    }\r\n\r\n    /** Run before the ManagerItem has been unregistered */\r\n    public uninstall(): any { }\r\n\r\n    /** Basically removes a ManagerItem, in order to recover the ManagerItem, it needs to be re-added to an AdvancedManager */\r\n    public unregister() {\r\n        this.uninstall();\r\n\r\n        this.manager.remove(this.key);\r\n        this.key = null;\r\n        this.manager = null;\r\n        this.app = null;\r\n        this.config = null;\r\n        this.emitter = null;\r\n    }\r\n}\r\n\r\n/** A tweak to the Manager class that makes it self aware of the App class it's instantiated in */\r\nexport class AdvancedManager<K, V extends ManagerItem> extends Manager<K, V> {\r\n    /** The App the AdvancedManager is attached to */\r\n    public app: IApp;\r\n\r\n    /** The Config of the App the AdvancedManager is attached to */\r\n    public config: ICONFIG;\r\n\r\n    /** The EventEmitter of the App the AdvancedManager is attached to */\r\n    public emitter: EventEmitter;\r\n\r\n    /** Register App details */\r\n    constructor(app: IApp) {\r\n        super();\r\n        this.app = app;\r\n        this.config = app.config;\r\n        this.emitter = app.emitter;\r\n    }\r\n\r\n    /** Add a ManagerItem to AdvancedManager at a specified key */\r\n    public set(key: K, value: V) {\r\n        super.set(key, value);\r\n        value.register(this, key);\r\n        return this;\r\n    }\r\n}\r\n\r\nexport { Manager, methodCall };\r\n", "export const newURL = (url: string | URL | Location = window.location.href): URL => {\r\n    return url instanceof URL ? url : new URL(url as unknown as string, window.location.origin);\r\n};\r\n\r\n/** Returns the pathname with the hash at the end */\r\nexport const getHashedPath = (url: URL | string): string => {\r\n    let _url = newURL(url);\r\n    return `${_url.pathname}${_url.hash}`;\r\n};\r\n\r\n/** Returns the actual hash without the hashtag */\r\nexport const getHash = (url: URL | string): string => newURL(url).hash.slice(1);\r\n\r\n/** Removes the hash from the full URL for a clean URL string */\r\nexport const clean = (url: URL | string): string => newURL(url).toString().replace(/(\\/#.*|\\/|#.*)$/, '');\r\n\r\n/** Compares two URLs to each other */\r\nexport const equal = (a: URL | string, b: URL | string): boolean => (clean(a) === clean(b));\r\n\r\n", "import { AdvancedManager, ManagerItem, methodCall } from \"./manager\";\r\nimport { IApp } from \"./app\";\r\n\r\n/** Controls specific kinds of actions that require JS */\r\nexport class Service extends ManagerItem {\r\n\t/** Called before the start of a Service, represents a constructor of sorts */\r\n\tpublic init(...args: any): any;\r\n\tpublic init(): any { }\r\n\r\n\t/** Called on start of Service */\r\n\tpublic boot(...args: any): any;\r\n\tpublic boot(): any {\r\n\t\tthis.initEvents();\r\n\t}\r\n\r\n\t/** Initialize events */\r\n\tpublic initEvents(): void { }\r\n\r\n\t/** Stop events */\r\n\tpublic stopEvents(): void { }\r\n\r\n\t/** Stop Service */\r\n\tpublic stop(): void {\r\n\t\tthis.stopEvents();\r\n\t\tthis.unregister();\r\n\t}\r\n}\r\n\r\n/** The Service Manager controls the lifecycle of all Services in an App */\r\nexport class ServiceManager extends AdvancedManager<string, Service> {\r\n\tconstructor(app: IApp) {\r\n\t\tsuper(app);\r\n\t}\r\n\r\n\t/** Call the init method for all Services */\r\n\tpublic init(): ServiceManager {\r\n\t\tmethodCall(this, \"init\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Call the boot method for all Services */\r\n\tpublic boot(): ServiceManager {\r\n\t\tmethodCall(this, \"boot\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Call the stop method for all Services */\r\n\tpublic stop(): ServiceManager {\r\n\t\tmethodCall(this, \"stop\");\r\n\t\treturn this;\r\n\t}\r\n}\r\n", "import { Service } from \"./service\";\r\nimport { getHashedPath, newURL } from \"./url\";\r\n\r\nexport type TypeTrigger = HTMLAnchorElement | \"HistoryManager\" | \"popstate\" | \"back\" | \"forward\";\r\nexport interface ICoords {\r\n\treadonly x: number;\r\n\treadonly y: number;\r\n}\r\n\r\nexport interface IStateData {\r\n\tscroll: ICoords;\r\n\t[key: string]: any;\r\n}\r\n\r\nexport interface IState {\r\n\turl: string;\r\n\tindex?: number;\r\n\ttransition: string;\r\n\tdata: IStateData;\r\n}\r\n\r\nexport interface IHistoryItem {\r\n\tindex: number;\r\n\tstates: IState[];\r\n}\r\n\r\n/** A quick snapshot of page scroll coordinates */\r\nexport const newCoords = (x: number = window.scrollX, y: number = window.scrollY): ICoords => ({ x, y });\r\n\r\n/** Creates a state; a state represents the current status of the page consisting of properties like: url, transition, and data */\r\nexport const newState = (state: IState = {\r\n\turl: getHashedPath(newURL()),\r\n\tindex: 0,\r\n\ttransition: \"default\",\r\n\tdata: {\r\n\t\tscroll: newCoords(),\r\n\t\ttrigger: \"HistoryManager\"\r\n\t}\r\n}): IState => (state);\r\n\r\n/** Keeps a record of the history of the App; it stores only the states of Pages */\r\nexport class HistoryManager extends Service {\r\n\tpublic states: IState[];\r\n\tpublic pointer = -1;\r\n\r\n\t/** Initializes the states array, and replace the history pushState data with the states array */\r\n\tinit() {\r\n\t\tthis.states = [];\r\n\r\n\t\tlet state = newState();\r\n\t\tthis.add(state, \"replace\");\r\n\t}\r\n\r\n\t/** Get a state based on it's index */\r\n\tpublic get(index: number) {\r\n\t\treturn this.states[index];\r\n\t}\r\n\r\n\t/** Add a state to HistoryManager and change the history pushState data based on the historyAction specified */\r\n\tpublic add(value?: IState, historyAction: \"replace\" | \"push\" = \"push\"): HistoryManager {\r\n\t\tlet state = newState(value);\r\n\t\tlet len = this.length;\r\n\t\tthis.states.push({ ...state });\r\n\t\tthis.pointer = len;\r\n\r\n\t\tlet item: IHistoryItem = {\r\n\t\t\tindex: this.pointer,\r\n\t\t\tstates: [...this.states]\r\n\t\t};\r\n\t\tchangeState(historyAction, state, item);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic remove(index?: number) {\r\n\t\tif (index) {\r\n\t\t\tthis.states.splice(index, 1);\r\n\t\t} else {\r\n\t\t\tthis.states.pop();\r\n\t\t}\r\n\r\n\t\tthis.pointer--;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Replaces the states array with another states array, this is later used when going back and forward in page history */\r\n\tpublic replace(newStates: IState[]) {\r\n\t\tthis.states = newStates;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Set state by index. */\r\n\tpublic set(i: number, state: IState) {\r\n\t\treturn (this.states[i] = state);\r\n\t}\r\n\r\n\t/** Get the current state */\r\n\tget current(): IState {\r\n\t\treturn this.get(this.pointer);\r\n\t}\r\n\r\n\t/** Get the last state (top of the history stack). */\r\n\tget last(): IState {\r\n\t\treturn this.get(this.length - 1);\r\n\t}\r\n\r\n\t/** Get the previous state. */\r\n\tget previous(): IState | null {\r\n\t\treturn this.pointer < 1 ? null : this.get(this.pointer - 1);\r\n\t}\r\n\r\n\tget length() {\r\n\t\treturn this.states.length;\r\n\t}\r\n}\r\n\r\nexport interface IHistoryManager extends HistoryManager { }\r\n\r\n/** Either push or replace history state */\r\nexport const changeState = (action: \"push\" | \"replace\", state: IState, item: object) => {\r\n\tlet href = getHashedPath(state.url);\r\n\tlet args = [item, \"\", href];\r\n\t\r\n\tif (window.history) {\r\n\t\tswitch (action) {\r\n\t\t\tcase \"push\":\r\n\t\t\t\twindow.history.pushState.apply(window.history, args);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"replace\":\r\n\t\t\t\twindow.history.replaceState.apply(window.history, args);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n};\r\n", "/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    // tslint:disable-next-line\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map(token => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function(pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\"\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map(path => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x\n  } = options;\n  const endsWith = `[${escapeString(options.endsWith || \"\")}]|$`;\n  const delimiter = `[${escapeString(options.delimiter || \"/#?\")}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiter}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWith})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n        : // tslint:disable-next-line\n          endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiter}(?=${endsWith}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiter}|${endsWith})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "import { Manager, ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { equal, newURL } from \"./url\";\r\nimport { toAttr } from \"./config\";\r\nimport { Service } from \"./service\";\r\nimport { IgnoreURLsList } from \"./pjax\";\r\nimport { pathToRegexp } from \"path-to-regexp\";\r\n\r\n/**\r\n * Parses strings to DOM\r\n */\r\nexport const PARSER: DOMParser = new DOMParser();\r\n\r\n/** A page represents the DOM elements that create each page */\r\nexport class Page extends ManagerItem {\r\n    /** Holds the DOM of the current page */\r\n    public dom: Document;\r\n\r\n    /** Holds the wrapper element to be swapped out of each Page */\r\n    public wrapper: HTMLElement;\r\n\r\n    /** Holds the title of each page */\r\n    public title: string;\r\n\r\n    /** Holds the head element of each page */\r\n    public head: Element;\r\n\r\n    /** Holds the body element of each page */\r\n    public body: Element;\r\n\r\n    /** The URL of the current page */\r\n    public url: URL;\r\n\r\n    /** The payload of a page request */\r\n    public data: string;\r\n\r\n    /** Attr that identifies the wrapper */\r\n    public wrapperAttr: string;\r\n\r\n    constructor(url: string | URL = newURL(), dom: string | Document = document) {\r\n        super();\r\n        this.url = newURL(url);\r\n\r\n        if (typeof dom === \"string\") {\r\n            this.data = dom;\r\n        } else this.dom = dom || document;\r\n    }\r\n\r\n    /** Builds the page's dom, and sets the title, head, body, and wrapper properties of the Page class */\r\n    public async build() {\r\n        if (!(this.dom instanceof Node)) {\r\n            this.dom = PARSER.parseFromString(this.data, \"text/html\");\r\n        }\r\n\r\n        if (!(this.body instanceof Node)) {\r\n            let { title, head, body } = this.dom;\r\n            this.title = title;\r\n            this.head = head;\r\n            this.body = body;\r\n            this.wrapper = this.body.querySelector(this.wrapperAttr);\r\n        }\r\n    }\r\n\r\n    public install() {\r\n        this.wrapperAttr = toAttr(this.config, \"wrapperAttr\");\r\n    }\r\n\r\n    public uninstall() {\r\n        this.url = null;\r\n        this.title = null;\r\n        this.head = null;\r\n        this.body = null;\r\n        this.dom = null;\r\n        this.wrapper = null;\r\n        this.data = null;\r\n        this.wrapperAttr = null;\r\n    }\r\n}\r\n\r\nexport interface IPage extends Page { }\r\n\r\n/** Controls which page to load */\r\nexport class PageManager extends Service {\r\n    /** Stores all fetch requests that are currently loading */\r\n    public loading: Manager<string, Promise<string>> = new Manager();\r\n    public pages: AdvancedManager<string, Page>;\r\n\r\n    /** URLs to ignore caching */\r\n    public cacheIgnore: IgnoreURLsList | boolean;\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /** Instantiate pages, and add the current page to pages */\r\n    install() {\r\n        this.pages = new AdvancedManager(this.app);\r\n        this.cacheIgnore = this.config.cacheIgnore;\r\n\r\n        let URLString = newURL().pathname;\r\n        this.set(URLString, new Page());\r\n        URLString = null;\r\n    }\r\n\r\n    get(key: string) { return this.pages.get(key); }\r\n    add(value: IPage) { this.pages.add(value); return this; }\r\n    set(key: string, value: IPage) { this.pages.set(key, value); return this; }\r\n    remove(key: string) { this.pages.remove(key); return this; }\r\n    has(key: string) { return this.pages.has(key); }\r\n    clear() { this.pages.clear(); return this; }\r\n    get size() { return this.pages.size; }\r\n    keys() { return this.pages.keys(); }\r\n\r\n    /** Load from cache or by requesting URL via a fetch request, avoid requesting for the same thing twice by storing the fetch request in \"this.loading\" */\r\n    public async load(_url: URL | string = newURL()): Promise<Page> {\r\n        let url: URL = newURL(_url);\r\n        let urlString: string = url.pathname;\r\n        let page: Page, request: Promise<string>;\r\n\r\n        if (this.has(urlString) && !ignoreURLs(urlString, this.cacheIgnore)) {\r\n            page = this.get(urlString);\r\n            return Promise.resolve(page);\r\n        }\r\n\r\n        if (!this.loading.has(urlString)) {\r\n            request = this.request(urlString);\r\n            this.loading.set(urlString, request);\r\n        } else request = this.loading.get(urlString);\r\n\r\n        let response = await request;\r\n        this.loading.remove(urlString);\r\n\r\n        page = new Page(url, response);\r\n        this.set(urlString, page);\r\n\r\n        if (this.size > this.config.maxPages) {\r\n            let currentUrl = newURL();\r\n            let keys = this.keys();\r\n            let first = equal(currentUrl, keys[0]) ? keys[1] : keys[0];\r\n            let page = this.get(first);\r\n            page.unregister();\r\n            page = null;\r\n            keys = null;\r\n            currentUrl = null;\r\n            first = null;\r\n        }\r\n\r\n        return page;\r\n    }\r\n\r\n    /** Starts a fetch request */\r\n    public async request(url: string): Promise<string> {\r\n        const headers = new Headers(this.config.headers);\r\n        const timeout = window.setTimeout(() => {\r\n            window.clearTimeout(timeout);\r\n\r\n            const err = new Error(\"Request Timed Out!\");\r\n            this.emitter.emit(\"TIMEOUT_ERROR\", err);\r\n            throw err;\r\n        }, this.config.timeout);\r\n\r\n        try {\r\n            let response = await fetch(url, {\r\n                mode: 'same-origin',\r\n                method: \"GET\",\r\n                headers,\r\n                cache: \"default\",\r\n                credentials: \"same-origin\",\r\n            });\r\n\r\n            window.clearTimeout(timeout);\r\n            if (response.status >= 200 && response.status < 300)\r\n                return await response.text();\r\n\r\n            const err = new Error(response.statusText || \"\" + response.status);\r\n            this.emitter.emit(\"REQUEST_ERROR\", err);\r\n            throw err;\r\n        } catch (err) {\r\n            window.clearTimeout(timeout);\r\n            throw err;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/** Check if url is supposed to be ignored */\r\nexport const ignoreURLs = (urlString: string, ignoreList: boolean | IgnoreURLsList) => {\r\n    if (typeof ignoreList == \"boolean\")\r\n        return ignoreList;\r\n\r\n    let _keys = [];\r\n    return !(ignoreList as IgnoreURLsList)\r\n        .every(val => pathToRegexp(val, _keys, {\r\n            start: false,\r\n            end: false\r\n        }).exec(urlString) == null);\r\n}\r\n\r\nexport interface IPageManager extends PageManager { }", "import { Manager } from \"./manager\";\r\nimport { ICoords, newCoords, TypeTrigger } from \"./history\";\r\nimport { IPage } from \"./page\";\r\nimport { toAttr } from \"./config\";\r\nimport { Service } from \"./service\";\r\nimport { newURL } from \"./url\";\r\n\r\n/**\r\n * The async function type, allows for smooth transition between Promises\r\n */\r\nexport type TypeAsyncFn = (value?: any) => void;\r\nexport interface ITransition {\r\n    oldPage?: IPage;\r\n    newPage?: IPage;\r\n    trigger?: TypeTrigger;\r\n    scroll?: { x: number; y: number };\r\n    manualScroll?: boolean;\r\n    init?: (data: InitialTransitionData) => void;\r\n    in?: (data: ITransitionData) => any;\r\n    out?: (data: ITransitionData) => any;\r\n    [key: string]: any;\r\n}\r\n\r\nexport interface InitialTransitionData {\r\n    trigger?: TypeTrigger;\r\n    scroll?: ICoords;\r\n    oldPage: IPage;\r\n    newPage: IPage;\r\n    ignoreHashAction: boolean;\r\n}\r\n\r\nexport interface ITransitionData extends InitialTransitionData {\r\n    from?: IPage;\r\n    to?: IPage;\r\n    done: TypeAsyncFn;\r\n}\r\n\r\n/** Auto scrolls to an elements position if the element has an hash */\r\nexport const hashAction = (coords?: ICoords, hash: string = window.location.hash) => {\r\n    try {\r\n        let _hash = hash[0] == \"#\" ? hash : newURL(hash).hash;\r\n        if (_hash.length > 1) {\r\n            let el = document.getElementById(_hash.slice(1));\r\n            if (el) {\r\n                let { left, top } = el.getBoundingClientRect();\r\n                let scrollLeft = window.scrollX;\r\n                let scrollTop = window.scrollY;\r\n                let x = left + scrollLeft;\r\n                let y = top + scrollTop;\r\n\r\n                return newCoords(x, y);\r\n            }\r\n        }\r\n    } catch (e) {\r\n        console.warn(\"[hashAction] error\", e);\r\n    }\r\n\r\n    return coords ?? newCoords(0, 0);\r\n};\r\n\r\n// The Default Transition\r\nexport const Replace: ITransition = { name: \"replace\" };\r\n\r\n/** Controls which Transition between pages to use */\r\nexport class TransitionManager extends Service {\r\n    public transitions: Manager<string, ITransition>;\r\n    private _arg: Array<[string, ITransition]>;\r\n    constructor(transitions?: Array<[string, ITransition]>) {\r\n        super();\r\n        this._arg = transitions;\r\n    }\r\n\r\n    /** On Service install set Config */\r\n    public install() {\r\n        super.install();\r\n\r\n        let transitions = this._arg && this._arg.length ? this._arg : this.config.transitions;\r\n\r\n        // Manager like Maps use the most recent [key, value] Array it knows, replacing the default transition\r\n        // with any other transitions called [\"default\", ...]\r\n        this.transitions = new Manager([\r\n            [\"default\", Replace],\r\n            [\"replace\", Replace],\r\n        ].concat(transitions) as Array<[string, ITransition]>);\r\n    }\r\n\r\n    get(key: string) { return this.transitions.get(key); }\r\n    set(key: string, value: ITransition) { this.transitions.set(key, value); return this; }\r\n    add(value: ITransition) { this.transitions.add(value); return this; }\r\n    has(key: string) { return this.transitions.has(key); }\r\n\r\n    /** Starts a transition */\r\n    public async start(name: string, data: InitialTransitionData): Promise<InitialTransitionData> {\r\n        let transition: ITransition = this.transitions.get(name);\r\n        let { oldPage, newPage, ignoreHashAction, trigger } = data;\r\n        this.emitter.emit(\"TRANSITION_START\", { transitionName: name, ...data });\r\n\r\n        if (!(\"wrapper\" in oldPage) || !(\"wrapper\" in newPage))\r\n            throw `[TransitionManager] either oldPage or newPage aren't instances of the Page Class.\\n ${{ newPage, oldPage }}`;\r\n\r\n        // Replace the title\r\n        document.title = `` + newPage.title;\r\n\r\n        let fromWrapper = oldPage.wrapper;\r\n        let toWrapper = newPage.wrapper;\r\n        if (!(fromWrapper instanceof Node) || !(toWrapper instanceof Node))\r\n            throw `[TransitionManager] the wrapper from the ${!(toWrapper instanceof Node) ? \"next\" : \"current\"\r\n            } page cannot be found. The wrapper must be an element that has the attribute ${toAttr(this.config, \"wrapperAttr\")}.`;\r\n\r\n        // Give the Transition all the background data it may require\r\n        transition.init && transition?.init(data);\r\n        this.emitter.emit(\"BEFORE_TRANSITION_OUT\", data);\r\n\r\n        // Start the out point of the Transition\r\n        if (transition.out) {\r\n            await new Promise(done => {\r\n                let outMethod: Promise<any> = transition.out.call(transition,\r\n                    { ...data, from: oldPage, done, }\r\n                );\r\n\r\n                outMethod?.then(done);\r\n            });\r\n        }\r\n\r\n        this.emitter.emit(\"AFTER_TRANSITION_OUT\", data);\r\n\r\n        // Add the new wrapper before the old one\r\n        await new Promise<void>(done => {\r\n            fromWrapper.insertAdjacentElement(\"beforebegin\", toWrapper);\r\n            this.emitter.emit(\"CONTENT_INSERT\", data);\r\n            done();\r\n        });\r\n\r\n        // Replace the old wrapper with the new one\r\n        await new Promise<void>(done => {\r\n            fromWrapper.remove();\r\n            fromWrapper = null;\r\n            toWrapper = null;\r\n\r\n            this.emitter.emit(\"CONTENT_REPLACED\", data);\r\n\r\n            if (!ignoreHashAction && !/back|popstate|forward/.test(trigger as string))\r\n                data.scroll = hashAction(data.scroll);\r\n            done();\r\n        });\r\n\r\n        this.emitter.emit(\"BEFORE_TRANSITION_IN\", data);\r\n\r\n        // Start the `in` point of the Transition (only the `in` method has access to the hashAction's scroll position)\r\n        if (transition.in) {\r\n            await new Promise(done => {\r\n                let inMethod: Promise<any> = transition.in.call(transition,\r\n                    { ...data, from: oldPage, to: newPage, done }\r\n                );\r\n\r\n                inMethod?.then(done);\r\n            });\r\n        }\r\n\r\n        this.emitter.emit(\"AFTER_TRANSITION_IN\", data);\r\n\r\n        // If the transition doesn't handle scroll itself, fallback on the transition manager handling it after the fact\r\n        if (!transition.manualScroll) {\r\n            if (!ignoreHashAction && !/back|popstate|forward/.test(trigger as string))\r\n                data.scroll = hashAction(data.scroll);\r\n\r\n            window.scroll(data.scroll.x, data.scroll.y);\r\n        }\r\n\r\n        this.emitter.emit(\"TRANSITION_END\", { transitionName: name, ...data });\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ITransitionManager extends TransitionManager { }", "import { EventEmitter, TypeEventInput } from \"@okikio/emitter\";\r\nimport { ServiceManager, Service } from \"./service\";\r\nimport { newConfig, ICONFIG } from \"./config\";\r\nimport { ITransitionData } from \"./transition\";\r\nimport { StateEvent } from \"./pjax\";\r\n\r\nexport interface IApp extends App { }\r\n\r\nexport type TypeAllEvents = \"REQUEST_ERROR\" | \"TIMEOUT_ERROR\" | \"ANCHOR_HOVER\" | \"HOVER\" | \"ANCHOR_CLICK\" | \"CLICK\" | \"PREFETCH\" | \"POPSTATE\" | \"POPSTATE_BACK\" | \"POPSTATE_FORWARD\" | \"HISTORY_NEW_ITEM\" | \"GO\" | \"NAVIGATION_START\" | \"PAGE_LOADING\" | \"PAGE_LOAD_COMPLETE\" | \"NAVIGATION_END\" | \"TRANSITION_START\" | \"TRANSITION_END\" | \"BEFORE_TRANSITION_OUT\" | \"AFTER_TRANSITION_OUT\" | \"CONTENT_INSERT\" | \"CONTENT_REPLACED\" | \"BEFORE_TRANSITION_IN\" | \"AFTER_TRANSITION_IN\" | \"READY\" | \"ready\" | \"SCROLL\" | \"scroll\" | \"RESIZE\" | \"resize\";\r\n\r\nexport type TypeEmitArgs = (\r\n    (ITransitionData & { oldHref: string, href: string, transitionName: string })\r\n    | StateEvent | Error | void | any\r\n)[];\r\nexport type TypeAppListenerCallback = (...args: TypeEmitArgs) => void;\r\n\r\n/** The App class starts the entire process, it controls all managers and all services */\r\nexport class App {\r\n    /** An instance of the ServiceManager */\r\n    public services: ServiceManager;\r\n\r\n    /** An instance of an EventEmitter */\r\n    public emitter: EventEmitter;\r\n\r\n    /** The current Configuration's for the App */\r\n    public config: ICONFIG;\r\n\r\n    protected canResize = true;\r\n    protected canScroll = true;\r\n    constructor(config: ICONFIG = {}) {\r\n        this._resize = this._resize.bind(this);\r\n        this._scroll = this._scroll.bind(this);\r\n        this._ready = this._ready.bind(this);\r\n        this.register(config);\r\n    }\r\n\r\n    /** Create new instances of the ServiceManager, EventEmitter and the configurations */\r\n    public register(config: ICONFIG = {}): App {\r\n        this.config = newConfig(config);\r\n        this.emitter = new EventEmitter();\r\n        this.services = new ServiceManager(this);\r\n        return this;\r\n    }\r\n\r\n    protected _ready() {\r\n        document.removeEventListener(\"DOMContentLoaded\", this._ready);\r\n        window.removeEventListener(\"load\", this._ready);\r\n        this.emitter.emit(\"READY ready\");\r\n    }\r\n\r\n    protected _resize() {\r\n        if (this.canResize) {\r\n            let timer: number | void, raf: number | void;\r\n            this.canResize = false;\r\n            raf = window.requestAnimationFrame(() => {\r\n                this.emitter.emit(\"RESIZE resize\");\r\n\r\n                // set a timeout to un-throttle\r\n                timer = window.setTimeout(() => {\r\n                    this.canResize = true;\r\n                    timer = window.clearTimeout(timer as number);\r\n                    raf = window.cancelAnimationFrame(raf as number);\r\n                }, this.config.resizeDelay);\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _scroll() {\r\n        if (this.canScroll) {\r\n            let raf: number | void;\r\n            this.canScroll = false;\r\n            raf = requestAnimationFrame(() => {\r\n                this.emitter.emit(\"SCROLL scroll\");\r\n\r\n                this.canScroll = true;\r\n                raf = window.cancelAnimationFrame(raf as number);\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Shortcuts for getting Services */\r\n    public get(key: string): Service {\r\n        return this.services.get(key);\r\n    }\r\n\r\n    /** Shortcuts for setting Services */\r\n    public set(key: string, value: Service): App {\r\n        this.services.set(key, value);\r\n        return this;\r\n    }\r\n\r\n    /** Shortcuts for adding Services */\r\n    public add(value: Service): App {\r\n        this.services.add(value);\r\n        return this;\r\n    }\r\n\r\n    /** Initialize and boot all Services */\r\n    public boot(): App {\r\n        document.addEventListener(\"DOMContentLoaded\", this._ready);\r\n        window.addEventListener(\"load\", this._ready);\r\n\r\n        window.addEventListener(\"resize\", this._resize, { passive: true });\r\n        window.addEventListener(\"scroll\", this._scroll, { passive: true });\r\n\r\n        this.services.init();\r\n        this.services.boot();\r\n        return this;\r\n    }\r\n\r\n    /** Stops all Services and clears the even emitter of all events and listeners */\r\n    public stop(): App {\r\n        window.removeEventListener(\"resize\", this._resize);\r\n        window.removeEventListener(\"scroll\", this._scroll);\r\n\r\n        this.services.stop();\r\n        this.emitter.clear();\r\n        return this;\r\n    }\r\n\r\n    /** Shortcuts to the App EventEmitter on method */\r\n    public on(events: TypeAllEvents | TypeEventInput, callback?: TypeAppListenerCallback): App {\r\n        this.emitter.on(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /** Shortcuts to the App EventEmitter off method */\r\n    public off(events: TypeAllEvents | TypeEventInput, callback?: TypeAppListenerCallback): App {\r\n        this.emitter.off(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /** Shortcuts to the App EventEmitter emit method */\r\n    public emit(events: TypeAllEvents | string | string[], ...args: TypeEmitArgs): App {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n}\r\n", "import { newState, TypeTrigger, newCoords, IHistoryItem, IHistoryManager } from \"./history\";\r\nimport { Service } from \"./service\";\r\nimport { ignoreURLs, IPage, IPageManager } from \"./page\";\r\nimport { newURL, getHashedPath, equal } from \"./url\";\r\nimport { toAttr } from \"./config\";\r\nimport { ITransitionManager } from \"./transition\";\r\n\r\nexport type LinkEvent = MouseEvent | TouchEvent;\r\nexport type StateEvent = LinkEvent | PopStateEvent;\r\nexport type IgnoreURLsList = Array<RegExp | string>;\r\n\r\n/**\r\n * Creates a barbajs based PJAX Service, for the native framework\r\n * Based on barbajs and StartingBlocks\r\n */\r\nexport class PJAX extends Service {\r\n    /** URLs to disable PJAX for */\r\n    public preventURLs: boolean | IgnoreURLsList;\r\n\r\n    /** URLs to ignore when prefetching / Whether or not to disable prefetching */\r\n    public prefetchIgnore: boolean | IgnoreURLsList;\r\n\r\n    /** Current state of transitions */\r\n    public isTransitioning: boolean;\r\n\r\n    /** Ignore extra clicks of an anchor element if a transition has already started */\r\n    public onTransitionPreventClick: boolean;\r\n\r\n    /** On page change (excluding popstate events) keep current scroll position */\r\n    public stickyScroll: boolean;\r\n\r\n    /** Force load a page if an error occurs */\r\n    public forceOnError: boolean;\r\n\r\n    /** Ignore hash action if set to true */\r\n    public ignoreHashAction: boolean;\r\n    public install() {\r\n        super.install();\r\n\r\n        this.preventURLs = this.config.preventURLs;\r\n        this.prefetchIgnore = this.config.prefetchIgnore;\r\n        this.onTransitionPreventClick = this.config.onTransitionPreventClick;\r\n        this.stickyScroll = this.config.stickyScroll;\r\n        this.forceOnError = this.config.forceOnError;\r\n        this.ignoreHashAction = this.config.ignoreHashAction;\r\n    }\r\n\r\n    /** Sets the transition state to either true or false */\r\n    public transitionStart() {\r\n        this.isTransitioning = true;\r\n    }\r\n\r\n    public transitionStop() {\r\n        this.isTransitioning = false;\r\n    }\r\n\r\n    public init() {\r\n        /**\r\n         * Bind the event listeners to the PJAX class\r\n         *\r\n         * @memberof PJAX\r\n         */\r\n        this.onHover = this.onHover.bind(this);\r\n        this.onClick = this.onClick.bind(this);\r\n        this.onStateChange = this.onStateChange.bind(this);\r\n    }\r\n\r\n    /** Starts the PJAX Service */\r\n    public boot() {\r\n        super.boot();\r\n    }\r\n\r\n    /** Gets the transition to use for a certain anchor */\r\n    public getTransitionName(el: HTMLAnchorElement): string | null {\r\n        if (!el || !el.getAttribute) return null;\r\n        let transitionAttr = el.getAttribute(\r\n            toAttr(this.config, \"transitionAttr\", false)\r\n        );\r\n\r\n        if (typeof transitionAttr === \"string\") return transitionAttr;\r\n        return null;\r\n    }\r\n\r\n    /** Checks to see if the anchor is valid */\r\n    public validLink(\r\n        el: HTMLAnchorElement,\r\n        event: LinkEvent | KeyboardEvent,\r\n        href: string\r\n    ): boolean {\r\n        let pushStateSupport = !window.history.pushState;\r\n        let exists = !el || !href;\r\n        let eventMutate =\r\n            (event as KeyboardEvent).metaKey ||\r\n            (event as KeyboardEvent).ctrlKey ||\r\n            (event as KeyboardEvent).shiftKey ||\r\n            (event as KeyboardEvent).altKey;\r\n        let newTab =\r\n            el.hasAttribute(\"target\") &&\r\n            (el as HTMLAnchorElement).target === \"_blank\";\r\n        let crossOrigin =\r\n            (el as HTMLAnchorElement).protocol !== location.protocol ||\r\n            (el as HTMLAnchorElement).hostname !== location.hostname;\r\n        let download = typeof el.getAttribute(\"download\") === \"string\";\r\n        let preventSelf = el.matches(toAttr(this.config, \"preventSelfAttr\"));\r\n        let preventAll = Boolean(\r\n            el.closest(toAttr(this.config, \"preventAllAttr\"))\r\n        );\r\n        let preventURL = ignoreURLs(newURL(href).pathname, this.preventURLs);\r\n        let sameURL = getHashedPath(newURL()) === getHashedPath(newURL(href));\r\n        return !(\r\n            exists ||\r\n            pushStateSupport ||\r\n            eventMutate ||\r\n            newTab ||\r\n            crossOrigin ||\r\n            download ||\r\n            preventSelf ||\r\n            preventAll ||\r\n            preventURL ||\r\n            sameURL\r\n        );\r\n    }\r\n\r\n    /** Returns the href of an Anchor element */\r\n    public getHref(el: HTMLAnchorElement): string | null {\r\n        if (\r\n            el &&\r\n            el.tagName &&\r\n            el.tagName.toLowerCase() === \"a\" &&\r\n            typeof el.href === \"string\"\r\n        )\r\n            return el.href;\r\n        return null;\r\n    }\r\n\r\n    /** Check if event target is a valid anchor with an href, if so, return the anchor */\r\n    public getLink(event: LinkEvent): HTMLAnchorElement {\r\n        let el = event.target as HTMLAnchorElement;\r\n        let href: string = this.getHref(el);\r\n\r\n        while (el && !href) {\r\n            el = (el as HTMLElement).parentNode as HTMLAnchorElement;\r\n            href = this.getHref(el);\r\n        }\r\n\r\n        // Check for a valid link\r\n        if (!el || !this.validLink(el, event, href)) return;\r\n        return el;\r\n    }\r\n\r\n    /** When an element is clicked, get valid anchor element, go for a transition */\r\n    public onClick(event: LinkEvent) {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        if (this.isTransitioning && this.onTransitionPreventClick) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            return;\r\n        }\r\n\r\n        let href = this.getHref(el);\r\n        this.emitter.emit(\"ANCHOR_CLICK CLICK\", event);\r\n        this.go({ href, trigger: el, event });\r\n    }\r\n\r\n    /** Returns the direction of the State change as a String, either the Back button or the Forward button */\r\n    public getDirection(value: number): TypeTrigger {\r\n        if (Math.abs(value) > 1) {\r\n            // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\r\n            return value > 0 ? \"forward\" : \"back\";\r\n        } else {\r\n            if (value === 0) return \"popstate\";\r\n            else {\r\n                // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\r\n                return value > 0 ? \"back\" : \"forward\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Force a page to go to a certain URL */\r\n    public force(href: string): void {\r\n        window.location.assign(href);\r\n    }\r\n\r\n    /**\r\n     * If transition is running force load page.\r\n     * Stop if currentURL is the same as new url.\r\n     * On state change, change the current state history, to reflect the direction of said state change\r\n     * Load page and page transition.\r\n     */\r\n    public go({ href, trigger = \"HistoryManager\", event }: {\r\n        href: string;\r\n        trigger?: TypeTrigger;\r\n        event?: StateEvent;\r\n    }): Promise<void> {\r\n        // If transition is already running and the go method is called again, force load page\r\n        if (this.isTransitioning && !this.onTransitionPreventClick || !(\r\n            this.manager.has(\"TransitionManager\") &&\r\n            this.manager.has(\"HistoryManager\") &&\r\n            this.manager.has(\"PageManager\")\r\n        )) {\r\n            this.force(href);\r\n            return;\r\n        }\r\n\r\n        const history = this.manager.get(\"HistoryManager\") as IHistoryManager;\r\n        let scroll = newCoords(0, 0);\r\n        let currentState = history.current;\r\n        let currentURL = currentState.url;\r\n        if (equal(currentURL, href)) return;\r\n\r\n        let transitionName: string;\r\n        if (event && (event as PopStateEvent).state) {\r\n            this.emitter.emit(\"POPSTATE\", event);\r\n\r\n            // If popstate, get back/forward direction.\r\n            let { state }: { state: IHistoryItem } = event as PopStateEvent;\r\n            let { index } = state;\r\n            let currentIndex = currentState.index;\r\n            let difference = currentIndex - index;\r\n            history.replace(state.states);\r\n            history.pointer = index;\r\n\r\n            let _state = history.get(index);\r\n            transitionName = _state.transition;\r\n            scroll = _state.data.scroll;\r\n\r\n            trigger = this.getDirection(difference);\r\n\r\n            // Based on the direction of the state change either remove or add a state\r\n            this.emitter.emit(trigger === \"back\" ? `POPSTATE_BACK` : `POPSTATE_FORWARD`, event);\r\n        } else {\r\n            // Add new state\r\n            transitionName = this.getTransitionName(trigger as HTMLAnchorElement);\r\n\r\n            scroll = newCoords();\r\n            let state = newState({\r\n                url: href,\r\n                transition: transitionName,\r\n                data: { scroll },\r\n            });\r\n\r\n            !this.stickyScroll && (scroll = newCoords(0, 0));\r\n\r\n            history.add(state);\r\n            this.emitter.emit(\"HISTORY_NEW_ITEM\", event);\r\n        }\r\n\r\n        if (event) {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n\r\n        this.emitter.emit(\"GO\", event);\r\n        return this.load({ oldHref: currentURL, href, trigger, transitionName, scroll });\r\n    }\r\n\r\n    /** Load the new Page as well as a Transition; starts the Transition */\r\n    public async load({\r\n        oldHref, href, trigger,\r\n        transitionName = \"default\",\r\n        scroll = { x: 0, y: 0 },\r\n    }: {\r\n        oldHref: string;\r\n        href: string;\r\n        trigger?: TypeTrigger;\r\n        transitionName?: string;\r\n        scroll?: { x: number; y: number };\r\n    }): Promise<any> {\r\n        try {\r\n            const transitions = this.manager.get(\"TransitionManager\") as ITransitionManager;\r\n            const pages = this.manager.get(\"PageManager\") as IPageManager;\r\n\r\n            let ignoreHashAction = this.ignoreHashAction;\r\n            let newPage: IPage, oldPage: IPage;\r\n\r\n            this.emitter.emit(\"NAVIGATION_START\", { oldHref, href, trigger, transitionName, scroll });\r\n\r\n            if (!transitions.has(transitionName)) {\r\n                console.log(`[PJAX] transition name \"${transitionName}\" doesn't exist, switching to the \"default\" transition`);\r\n                transitionName = \"default\";\r\n            }\r\n\r\n            // Load & Build both the old and new pages\r\n            try {\r\n                this.transitionStart();\r\n                this.emitter.emit(\"PAGE_LOADING\", { href, oldHref, trigger, scroll });\r\n\r\n                oldPage = await pages.load(oldHref);\r\n                newPage = await pages.load(href);\r\n\r\n                this.emitter.emit(\"PAGE_LOAD_COMPLETE\", { newPage, oldPage, trigger, scroll });\r\n\r\n                // If you reload the page, the previous page may not have been built\r\n                // this is to ensure no errors occur\r\n                if (!(oldPage.dom instanceof Element)) oldPage.build();\r\n                newPage.build();\r\n            } catch (err) {\r\n                console.warn(`[PJAX] Page load error`, err);\r\n            }\r\n\r\n            // Transition Between Pages\r\n            try {\r\n                let data = await transitions.start(transitionName, { oldPage, newPage, trigger, scroll, ignoreHashAction });\r\n                scroll = data.scroll;\r\n            } catch (err) {\r\n                console.warn(`[PJAX] Transition error`, err);\r\n            }\r\n\r\n            // Navigation is over\r\n            this.emitter.emit(\"NAVIGATION_END\", { oldPage, newPage, trigger, transitionName, scroll });\r\n        } catch (err) {\r\n            if (this.forceOnError) this.force(href);\r\n            else console.warn(err);\r\n        } finally {\r\n            this.transitionStop(); // Sets isTransitioning to false\r\n        }\r\n    }\r\n\r\n    /** When you hover over an anchor, prefetch the event target's href */\r\n    public onHover(event: LinkEvent): Promise<void> {\r\n        let el = this.getLink(event);\r\n        if (!el || !this.manager.has(\"PageManager\")) return;\r\n\r\n        const pages = this.manager.get(\"PageManager\") as IPageManager;\r\n        let url = newURL(this.getHref(el));\r\n        let urlString: string = url.pathname;\r\n\r\n        this.emitter.emit(\"ANCHOR_HOVER HOVER\", event);\r\n\r\n        // If Url is ignored or already in cache, don't prefetch\r\n        if (ignoreURLs(url.pathname, this.prefetchIgnore)) return;\r\n        if (pages.has(urlString) && !ignoreURLs(urlString, pages.cacheIgnore)) return;\r\n\r\n        try {\r\n            pages.load(url);\r\n            this.emitter.emit(\"PREFETCH\", event);\r\n        } catch (err) {\r\n            console.warn(\"[PJAX] Prefetch error\", err);\r\n        }\r\n    }\r\n\r\n    /** When History state changes, get url from State, go for a Transition. */\r\n    public onStateChange(event: PopStateEvent): void {\r\n        this.go({ href: window.location.href, trigger: \"popstate\", event });\r\n    }\r\n\r\n    /** Initialize DOM Events */\r\n    public initEvents() {\r\n        if (this.prefetchIgnore !== true) {\r\n            document.addEventListener(\"mouseover\", this.onHover);\r\n            document.addEventListener(\"touchstart\", this.onHover);\r\n        }\r\n\r\n        document.addEventListener(\"click\", this.onClick);\r\n        window.addEventListener(\"popstate\", this.onStateChange);\r\n    }\r\n\r\n    /** Stop DOM Events */\r\n    public stopEvents() {\r\n        if (this.prefetchIgnore !== true) {\r\n            document.removeEventListener(\"mouseover\", this.onHover);\r\n            document.removeEventListener(\"touchstart\", this.onHover);\r\n        }\r\n\r\n        document.removeEventListener(\"click\", this.onClick);\r\n        window.removeEventListener(\"popstate\", this.onStateChange);\r\n    }\r\n}\r\n", "import { Service } from \"./service\";\r\nimport { Manager } from \"./manager\";\r\nimport { newURL, getHashedPath } from \"./url\";\r\nimport { IHistoryManager } from \"./history\";\r\nimport { Path, pathToRegexp } from \"path-to-regexp\";\r\n\r\nexport type RouteMethod = (...args: any) => any;\r\nexport type RouteStyle = string | RegExp | boolean | RouteStyle[];\r\nexport interface IRouteToFrom {\r\n    to?: RouteStyle,\r\n    from?: RouteStyle\r\n}\r\n\r\nexport type RoutePath = IRouteToFrom & ({ to: RouteStyle } | { from: RouteStyle }) | RouteStyle;\r\nexport interface IRoute {\r\n    path: RoutePath,\r\n    method: RouteMethod\r\n}\r\n\r\n/** Controls what happens when certain url paths match a set of criteria */\r\nexport class Router extends Service {\r\n    /** List of routes */\r\n    protected routes: Manager<IRouteToFrom, RouteMethod>;\r\n    constructor(routes: IRoute[] = []) {\r\n        super();\r\n        this.routes = new Manager();\r\n        for (let route of routes) {\r\n            this.add(route);\r\n        }\r\n    }\r\n\r\n    /** Add a new route to watch for */\r\n    public add({ path, method }: IRoute): Router {\r\n        let key = this.parse(path);\r\n        this.routes.set(key, method);\r\n        return this;\r\n    }\r\n\r\n    /** Convert strings into path match functions */\r\n    public parsePath(path: RouteStyle): RegExp | boolean {\r\n        if (typeof path === \"string\" || path instanceof RegExp || Array.isArray(path)) {\r\n            let _keys = [];\r\n            return pathToRegexp(path as Path, _keys, {\r\n                start: false,\r\n                end: false\r\n            });\r\n        } else if (typeof path === \"boolean\")\r\n            return path ? /.*/ : path;\r\n\r\n        throw \"[Router] only regular expressions, strings, booleans and arrays of regular expressions and strings are accepted as paths.\";\r\n    }\r\n\r\n    /** Determines if a strings counts has a path */\r\n    public isPath(input: RouteStyle): boolean {\r\n        return (\r\n            typeof input === \"string\" ||\r\n            input instanceof RegExp ||\r\n            typeof input === \"boolean\" ||\r\n            Array.isArray(input)\r\n        );\r\n    }\r\n\r\n    /** Parse the multiple different formats for paths, into a { from, to } object */\r\n    public parse(input: RoutePath): IRouteToFrom {\r\n        let route = input as IRouteToFrom;\r\n        let toFromPath: IRouteToFrom = {\r\n            from: /.*/,\r\n            to: /.*/,\r\n        };\r\n\r\n        if (this.isPath(input as RouteStyle))\r\n            toFromPath = {\r\n                from: true,\r\n                to: input as RouteStyle,\r\n            };\r\n        else if (this.isPath(route.from) && this.isPath(route.to as RouteStyle))\r\n            toFromPath = Object.assign({}, toFromPath, route);\r\n        else\r\n            throw \"[Router] path is neither a string, regular expression, or a { from, to } object.\";\r\n\r\n        let { from, to } = toFromPath;\r\n        return {\r\n            from: this.parsePath(from),\r\n            to: this.parsePath(to),\r\n        };\r\n    }\r\n\r\n    /** Test if route paths are true, if so run their methods */\r\n    public route() {\r\n        if (this.manager.has(\"HistoryManager\")) {\r\n            let history = this.manager.get(\"HistoryManager\") as IHistoryManager;\r\n            let from: string = getHashedPath(newURL((history.length > 1 ? history.previous : history.current).url));\r\n            let to: string = getHashedPath(newURL());\r\n\r\n            this.routes.forEach((method: RouteMethod, path: IRouteToFrom) => {\r\n                let fromRegExp = path.from as RegExp | boolean;\r\n                let toRegExp = path.to as RegExp | boolean;\r\n\r\n                if (\r\n                    typeof fromRegExp === \"boolean\" &&\r\n                    typeof toRegExp === \"boolean\"\r\n                )\r\n                    throw `[Router] path ({ from: ${fromRegExp}, to: ${toRegExp} }) is not valid, remember paths can only be strings, regular expressions, or a boolean; however, both the from and to paths cannot be both booleans.`;\r\n\r\n                let fromParam: RegExpExecArray | RegExp | boolean = fromRegExp;\r\n                let toParam: RegExpExecArray | RegExp | boolean = toRegExp;\r\n\r\n                if (fromRegExp instanceof RegExp && fromRegExp.test(from))\r\n                    fromParam = fromRegExp.exec(from);\r\n\r\n                if (toRegExp instanceof RegExp && toRegExp.test(to))\r\n                    toParam = toRegExp.exec(to);\r\n\r\n                // If fromParam or toParam are `false`, then negate the other param's RegEx\r\n                if (\r\n                    (Array.isArray(toParam) && Array.isArray(fromParam)) ||\r\n                    (Array.isArray(toParam) &&\r\n                        fromParam == false && !(toRegExp as RegExp).test(from)) ||\r\n                    (Array.isArray(fromParam) &&\r\n                        toParam == false && !(fromRegExp as RegExp).test(to))\r\n                )\r\n                    method({\r\n                        from: fromParam,\r\n                        to: toParam,\r\n                        path: { from, to }\r\n                    });\r\n            });\r\n        } else {\r\n            console.warn(\"[Route] HistoryManager is missing.\");\r\n        }\r\n    }\r\n\r\n    /** Add listeners for PJAX Events */\r\n    public initEvents() {\r\n        this.emitter.on(\"READY\", this.route, this);\r\n        this.emitter.on(\"CONTENT_REPLACED\", this.route, this);\r\n    }\r\n\r\n    /** Remove listeners for PJAX Events */\r\n    public stopEvents() {\r\n        this.emitter.off(\"READY\", this.route, this);\r\n        this.emitter.off(\"CONTENT_REPLACED\", this.route, this);\r\n    }\r\n}\r\n", "import { ITransition, ITransitionData, animate } from \"@okikio/native\";\r\n\r\n//== Transition\r\nexport const Fade: ITransition = {\r\n    name: \"default\",\r\n    duration: 500,\r\n    manualScroll: true,\r\n\r\n    out({ from }: ITransitionData) {\r\n        let { duration } = this;\r\n        let fromWrapper = from.wrapper;\r\n        return animate({\r\n            target: fromWrapper,\r\n            opacity: [1, 0],\r\n            duration,\r\n        }).on(\"finish\", function () {\r\n            this.stop();\r\n        });\r\n    },\r\n\r\n    in({ to, scroll }: ITransitionData) {\r\n        let { duration } = this;\r\n        let toWrapper = to.wrapper;\r\n\r\n        window.scroll(scroll.x, scroll.y);\r\n        return animate({\r\n            target: toWrapper,\r\n            opacity: [0, 1],\r\n            duration\r\n        }).then(function () {\r\n            this.stop();\r\n        });\r\n    }\r\n};\r\n", "import { ITransition, ITransitionData, animate } from \"@okikio/native\";\r\n\r\nexport const BigTransition: ITransition = {\r\n    name: \"big\",\r\n    delay: 200,\r\n    durationPerAnimation: 700,\r\n    manualScroll: true,\r\n\r\n    init() {\r\n        this.mainElement = document.getElementById('big-transition');\r\n        this.logoElement = this.mainElement.querySelector('#logo');\r\n        this.horizontalElements = Array.from(this.mainElement.querySelectorAll('#big-transition-horizontal div'));\r\n        this.maxLength = this.horizontalElements.length;\r\n    },\r\n\r\n    out({ from, done }: ITransitionData) {\r\n        let { durationPerAnimation: duration, delay } = this;\r\n        let fromWrapper = from.wrapper;\r\n        \r\n        (async () => {\r\n            let wrapperStyle = Object.assign({}, fromWrapper.style);\r\n            this.mainElement.style.opacity = \"1\";\r\n            this.mainElement.style.visibility = \"visible\";\r\n            let anim1 = animate({\r\n                target: fromWrapper,\r\n                opacity: [1, 0],\r\n                duration,\r\n                onfinish(el) {\r\n                    el.style.opacity = '0';\r\n                }\r\n            });\r\n\r\n            anim1.then(function () {\r\n                this.stop();\r\n            });\r\n\r\n            let [anim2] = await animate({\r\n                target: this.horizontalElements,\r\n                scaleX: [0, 1],\r\n                delay(i: number) {\r\n                    return delay * (i + 1);\r\n                },\r\n                onfinish(el) {\r\n                    el.style.transform = `scaleX(1)`;\r\n                },\r\n                easing: \"out-cubic\",\r\n                duration: 500\r\n            });\r\n\r\n            fromWrapper.style.opacity = '1';\r\n            Object.assign(fromWrapper.style, wrapperStyle);\r\n            this.logoElement.style.visibility = \"visible\";\r\n\r\n            let loaderDuration = 500;\r\n            let [anim3] = await animate({\r\n                target: this.logoElement,\r\n                opacity: [0, 1],\r\n                duration: loaderDuration,\r\n                onfinish(el) {\r\n                    el.style.opacity = `1`;\r\n                },\r\n            });\r\n\r\n            anim3.on(\"stop\", () => {\r\n                console.log(\"`anim3` of the BigTransition has stopped\")\r\n            });\r\n\r\n            let [anim4] = await animate({\r\n                options: anim3,\r\n                opacity: [1, 0],\r\n                onfinish(el) {\r\n                    el.style.opacity = `0`;\r\n                },\r\n                delay: 1500\r\n            });\r\n\r\n            this.logoElement.style.visibility = \"hidden\";\r\n            anim2.stop()\r\n            anim3.stop();\r\n            anim4.stop();\r\n            done();\r\n        })();\r\n    },\r\n\r\n    in({ to, scroll }: ITransitionData) {\r\n        let { durationPerAnimation: duration, delay } = this;\r\n        let toWrapper = to.wrapper;\r\n\r\n        window.scroll(scroll.x, scroll.y);\r\n        return new Promise<void>(async resolve => {\r\n            let anim1 = animate({\r\n                target: toWrapper,\r\n                opacity: [0, 1],\r\n                duration\r\n            }).then(() => {\r\n                anim1.stop();\r\n            });\r\n\r\n            let [anim2] = await animate({\r\n                target: this.horizontalElements,\r\n                scaleX: [2, 0],\r\n                delay(i: number) {\r\n                    return delay * (i + 1);\r\n                },\r\n                onfinish(el) {\r\n                    el.style.transform = `scaleX(0)`;\r\n                },\r\n                easing: \"out-cubic\",\r\n                duration: 500\r\n            });\r\n\r\n            this.mainElement.style.opacity = \"0\";\r\n            this.mainElement.style.visibility = \"hidden\";\r\n            anim2.stop();\r\n            resolve();\r\n        });\r\n    }\r\n}\r\n", "import { ITransition, ITransitionData, animate } from \"@okikio/native\";\r\n\r\n//== Transitions\r\nexport const Slide: ITransition = {\r\n    name: \"slide\",\r\n    duration: 500,\r\n    direction: \"right\",\r\n\r\n    init(data: ITransition) {\r\n        document.documentElement.classList.add(\"no-overflow-x\");\r\n        let trigger = (data.trigger as HTMLElement);\r\n        if (trigger instanceof Node && trigger.hasAttribute(\"data-direction\")) {\r\n            this.direction = trigger.getAttribute(\"data-direction\");\r\n        } else {\r\n            this.direction = \"right\";\r\n        }\r\n    },\r\n\r\n    out({ from }) {\r\n        let { duration, direction } = this;\r\n        let fromWrapper = from.wrapper;\r\n\r\n        let anim = animate({\r\n            target: fromWrapper,\r\n            translateX: [0, `${(direction === \"left\" ? -1 : 1) * 25}%`],\r\n            opacity: [1, 0],\r\n            duration,\r\n            easing: \"in-quint\"\r\n        });\r\n\r\n        return anim.then(function () {\r\n            this.stop();\r\n        });\r\n    },\r\n\r\n    async in({ to }) {\r\n        let { duration } = this;\r\n        let toWrapper = to.wrapper;\r\n\r\n        let anim = animate({\r\n            target: toWrapper,\r\n            translateX: [`${(this.direction === \"right\" ? -1 : 1) * 25}%`, 0],\r\n            opacity: [0, 1],\r\n            duration,\r\n            easing: \"out-quint\"\r\n        })\r\n\r\n        await anim;\r\n\r\n        document.documentElement.classList.remove(\"no-overflow-x\");\r\n        anim.stop();\r\n    }\r\n};\r\n\r\nexport const SlideLeft: ITransition = {\r\n    ...Slide,\r\n\r\n    name: \"slide-left\",\r\n    direction: \"left\",\r\n};\r\n\r\nexport const SlideRight: ITransition = {\r\n    ...Slide,\r\n\r\n    name: \"slide-right\",\r\n    direction: \"right\",\r\n};\r\n", "import { Service } from \"@okikio/native\";\r\n\r\nexport class Navbar extends Service {\r\n    public navbar: HTMLElement;\r\n    public elements: HTMLElement[];\r\n    public menu: HTMLElement;\r\n    public collapseSection: HTMLElement;\r\n    public navbarList: HTMLElement;\r\n    public toggleStatus: boolean;\r\n\r\n    public init() {\r\n        // Elements\r\n        this.navbar = document.querySelector(\".navbar\") as HTMLElement;\r\n        this.collapseSection = this.navbar.querySelector(\".navbar-collapse.mobile\") as HTMLElement;\r\n        this.navbarList = this.navbar.querySelector(\".navbar-list\") as HTMLElement;\r\n        this.elements = Array.from(this.navbar.querySelectorAll(\".navbar-list a\"));\r\n        this.menu = this.navbar.querySelector(\".navbar-toggle\") as HTMLElement;\r\n        this.toggleStatus = false;\r\n\r\n        this.fixTabindex();\r\n        this.toggleClick = this.toggleClick.bind(this);\r\n    }\r\n\r\n    public activateLink() {\r\n        let { href } = window.location;\r\n\r\n        for (let el of this.elements) {\r\n            let itemHref =\r\n                el.getAttribute(\"data-path\") ||\r\n                (el as HTMLAnchorElement).href;\r\n            if (!itemHref || itemHref.length < 1) return;\r\n\r\n            let URLmatch = new RegExp(itemHref).test(href);\r\n            let isActive = el.classList.contains(\"active\");\r\n            if (!(URLmatch && isActive)) {\r\n                el.classList.toggle(\"active\", URLmatch);\r\n            }\r\n        }\r\n\r\n        if (this.toggleStatus) {\r\n            this.toggleClick();\r\n        }\r\n    }\r\n\r\n    public fixTabindex() {\r\n        for (let el of this.elements) {\r\n            el.setAttribute(\"tabindex\", `${this.toggleStatus ? 0 : -1}`);\r\n        }\r\n    }\r\n\r\n    public toggleClick() {\r\n        this.collapseSection.style?.setProperty?.(\"--height\", `${this.navbarList.clientHeight}px`);\r\n        this.toggleStatus = !this.toggleStatus;\r\n        this.collapseSection.classList.toggle(\"collapse\", !this.toggleStatus);\r\n        this.collapseSection.classList.toggle(\"show\", this.toggleStatus);\r\n        this.fixTabindex();\r\n    }\r\n\r\n    public scroll() {\r\n        this.navbar.classList.toggle(\"active-shadow\", window.scrollY >= 5);\r\n    }\r\n\r\n    public initEvents() {\r\n        this.menu.addEventListener(\"click\", this.toggleClick);\r\n        this.emitter.on(\"scroll\", this.scroll, this);\r\n        this.emitter.on(\"READY\", this.activateLink, this);\r\n        this.emitter.on(\"GO\", this.activateLink, this);\r\n    }\r\n\r\n    public stopEvents() {\r\n        this.navbar.removeEventListener(\"click\", this.toggleClick);\r\n        this.emitter.off(\"scroll\", this.scroll, this);\r\n        this.emitter.off(\"READY\", this.activateLink, this);\r\n        this.emitter.off(\"GO\", this.activateLink, this);\r\n    }\r\n\r\n    public uninstall() {\r\n        while (this.elements.length) this.elements.pop();\r\n        this.elements = null;\r\n        this.menu = null;\r\n        this.navbar = null;\r\n    }\r\n}", "import { animate, IAnimationOptions, methodCall, UnitPXCSSValue } from \"@okikio/native\";\r\n\r\n\r\nlet playbackFn = (containerSel, anims) => {\r\n    let playstateEl = document.querySelector(`${containerSel} #playstate-toggle`) as HTMLInputElement;\r\n    let progressEl = document.querySelector(`${containerSel} #progress`) as HTMLInputElement;\r\n\r\n    let progressOutputEl = document.querySelector(`${containerSel} #progress-output`);\r\n    let oldState: AnimationPlayState;\r\n\r\n    let updatePlayState = () => {\r\n        oldState = anims[0].getPlayState();\r\n        playstateEl.setAttribute(\"data-playstate\", oldState);\r\n    };\r\n\r\n    anims[0]\r\n        .on(\"finish begin\", updatePlayState)\r\n        .on(\"update\", (progress) => {\r\n            progressEl.value = `` + progress.toFixed(2);\r\n            progressOutputEl.textContent = `${Math.round(progress)}%`;\r\n        });\r\n\r\n    let clickFn = () => {\r\n        if (anims[0].is(\"running\")) methodCall(anims, \"pause\");\r\n        else if (anims[0].is(\"finished\")) methodCall(anims, \"reset\");\r\n        else methodCall(anims, \"play\");\r\n\r\n        updatePlayState();\r\n    };\r\n\r\n    let inputFn = () => {\r\n        let percent = +progressEl.value;\r\n        methodCall(anims, \"setProgress\", percent);\r\n        methodCall(anims, \"pause\");\r\n    }\r\n\r\n    let changeFn = () => {\r\n        oldState !== \"paused\" ? methodCall(anims, \"play\") : methodCall(anims, \"pause\");\r\n\r\n        updatePlayState();\r\n    }\r\n\r\n    playstateEl.addEventListener(\"click\", clickFn);\r\n    progressEl.addEventListener(\"input\", inputFn);\r\n    progressEl.addEventListener(\"change\", changeFn);\r\n\r\n    anims[0].on(\"stop\", () => {\r\n        playstateEl.removeEventListener(\"click\", clickFn);\r\n        progressEl.removeEventListener(\"input\", inputFn);\r\n        progressEl.removeEventListener(\"change\", changeFn);\r\n        anims = null;\r\n    })\r\n\r\n}\r\n\r\nlet random = (min: number, max: number) => Math.floor(Math.random() * (max - min + 1)) + min;\r\n\r\n/* Properties Section */\r\n// Playback Controls Demo\r\nexport let anim, motionPath, getTotalLength;\r\nexport let run = () => {\r\n    // Based on an example by animateplus\r\n    (() => {\r\n        let containerSel = \".morph-demo\";\r\n        let pathEl = document.querySelectorAll(`${containerSel} path`);\r\n\r\n        if (pathEl.length) {\r\n            let anim = animate({\r\n                target: pathEl,\r\n                duration: 1800,\r\n                easing: \"ease\",\r\n                loop: 4,\r\n                direction: \"alternate\",\r\n                \"d\": `path(\"M2,5 S2,14 4,5 S7,8 8,4\")`,\r\n                stroke: `rgb(96, 165, 250)`,\r\n            });\r\n\r\n            playbackFn(containerSel, [anim]);\r\n        }\r\n    })();\r\n\r\n    (() => {\r\n        let containerSel = \".playback-demo\";\r\n        let DOMNodes = document.querySelectorAll(`${containerSel} .el`);\r\n        if (DOMNodes.length) {\r\n            anim = animate({\r\n                target: DOMNodes,\r\n                backgroundColor() {\r\n                    let [r, g, b] = [\r\n                        random(0, 255),\r\n                        random(0, 255),\r\n                        random(0, 255)\r\n                    ]\r\n                    return `rgb(${r}, ${g}, ${b})`;\r\n                },\r\n\r\n                translateX: () => random(50, 400),\r\n                translateY(_, total) {\r\n                    return (random(-50, 50) * total);\r\n                },\r\n                scale() {\r\n                    return 1 + random(0.025, 1.75);\r\n                },\r\n                opacity(_, total) {\r\n                    return [0.5, 0.5 + Math.min(random(0.025, total) / total, 0.5)];\r\n                },\r\n                rotate: () => random(-360, 360),\r\n                borderRadius: () => `${random(10, 35)}%`,\r\n                duration: () => random(1200, 1800),\r\n                delay: () => random(0, 400),\r\n\r\n                // It is best to use the onfinish() method, but in this situation fillMode works best\r\n                fillMode: \"both\",\r\n                easing: \"in-out-back\",\r\n                loop: 2,\r\n                speed: (i) => 1.5 - (i * 0.125),\r\n                direction: \"alternate\",\r\n\r\n                padEndDelay: true,\r\n                autoplay: true\r\n            });\r\n\r\n            let addBtn = document.querySelector(\"#add-el\") as HTMLElement;\r\n            let removeBtn = document.querySelector(\"#remove-el\") as HTMLElement;\r\n            let elPlacement = document.querySelector(\".el-placement\") as HTMLElement;\r\n\r\n            let contain = document.createElement(\"div\");\r\n            contain.className = \"contain\";\r\n            contain.innerHTML = `\r\n            <div class=\"el\"></div>\r\n            <div class=\"el-initial\"></div>`.trim();\r\n\r\n            addBtn.onclick = () => {\r\n                let _contain = contain.cloneNode(true) as HTMLElement;\r\n                let el = _contain.querySelector(\".el\");\r\n                elPlacement.appendChild(_contain);\r\n\r\n                anim.add(el);\r\n\r\n                let transition = animate({\r\n                    target: _contain,\r\n                    opacity: [0, 1],\r\n                    height: [0, \"4vmin\"],\r\n                    marginBottom: UnitPXCSSValue([0, 5]),\r\n                    fillMode: \"forwards\",\r\n                    duration: 400,\r\n                    easing: \"out\"\r\n                }).then(() => {\r\n                    transition.stop();\r\n                    transition = null;\r\n                    _contain = null;\r\n                    el = null;\r\n                });\r\n\r\n            };\r\n\r\n            removeBtn.onclick = () => {\r\n                let contain = elPlacement.querySelector(\".contain\");\r\n                let el = contain?.querySelector(\".el\");\r\n\r\n                anim.remove(el);\r\n\r\n                let transition = animate({\r\n                    target: contain,\r\n                    opacity: 0,\r\n                    height: 0,\r\n                    marginBottom: 0,\r\n                    fillMode: \"forwards\",\r\n                    duration: 400,\r\n                    easing: \"out\"\r\n                }).then(() => {\r\n                    transition.stop();\r\n                    contain?.remove();\r\n\r\n                    transition = null;\r\n                    contain = null;\r\n                    el = null;\r\n                });\r\n            };\r\n\r\n            playbackFn(containerSel, [anim]);\r\n        }\r\n    })();\r\n\r\n    (() => {\r\n        let options: IAnimationOptions = {\r\n            padEndDelay: true,\r\n            easing: \"linear\",\r\n            duration: 2000,\r\n            loop: 4,\r\n            speed: 1,\r\n        };\r\n\r\n        let containerSel = \".motion-path-demo\";\r\n        let el = document.querySelector('.motion-path .el-1') as HTMLElement;\r\n        if (el) {\r\n            motionPath = animate({\r\n                target: el,\r\n                \"offsetDistance\": [\"0%\", \"100%\"],\r\n                ...options\r\n            });\r\n        }\r\n\r\n        let path = document.querySelector('.motion-path path') as SVGPathElement;\r\n        let el2 = document.querySelector('.motion-path .el-2') as HTMLElement;\r\n        if (path && el2) {\r\n\r\n            let pts: Set<number[]> = new Set();\r\n            let rotateArr: number[] = [];\r\n            let len = path.getTotalLength();\r\n\r\n            let ptAtZero = path.getPointAtLength(0);\r\n            for (var i = 0; i < len; i++) {\r\n                let { x, y } = path.getPointAtLength(i);\r\n                pts.add([x, y]);\r\n\r\n                let { x: x0, y: y0 } = i - 1 >= 1 ? path.getPointAtLength(i - 1) : ptAtZero;\r\n                let { x: x1, y: y1 } = i + 1 >= 1 ? path.getPointAtLength(i + 1) : ptAtZero;\r\n                let calc = +(Math.atan2(y0 - y1, x0 - x1) * 180 / Math.PI);\r\n                rotateArr.push(calc);\r\n            }\r\n\r\n            getTotalLength = animate({\r\n                target: el2,\r\n                translate: [...pts],\r\n                rotate: rotateArr,\r\n                fillMode: \"both\",\r\n                ...options,\r\n            });\r\n\r\n            playbackFn(containerSel, [motionPath, getTotalLength]);\r\n        }\r\n    })();\r\n};\r\n\r\nexport let stop = () => {\r\n    anim?.stop();\r\n    motionPath?.stop();\r\n    getTotalLength?.stop();\r\n\r\n}\r\n", "import { PJAX, App, TransitionManager, Router, HistoryManager, PageManager } from \"@okikio/native\";\r\n\r\nimport { Fade } from \"./transitions/Fade\";\r\nimport { BigTransition } from \"./transitions/BigTransition\";\r\nimport { Slide, SlideLeft, SlideRight } from \"./transitions/Slide\";\r\n\r\nimport { Navbar } from \"./services/Navbar\";\r\nimport { stop, run } from \"./animate\";\r\n\r\nconst router = new Router();\r\nconst pjax = new PJAX();\r\nconst navbar = new Navbar();\r\nconst app = new App({\r\n    // prefetchIgnore: [\"/index(.html)?\"],\r\n    // preventURLs: [\"/other(.html)?\"],\r\n    transitions: [\r\n        [\"default\", Fade],\r\n        [\"BigTransition\", BigTransition],\r\n        [\"Slide\", Slide],\r\n        [\"SlideLeft\", SlideLeft],\r\n        [\"SlideRight\", SlideRight]\r\n    ]\r\n});\r\n\r\napp\r\n    .set(\"HistoryManager\", new HistoryManager())\r\n    .set(\"PageManager\", new PageManager())\r\n    .set(\"TransitionManager\", new TransitionManager())\r\n\r\n    .add(navbar)\r\n    .add(router)\r\n    .add(pjax);\r\n\r\nrouter\r\n    .add({\r\n        path: {\r\n            from: \"/animate(.html)?\",\r\n            to: false,\r\n        },\r\n        method: stop\r\n    })\r\n    .add({\r\n        path: /\\/animate(.html)?/,\r\n        method: run\r\n    });\r\n\r\ntry {\r\n    app.boot();\r\n} catch (err) {\r\n    console.warn(\"[App] boot failed,\", err);\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
