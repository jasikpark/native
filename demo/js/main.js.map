{
  "version": 3,
  "sources": ["packages/native/src/config.ts", "packages/manager/src/api.ts", "packages/native/src/manager.ts", "packages/native/src/url.ts", "packages/native/src/service.ts", "packages/native/src/history.ts", "packages/native/src/page.ts", "packages/emitter/src/api.ts", "packages/native/src/transition.ts", "packages/native/src/app.ts", "packages/native/src/pjax.ts", "packages/native/src/router.ts", "packages/animate/src/api.ts", "build/ts/toArr.ts", "build/ts/services/IntroAnimation.ts", "build/ts/transitions/Fade.ts", "build/ts/transitions/BigTransition.ts", "build/ts/transitions/Slide.ts", "build/ts/services/Navbar.ts", "build/ts/main.ts"],
  "sourcesContent": ["export interface ICONFIG {\n    prefix?: string;\n    wrapperAttr?: string;\n    noAjaxLinkAttr?: string;\n    noPrefetchAttr?: \"no-prefetch\";\n    headers?: string[][];\n    preventSelfAttr?: string;\n    preventAllAttr?: string;\n    transitionAttr?: string;\n    blockAttr?: string;\n    timeout?: number;\n    maxPages?: number;\n    resizeDelay?: number;\n    [key: string]: any;\n}\n\nexport const CONFIG_DEFAULTS: ICONFIG = {\n    wrapperAttr: \"wrapper\",\n    noAjaxLinkAttr: \"no-ajax-link\",\n    noPrefetchAttr: \"no-prefetch\",\n    headers: [\n        [\"x-partial\", \"true\"]\n    ],\n    preventSelfAttr: `prevent=\"self\"`,\n    preventAllAttr: `prevent=\"all\"`,\n    transitionAttr: \"transition\",\n    blockAttr: `block`,\n    timeout: 30000,\n    maxPages: 5,\n    resizeDelay: 100\n};\n\nexport type ConfigKeys = keyof typeof CONFIG_DEFAULTS | string;\nexport const newConfig = (config: ICONFIG): ICONFIG => {\n    return Object.assign({ ...CONFIG_DEFAULTS }, config);\n};\n\n/** Converts string into properly formatted data attributes */\nexport const toAttr = (config: ICONFIG, value: string, brackets: boolean = true): string => {\n    let { prefix } = config;\n    let attr = `data${prefix ? \"-\" + prefix : \"\"}-${value}`;\n    return brackets ? `[${attr}]` : attr;\n};\n\n/** Selects config vars, and formats them for use, or simply returns the current configurations for the framework */\nexport const getConfig = (config: ICONFIG, value?: ConfigKeys, brackets: boolean = true): any => {\n    if (typeof value !== \"string\")\n        return config;\n\n    let prop = config[value];\n    if (typeof prop === \"string\")\n        return toAttr(config, prop, brackets);\n    return prop;\n};\n", "/** Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data */\nexport class Manager<K, V> {\n\t/** The complex list of named data, to which the Manager controls */\n\tpublic map: Map<K, V>;\n\tconstructor(value?: Array<[K, V]>) {\n\t\tthis.map = new Map(value);\n\t}\n\n\t/** Returns the Manager classes base Map */\n\tpublic getMap(): Map<K, V> {\n\t\treturn this.map;\n\t}\n\n\t/** Get a value stored in the Manager */\n\tpublic get(key: K): V {\n\t\treturn this.map.get(key);\n\t}\n\n\t/** Returns the keys of all items stored in the Manager as an Array */\n\tpublic keys(): Array<K> {\n\t\treturn Array.from(this.map.keys());\n\t}\n\n\t/** Returns the values of all items stored in the Manager as an Array */\n\tpublic values(): Array<V> {\n\t\treturn Array.from(this.map.values());\n\t}\n\n\t/** Set a value to the Manager using a key */\n\tpublic set(key: K, value: V): Manager<K, V> {\n\t\tthis.map.set(key, value);\n\t\treturn this;\n\t}\n\n\t/** Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers */\n\tpublic add(value: V): Manager<K, V> {\n\t\tlet size = this.size;\n\t\t// @ts-ignore\n\t\tlet num: K = size as K;\n\t\tthis.set(num, value);\n\t\treturn this;\n\t}\n\n\t/** Returns the total number of items stored in the Manager */\n\tpublic get size(): number {\n\t\treturn this.map.size;\n\t}\n\n\t/** An alias for size */\n\tpublic get length(): number {\n\t\treturn this.map.size;\n\t}\n\n\t/** Returns the last item in the Manager who's index is a certain distance from the last item in the Manager */\n\tpublic last(distance: number = 1): V | undefined {\n\t\tlet key = this.keys()[this.size - distance];\n\t\treturn this.get(key);\n\t}\n\n\t/** Removes a value stored in the Manager via a key, returns true if an element in the Map object existed and has been removed, or false if the element does not exist */\n\tpublic delete(key: K): boolean {\n\t\treturn this.map.delete(key);\n\t}\n\n\t/** Removes a value stored in the Manager via a key, returns the Manager class, allowing for chains */\n\tpublic remove(key: K): Manager<K, V> {\n\t\tthis.map.delete(key);\n\t\treturn this;\n\t}\n\n\t/** Clear the Manager of all its contents */\n\tpublic clear(): Manager<K, V> {\n\t\tthis.map.clear();\n\t\treturn this;\n\t}\n\n\t/** Checks if the Manager contains a certain key */\n\tpublic has(key: K): boolean {\n\t\treturn this.map.has(key);\n\t}\n\n\t/** Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order. */\n\tpublic entries(): IterableIterator<[K, V]> {\n\t\treturn this.map.entries();\n\t}\n\n\t/** Iterates through the Managers contents, calling a callback function every iteration */\n\tpublic forEach(\n\t\tcallback: (value?: V, key?: K, map?: Map<K, V>) => void,\n\t\tcontext?: object\n\t): Manager<K, V> {\n\t\tthis.map.forEach(callback, context);\n\t\treturn this;\n\t}\n\n\t/** Allows for iteration via for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators] */\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n}\n\n/**\n * Calls the method of a certain name for all items that are currently installed\n */\nexport const methodCall = (manager: Manager<any, any>, method: string, ...args: any): void => {\n\tmanager.forEach((item) => {\n\t\t// @ts-ignore\n\t\titem[method](...args);\n\t});\n};\n\n/**\n * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\n */\nexport const asyncMethodCall = async (manager: Manager<any, any>, method: string, ...args: any): Promise<void> => {\n\tfor (let [, item] of manager) {\n\t\t// @ts-ignore\n\t\tawait item[method](...args);\n\t}\n};\n\nexport default Manager;\n", "import { Manager, methodCall, asyncMethodCall } from \"@okikio/manager\";\nimport { ICONFIG } from \"./config\";\nimport { IApp } from \"./app\";\nimport { EventEmitter } from \"./emitter\";\n\nexport type IAdvancedManager = AdvancedManager<any, ManagerItem>;\n\n/** The base class for AdvancedManager items */\nexport class ManagerItem {\n    /** The AdvancedManager the ManagerItem is attached to */\n    public manager: IAdvancedManager;\n\n    /** The App the ManagerItem is attached to */\n    public app: IApp;\n\n    /** The Config of the App the ManagerItem is attached to */\n    public config: ICONFIG;\n\n    /** The EventEmitter of the App the ManagerItem is attached to */\n    public emitter: EventEmitter;\n\n    /** The key to where ManagerItem is stored in an AdvancedManager */\n    public key: any;\n\n    constructor() { }\n\n    /** Run after the Manager Item has been registered */\n    public install(): any { }\n\n    /** Register the current Manager Item's manager */\n    public register(manager: IAdvancedManager, key: any): ManagerItem {\n        this.manager = manager;\n        this.app = manager.app;\n        this.config = manager.config;\n        this.emitter = manager.emitter;\n        this.key = key;\n        this.install();\n        return this;\n    }\n\n    /** Run before the ManagerItem has been unregistered */\n    public uninstall(): any { }\n\n    /** Basically removes a ManagerItem, in order to recover the ManagerItem, it needs to be re-added to an AdvancedManager */\n    public unregister() {\n        this.uninstall();\n\n        this.manager.remove(this.key);\n        this.key = undefined;\n        this.manager = undefined;\n        this.app = undefined;\n        this.config = undefined;\n        this.emitter = undefined;\n    }\n}\n\n/** A tweak to the Manager class that makes it self aware of the App class it's instantiated in */\nexport class AdvancedManager<K, V extends ManagerItem> extends Manager<K, V> {\n    /** The App the AdvancedManager is attached to */\n    public app: IApp;\n\n    /** The Config of the App the AdvancedManager is attached to */\n    public config: ICONFIG;\n\n    /** The EventEmitter of the App the AdvancedManager is attached to */\n    public emitter: EventEmitter;\n\n    /** Register App details */\n    constructor(app: IApp) {\n        super();\n        this.app = app;\n        this.config = app.config;\n        this.emitter = app.emitter;\n    }\n\n    /** Add a ManagerItem to AdvancedManager at a specified key */\n    public set(key: K, value: V) {\n        super.set(key, value);\n        value.register(this, key);\n        return this;\n    }\n}\n\nexport { Manager, methodCall, asyncMethodCall };\n", "export const newURL = (url: string | URL | Location = window.location.href): URL => {\n    return url instanceof URL ? url : new URL(url as unknown as string, window.location.origin);\n};\n\n/** Returns the pathname with the hash at the end */\nexport const getHashedPath = (url: URL | string): string => {\n    let _url = newURL(url);\n    return `${_url.pathname}${_url.hash}`;\n};\n\n/** Returns the actual hash without the hashtag */\nexport const getHash = (url: URL | string): string => newURL(url).hash.slice(1);\n\n/** Removes the hash from the full URL for a clean URL string */\nexport const clean = (url: URL | string): string => newURL(url).toString().replace(/(\\/#.*|\\/|#.*)$/, '');\n\n/** Compares two URLs to each other */\nexport const equal = (a: URL | string, b: URL | string): boolean => (clean(a) === clean(b));\n\n", "import { AdvancedManager, ManagerItem, methodCall } from \"./manager\";\nimport { IApp } from \"./app\";\n\n/** Controls specific kinds of actions that require JS */\nexport class Service extends ManagerItem {\n\t/** Called before the start of a Service, represents a constructor of sorts */\n\tpublic init(...args: any): any;\n\tpublic init(): any { }\n\n\t/** Called on start of Service */\n\tpublic boot(...args: any): any;\n\tpublic boot(): any {\n\t\tthis.initEvents();\n\t}\n\n\t/** Initialize events */\n\tpublic initEvents(): void { }\n\n\t/** Stop events */\n\tpublic stopEvents(): void { }\n\n\t/** Stop services */\n\tpublic stop(): void {\n\t\tthis.stopEvents();\n\t\tthis.unregister();\n\t}\n}\n\n/** The Service Manager controls the lifecycle of all Services in an App */\nexport class ServiceManager extends AdvancedManager<string, Service> {\n\tconstructor(app: IApp) {\n\t\tsuper(app);\n\t}\n\n\t/** Call the init method for all Services */\n\tpublic init(): ServiceManager {\n\t\tmethodCall(this, \"init\");\n\t\treturn this;\n\t}\n\n\t/** Call the boot method for all Services */\n\tpublic boot(): ServiceManager {\n\t\tmethodCall(this, \"boot\");\n\t\treturn this;\n\t}\n\n\t/** Call the stop method for all Services */\n\tpublic stop(): ServiceManager {\n\t\tmethodCall(this, \"stop\");\n\t\treturn this;\n\t}\n}\n", "import { Service } from \"./service\";\nimport { getHashedPath, newURL } from \"./url\";\n\nexport type Trigger = HTMLAnchorElement | \"HistoryManager\" | \"popstate\" | \"back\" | \"forward\";\nexport interface ICoords {\n\treadonly x: number;\n\treadonly y: number;\n}\n\nexport interface IStateData {\n\tscroll: ICoords;\n\t[key: string]: any;\n}\n\nexport interface IState {\n\turl: string;\n\tindex?: number;\n\ttransition: string;\n\tdata: IStateData;\n}\n\nexport interface IHistoryItem {\n\tindex: number;\n\tstates: IState[];\n}\n\nexport interface IHistoryManager extends Service {\n\tstates: IState[],\n\tpointer: number,\n\n\tinit(): any,\n\tget(index: number): IState,\n\tadd(value?: IState, historyAction?: \"replace\" | \"push\"): HistoryManager,\n\tremove(index?: number): HistoryManager,\n\treplace(newStates: IState[]): HistoryManager,\n\tset(i: number, state: IState): IState,\n\tcurrent: IState,\n\tlast: IState,\n\tprevious: IState | null,\n\tlength: number,\n}\n\n/** A quick snapshot of page scroll coordinates */\nexport const newCoords = (x: number = window.scrollX, y: number = window.scrollY): ICoords => ({ x, y });\n\n/** Creates a state; a state represents the current status of the page consisting of properties like: url, transition, and data */\nexport const newState = (state: IState = {\n\turl: getHashedPath(newURL()),\n\tindex: 0,\n\ttransition: \"default\",\n\tdata: {\n\t\tscroll: newCoords(),\n\t\ttrigger: \"HistoryManager\"\n\t}\n}): IState => (state);\n\n/** Keeps a record of the history of the App; it stores only the states of Pages */\nexport class HistoryManager extends Service implements IHistoryManager {\n\tpublic states: IState[];\n\tpublic pointer = -1;\n\n\t/** Initializes the states array, and replace the history pushState data with the states array */\n\tinit() {\n\t\tthis.states = [];\n\n\t\tlet state = newState();\n\t\tthis.add(state, \"replace\");\n\t}\n\n\t/** Get a state based on it's index */\n\tpublic get(index: number) {\n\t\treturn this.states[index];\n\t}\n\n\t/** Add a state to HistoryManager and change the history pushState data based on the historyAction specified */\n\tpublic add(value?: IState, historyAction: \"replace\" | \"push\" = \"push\"): HistoryManager {\n\t\tlet state = newState(value);\n\t\tlet len = this.length;\n\t\tthis.states.push({ ...state });\n\t\tthis.pointer = len;\n\n\t\tlet item: IHistoryItem = {\n\t\t\tindex: this.pointer,\n\t\t\tstates: [...this.states]\n\t\t};\n\t\tchangeState(historyAction, state, item);\n\t\treturn this;\n\t}\n\n\tpublic remove(index?: number) {\n\t\tif (index) {\n\t\t\tthis.states.splice(index, 1);\n\t\t} else {\n\t\t\tthis.states.pop();\n\t\t}\n\n\t\tthis.pointer--;\n\t\treturn this;\n\t}\n\n\t/** Replaces the states array with another states array, this is later used when going back and forward in page history */\n\tpublic replace(newStates: IState[]) {\n\t\tthis.states = newStates;\n\t\treturn this;\n\t}\n\n\t/** Set state by index. */\n\tpublic set(i: number, state: IState) {\n\t\treturn (this.states[i] = state);\n\t}\n\n\t/** Get the current state */\n\tget current(): IState {\n\t\treturn this.get(this.pointer);\n\t}\n\n\t/** Get the last state (top of the history stack). */\n\tget last(): IState {\n\t\treturn this.get(this.length - 1);\n\t}\n\n\t/** Get the previous state. */\n\tget previous(): IState | null {\n\t\treturn this.pointer < 1 ? null : this.get(this.pointer - 1);\n\t}\n\n\tget length() {\n\t\treturn this.states.length;\n\t}\n}\n\n/** Either push or replace history state */\nexport const changeState = (action: \"push\" | \"replace\", state: IState, item: object) => {\n\tlet href = getHashedPath(state.url);\n\tlet args = [item, \"\", href];\n\tif (window.history) {\n\t\tswitch (action) {\n\t\t\tcase \"push\":\n\t\t\t\twindow.history.pushState.apply(window.history, args);\n\t\t\t\tbreak;\n\t\t\tcase \"replace\":\n\t\t\t\twindow.history.replaceState.apply(window.history, args);\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n", "import { Manager, ManagerItem, AdvancedManager } from \"./manager\";\nimport { equal, newURL } from \"./url\";\nimport { getConfig } from \"./config\";\nimport { Service } from \"./service\";\n\nexport interface IPage extends ManagerItem {\n    dom: Document,\n    wrapper: HTMLElement,\n    title: string,\n    head: Element,\n    body: Element,\n    url: URL,\n    data: string,\n    wrapperAttr: string,\n\n    build(): any,\n    install(): void,\n    uninstall(): any,\n}\n\n/**\n * Parses strings to DOM\n */\nexport const PARSER: DOMParser = new DOMParser();\n\n/** A page represents the DOM elements that create each page */\nexport class Page extends ManagerItem implements IPage {\n    /** Holds the DOM of the current page */\n    public dom: Document;\n\n    /** Holds the wrapper element to be swapped out of each Page */\n    public wrapper: HTMLElement;\n\n    /** Holds the title of each page */\n    public title: string;\n\n    /** Holds the head element of each page */\n    public head: Element;\n\n    /** Holds the body element of each page */\n    public body: Element;\n\n    /** The URL of the current page */\n    public url: URL;\n\n    /** The payload of a page request */\n    public data: string;\n\n    /** Attr that identifies the wrapper */\n    public wrapperAttr: string;\n\n    constructor(url: URL = newURL(), dom: string | Document = document) {\n        super();\n        this.url = url;\n\n        if (typeof dom === \"string\") {\n            this.data = dom;\n        } else this.dom = dom || document;\n    }\n\n    /** Builds the page's dom, and sets the title, head, body, and wrapper properties of the Page class */\n    public build() {\n        if (!(this.dom instanceof Node)) {\n            this.dom = PARSER.parseFromString(this.data, \"text/html\");\n        }\n\n        if (!(this.body instanceof Node)) {\n            let { title, head, body } = this.dom;\n            this.title = title;\n            this.head = head;\n            this.body = body;\n            this.wrapper = this.body.querySelector(this.wrapperAttr);\n        }\n    }\n\n    public install() {\n        this.wrapperAttr = getConfig(this.config, \"wrapperAttr\");\n    }\n\n    public uninstall() {\n        this.url = undefined;\n        this.title = undefined;\n        this.head = undefined;\n        this.body = undefined;\n        this.dom = undefined;\n        this.wrapper = undefined;\n        this.data = undefined;\n        this.wrapperAttr = undefined;\n    }\n}\n\nexport interface IPageManager extends Service {\n    loading: Manager<string, Promise<string>>,\n    pages: AdvancedManager<string, Page>;\n\n    install(): any,\n\n    get(key): Page,\n    add(value): PageManager,\n    set(key, value): PageManager,\n    remove(key): PageManager,\n    has(key): boolean,\n    clear(): PageManager,\n    size: number,\n    keys(): any[],\n\n    load(_url: URL | string): Promise<Page>,\n    request(url: string): Promise<string>,\n}\n\n/** Controls which page to load */\nexport class PageManager extends Service implements IPageManager {\n    /** Stores all fetch requests that are currently loading */\n    public loading: Manager<string, Promise<string>> = new Manager();\n\n    pages: AdvancedManager<string, Page>;\n\n    /** Instantiate pages, and add the current page to pages */\n    install() {\n        this.pages = new AdvancedManager(this.app);\n\n        let URLString = newURL().pathname;\n        this.set(URLString, new Page());\n        URLString = undefined;\n    }\n\n    get(key) { return this.pages.get(key); }\n    add(value) { this.pages.add(value); return this; }\n    set(key, value) { this.pages.set(key, value); return this; }\n    remove(key) { this.pages.remove(key); return this; }\n    has(key) { return this.pages.has(key); }\n    clear() { this.pages.clear(); return this; }\n    get size() { return this.pages.size; }\n    keys() { return this.pages.keys(); }\n\n    /** Load from cache or by requesting URL via a fetch request, avoid requesting for the same thing twice by storing the fetch request in \"this.loading\" */\n    public async load(_url: URL | string = newURL()): Promise<Page> {\n        let url: URL = newURL(_url);\n        let urlString: string = url.pathname;\n        let page: Page, request: Promise<string>;\n\n        if (this.has(urlString)) {\n            page = this.get(urlString);\n            return Promise.resolve(page);\n        }\n\n        if (!this.loading.has(urlString)) {\n            request = this.request(urlString);\n            this.loading.set(urlString, request);\n        } else request = this.loading.get(urlString);\n\n        let response = await request;\n        this.loading.remove(urlString);\n\n        page = new Page(url, response);\n        this.set(urlString, page);\n\n        if (this.size > getConfig(this.config, \"maxPages\")) {\n            let currentUrl = newURL();\n            let keys = this.keys();\n            let first = equal(currentUrl, keys[0]) ? keys[1] : keys[0];\n            let page = this.get(first);\n            page.unregister();\n            page = undefined;\n            keys = undefined;\n            currentUrl = undefined;\n            first = undefined;\n        }\n\n        return page;\n    }\n\n    /** Starts a fetch request */\n    public async request(url: string): Promise<string> {\n        const headers = new Headers(getConfig(this.config, \"headers\"));\n        const timeout = window.setTimeout(() => {\n            window.clearTimeout(timeout);\n            throw \"Request Timed Out!\";\n        }, getConfig(this.config, \"timeout\"));\n\n        try {\n            let response = await fetch(url, {\n                mode: 'same-origin',\n                method: \"GET\",\n                headers,\n                cache: \"default\",\n                credentials: \"same-origin\",\n            });\n\n            window.clearTimeout(timeout);\n            if (response.status >= 200 && response.status < 300) {\n                return await response.text();\n            }\n\n            const err = new Error(response.statusText || \"\" + response.status);\n            throw err;\n        } catch (err) {\n            window.clearTimeout(timeout);\n            throw err;\n        }\n    }\n}\n", "import { Manager, methodCall } from \"@okikio/manager\";\n\nexport type ListenerCallback = ((...args: any) => void);\nexport interface IListener {\n    readonly callback: ListenerCallback;\n    readonly scope: object;\n    readonly name: string;\n}\n\n/** Represents a new event listener consisting of properties like: callback, scope, name */\nexport const newListener = ({\n    callback = () => { },\n    scope = null,\n    name = \"event\",\n}: IListener): IListener => ({ callback, scope, name });\n\n/** Represents a new event  */\nexport class Event extends Manager<number, IListener> {\n    /** The name of the event */\n    public name: string;\n    constructor(name: string = \"event\") {\n        super();\n        this.name = name;\n    }\n}\n\nexport type EventInput = string | object | Array<string>;\n\n/**\n * An Event Emitter\n * */\nexport class EventEmitter extends Manager<string, Event> {\n    constructor() {\n        super();\n    }\n\n    /** Gets event, if event doesn't exist create a new one */\n    public getEvent(name: string): Event {\n        let event = this.get(name);\n        if (!(event instanceof Event)) {\n            this.set(name, new Event(name));\n            return this.get(name);\n        }\n\n        return event;\n    }\n\n    /** Creates a listener and adds it to an event */\n    public newListener(\n        name: string,\n        callback: ListenerCallback,\n        scope: object\n    ): Event {\n        let event = this.getEvent(name);\n        event.add(newListener({ name, callback, scope }));\n        return event;\n    }\n\n    /** Adds a listener to a given event */\n    public on(\n        events: EventInput,\n        callback?: ListenerCallback | object,\n        scope?: object\n    ): EventEmitter {\n        // If there is no event break\n        if (typeof events == \"undefined\") return this;\n\n        // Create a new event every space\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\n\n        let _name: string;\n        let _callback: ListenerCallback;\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\n\n        let _scope: object = isObject ? callback : scope;\n        if (!isObject) _callback = (callback as ListenerCallback);\n\n        // Loop through the list of events\n        Object.keys(events).forEach(key => {\n            // Select the name of the event from the list\n            // Remember events can be {String | Object | Array<string>}\n\n            // Check If events is an Object (JSON like Object, and not an Array)\n            if (isObject) {\n                _name = key;\n                _callback = events[key];\n            } else {\n                _name = events[key];\n            }\n\n            this.newListener(_name, _callback, _scope);\n        }, this);\n        return this;\n    }\n\n    /** Removes a listener from an event */\n    public removeListener(\n        name: string,\n        callback: ListenerCallback,\n        scope: object\n    ): Event {\n        let event: Event = this.get(name);\n        if (event instanceof Event && callback) {\n            let listener = newListener({ name, callback, scope });\n\n            event.forEach((value: IListener, i: number) => {\n                if (\n                    value.callback === listener.callback &&\n                    value.scope === listener.scope\n                ) {\n                    return event.remove(i);\n                }\n            });\n        }\n\n        return event;\n    }\n\n    /** Remove a listener from a given event, or just completely remove an event */\n    public off(\n        events: EventInput,\n        callback?: ListenerCallback | object,\n        scope?: object\n    ): EventEmitter {\n        // If there is no event break\n        if (typeof events == \"undefined\") return this;\n\n        // Create a new event every space\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\n\n        let _name: string;\n        let _callback: ListenerCallback;\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\n\n        let _scope: object = isObject ? callback : scope;\n        if (!isObject) _callback = (callback as ListenerCallback);\n\n        // Loop through the list of events\n        Object.keys(events).forEach(key => {\n            // Select the name of the event from the list\n            // Remember events can be {String | Object | Array<any>}\n\n            // Check If events is an Object (JSON like Object, and not an Array)\n            if (isObject) {\n                _name = key;\n                _callback = events[key];\n            } else {\n                _name = events[key];\n            }\n\n            if (typeof _callback === \"function\") {\n                this.removeListener(_name, _callback, _scope);\n            } else this.remove(_name);\n        }, this);\n        return this;\n    }\n\n    /** Call all listeners within an event */\n    public emit(\n        events: string | Array<any>,\n        ...args: any\n    ): EventEmitter {\n        // If there is no event break\n        if (typeof events == \"undefined\") return this;\n\n        // Create a new event every space\n        if (typeof events == \"string\") events = events.trim().split(/\\s/g);\n\n        // Loop through the list of events\n        events.forEach((event: string) => {\n            let _event: Event = this.get(event);\n\n            if (_event instanceof Event) {\n                _event.forEach((listener: IListener) => {\n                    let { callback, scope } = listener;\n                    callback.apply(scope, args);\n                });\n            }\n        }, this);\n        return this;\n    }\n\n    /** Clears events and event listeners */\n    public clear() {\n        methodCall(this, \"clear\");\n        super.clear();\n        return this;\n    }\n}\n\nexport default EventEmitter;\n", "import { Manager } from \"./manager\";\nimport { ICoords, newCoords, Trigger } from \"./history\";\nimport { IPage } from \"./page\";\nimport { getConfig } from \"./config\";\nimport { Service } from \"./service\";\nimport { newURL } from \"./url\";\n\n/**\n * The async function type, allows for smooth transition between Promises\n */\nexport type asyncFn = (err?: any, value?: any) => void;\nexport interface ITransition {\n    oldPage?: IPage;\n    newPage?: IPage;\n    trigger?: Trigger;\n    scroll?: { x: number; y: number };\n    scrollable?: boolean;\n    in: (data: ITransitionData) => any;\n    out: (data: ITransitionData) => any;\n    [key: string]: any;\n}\nexport interface ITransitionData {\n    from?: IPage;\n    to?: IPage;\n    trigger?: Trigger;\n    scroll?: ICoords;\n    done: asyncFn;\n}\nexport interface ITransitionManager extends Service {\n    transitions: Manager<string, ITransition>,\n\n    get(key: string): ITransition,\n    set(key: string, value: ITransition): TransitionManager,\n    add(value: ITransition): TransitionManager,\n    has(key: string): boolean,\n\n    boot(): any,\n    animate(name: string, data: any): Promise<ITransition>,\n}\n\n/** Auto scrolls to an elements position if the element has an hash */\nexport const hashAction = (coords?: ICoords, hash: string = window.location.hash) => {\n    try {\n        let _hash = hash[0] == \"#\" ? hash : newURL(hash).hash;\n        if (_hash.length > 1) {\n            let el = document.getElementById(_hash.slice(1));\n            if (el) {\n                let { left, top } = el.getBoundingClientRect();\n                let scrollLeft = window.scrollX;\n                let scrollTop = window.scrollY;\n                let x = left + scrollLeft;\n                let y = top + scrollTop;\n\n                console.log(x, y);\n                return newCoords(x, y);\n            }\n        }\n    } catch (e) {\n        console.warn(\"[hashAction] error\", e);\n    }\n\n    return coords ?? newCoords(0, 0);\n};\n\n// The Default Transition\nconst Default: ITransition = {\n    name: \"default\",\n    scrollable: true,\n\n    out({ done }: ITransitionData) {\n        done();\n    },\n    in({ scroll, done }: ITransitionData) {\n        window.scroll(scroll.x, scroll.y);\n        done();\n    }\n};\n\n/** Controls which Transition between pages to use */\nexport class TransitionManager extends Service implements ITransitionManager {\n    transitions: Manager<string, ITransition>;\n    private _arg: Array<[string, ITransition]>;\n    constructor(transitions?: Array<[string, ITransition]>) {\n        super();\n        this._arg = transitions;\n    }\n\n    /** On Service install set Config */\n    public install() {\n        super.install();\n\n        let transitions = this._arg && this._arg.length ? this._arg : (getConfig(this.config, \"transitions\") ?? []);\n\n        // Manager like Maps use the most recent [key, value] Array it knows, replacing the default transition\n        // With any other transitions called [\"default\", ...]\n        transitions = [[\"default\", Default]].concat(transitions);\n        this.transitions = new Manager(transitions);\n    }\n\n    get(key: string) { return this.transitions.get(key); }\n    set(key: string, value: ITransition) { this.transitions.set(key, value); return this; }\n    add(value: ITransition) { this.transitions.add(value); return this; }\n    has(key: string) { return this.transitions.has(key); }\n\n    /** Starts a transition */\n    public async animate(name: string, data: any): Promise<ITransition> {\n        let transition: ITransition = this.transitions.get(name);\n        let scroll = data.scroll;\n        let ignoreHashAction = data.ignoreHashAction;\n        if (!(\"wrapper\" in data.oldPage) || !(\"wrapper\" in data.newPage))\n            throw `[Page] either oldPage or newPage aren't instances of the Page Class.\\n ${{\n                newPage: data.newPage,\n                oldPage: data.oldPage,\n            }}`;\n\n        // Replace the title\n        document.title = `` + data.newPage.title;\n\n        let fromWrapper = data.oldPage.wrapper;\n        let toWrapper = data.newPage.wrapper;\n\n        if (!(fromWrapper instanceof Node) || !(toWrapper instanceof Node))\n            throw `[Wrapper] the wrapper from the ${!(toWrapper instanceof Node) ? \"next\" : \"current\"\n            } page cannot be found. The wrapper must be an element that has the attribute ${getConfig(this.config,\n                \"wrapperAttr\"\n            )}.`;\n\n        // Give the Transition all the background data it may require\n        transition.init && transition?.init(data);\n\n        this.emitter.emit(\"BEFORE_TRANSITION_OUT\");\n\n        // Start the out point of the Transition\n        if (transition.out) {\n            await new Promise((done) => {\n                let outMethod: Promise<any> = transition.out.call(transition, {\n                    ...data,\n                    from: data.oldPage,\n                    trigger: data.trigger,\n                    done,\n                });\n\n                outMethod?.then(done);\n            });\n        }\n\n        this.emitter.emit(\"AFTER_TRANSITION_OUT\");\n\n        // Add the new wrapper before the old one\n        await new Promise<void>((done) => {\n            fromWrapper.insertAdjacentElement(\"beforebegin\", toWrapper);\n            this.emitter.emit(\"CONTENT_INSERT\");\n\n            if (!ignoreHashAction && !/back|popstate|forward/.test(data.trigger as string)) {\n                scroll = hashAction(scroll);\n            }\n            done();\n        });\n\n        // Replace the old wrapper with the new one\n        await new Promise<void>((done) => {\n            fromWrapper.remove();\n            fromWrapper = undefined;\n            toWrapper = undefined;\n            this.emitter.emit(\"CONTENT_REPLACED\");\n            done();\n        });\n\n        this.emitter.emit(\"BEFORE_TRANSITION_IN\");\n\n        // Start the in point of the Transition (only the in method has access to the hashAction's scroll position)\n        if (transition.in) {\n            await new Promise(async (done) => {\n                let inMethod: Promise<any> = transition.in.call(transition, {\n                    ...data,\n                    from: data.oldPage,\n                    to: data.newPage,\n                    trigger: data.trigger,\n                    scroll,\n                    done,\n                });\n\n                inMethod?.then(done);\n            });\n        }\n\n        this.emitter.emit(\"AFTER_TRANSITION_IN\");\n        return transition;\n    }\n}\n", "import { EventEmitter, ListenerCallback, EventInput } from \"./emitter\";\nimport { ServiceManager, Service } from \"./service\";\nimport { newConfig, ICONFIG, getConfig } from \"./config\";\n\nexport interface IApp {\n    services: ServiceManager,\n    emitter: EventEmitter,\n    config: ICONFIG,\n    register(config: ICONFIG): App,\n    get(key: string): Service,\n    set(key: string, service: Service): App,\n    add(value: Service): App,\n    boot(): App,\n    stop(): App,\n    on(events: EventInput, callback?: ListenerCallback): App,\n    off(events: EventInput, callback?: ListenerCallback): App,\n    emit(events: string | any[], ...args: any): App,\n}\n\n/** The App class starts the entire process, it controls all managers and all services */\nexport class App implements IApp {\n    /** An instance of the ServiceManager */\n    public services: ServiceManager;\n\n    /** An instance of an EventEmitter */\n    public emitter: EventEmitter;\n\n    /** The current Configuration's for the App */\n    public config: ICONFIG;\n\n    private canResize = true;\n    private canScroll = true;\n    constructor(config: object = {}) {\n        this._resize = this._resize.bind(this);\n        this._scroll = this._scroll.bind(this);\n        this._ready = this._ready.bind(this);\n        this.register(config);\n    }\n\n    /** Create new instances of the ServiceManager, EventEmitter and the configurations */\n    public register(config: ICONFIG = {}): App {\n        this.config = newConfig(config);\n        this.emitter = new EventEmitter();\n        this.services = new ServiceManager(this);\n\n        document.addEventListener(\"DOMContentLoaded\", this._ready);\n        window.addEventListener(\"load\", this._ready);\n        window.addEventListener(\"resize\", this._resize, { passive: true });\n        window.addEventListener(\"scroll\", this._scroll, { passive: true });\n        return this;\n    }\n\n    private _ready() {\n        document.removeEventListener(\"DOMContentLoaded\", this._ready);\n        window.removeEventListener(\"load\", this._ready);\n        this.emitter.emit(\"READY ready\");\n    }\n\n    private _resize() {\n        if (this.canResize) {\n            let timer: number | void, raf: number | void;\n            this.canResize = false;\n            raf = window.requestAnimationFrame(() => {\n                this.emitter.emit(\"RESIZE resize\");\n\n                // set a timeout to un-throttle\n                timer = window.setTimeout(() => {\n                    this.canResize = true;\n                    timer = window.clearTimeout(timer as number);\n                    raf = window.cancelAnimationFrame(raf as number);\n                }, getConfig(this.config, \"resizeDelay\"));\n            });\n        }\n    }\n\n    private _scroll() {\n        if (this.canScroll) {\n            let raf: number | void;\n            this.canScroll = false;\n            raf = requestAnimationFrame(() => {\n                this.emitter.emit(\"SCROLL scroll\");\n\n                this.canScroll = true;\n                raf = window.cancelAnimationFrame(raf as number);\n            });\n        }\n    }\n\n    /** Shortcuts to adding, setting, and getting Services */\n    public get(key: string): Service {\n        return this.services.get(key);\n    }\n\n    public set(key: string, value: Service): App {\n        this.services.set(key, value);\n        return this;\n    }\n\n    public add(value: Service): App {\n        this.services.add(value);\n        return this;\n    }\n\n    /** Initialize and boot all Services */\n    public boot(): App {\n        this.services.init();\n        this.services.boot();\n        return this;\n    }\n\n    /** Stops all Services and clears the even emitter of all events and listeners */\n    public stop(): App {\n        this.services.stop();\n        this.emitter.clear();\n        return this;\n    }\n\n    /** Shortcuts to the App EventEmitter on, off, and emit methods */\n    public on(events: EventInput, callback?: ListenerCallback): App {\n        this.emitter.on(events, callback, this);\n        return this;\n    }\n\n    public off(events: EventInput, callback?: ListenerCallback): App {\n        this.emitter.off(events, callback, this);\n        return this;\n    }\n\n    public emit(events: string | any[], ...args: any): App {\n        this.emitter.emit(events, ...args);\n        return this;\n    }\n}\n", "import { newState, Trigger, newCoords, IHistoryItem, IHistoryManager } from \"./history\";\nimport { Service } from \"./service\";\nimport { IPage, IPageManager } from \"./page\";\nimport { newURL, getHashedPath, equal } from \"./url\";\nimport { getConfig } from \"./config\";\nimport { hashAction, ITransitionManager } from \"./transition\";\n\nexport type LinkEvent = MouseEvent | TouchEvent;\nexport type StateEvent = LinkEvent | PopStateEvent;\nexport type IgnoreURLsList = Array<RegExp | string>;\n/**\n * Creates a barbajs like PJAX Service, for the native framework\n * Based on barbajs and StartingBlocks\n */\nexport class PJAX extends Service {\n    /** URLs to ignore when prefetching */\n    public ignoreURLs: IgnoreURLsList;\n\n    /** Whether or not to disable prefetching */\n    public prefetchIgnore: boolean;\n\n    /** Current state of transitions */\n    public isTransitioning: boolean;\n\n    /** Ignore extra clicks of an anchor element if a transition has already started */\n    public stopOnTransitioning: boolean;\n\n    /** On page change (excluding popstate events) keep current scroll position */\n    public stickyScroll: boolean;\n\n    /** Force load a page if an error occurs */\n    public forceOnError: boolean;\n\n    /** Ignore hash action if set to true */\n    public ignoreHashAction: boolean;\n\n    public install() {\n        super.install();\n\n        this.ignoreURLs = getConfig(this.config, \"ignoreURLs\") ?? [];\n        this.prefetchIgnore = getConfig(this.config, \"prefetchIgnore\") ?? false;\n        this.stopOnTransitioning = getConfig(this.config, \"stopOnTransitioning\") ?? false;\n        this.stickyScroll = getConfig(this.config, \"stickyScroll\") ?? false;\n        this.forceOnError = getConfig(this.config, \"forceOnError\") ?? false;\n        this.ignoreHashAction = getConfig(this.config, \"ignoreHashAction\") ?? false\n    }\n\n    /** Sets the transition state to either true or false */\n    public transitionStart() {\n        this.isTransitioning = true;\n    }\n\n    public transitionStop() {\n        this.isTransitioning = false;\n    }\n\n    public init() {\n        /**\n         * Bind the event listeners to the PJAX class\n         *\n         * @memberof PJAX\n         */\n        this.onHover = this.onHover.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.onStateChange = this.onStateChange.bind(this);\n    }\n\n    /** Starts the PJAX Service */\n    public boot() {\n        if (\"scrollRestoration\" in window.history) {\n            // Back off, browser, I got this...\n            window.history.scrollRestoration = \"manual\";\n        }\n\n        super.boot();\n    }\n\n    /** Gets the transition to use for a certain anchor */\n    public getTransitionName(el: HTMLAnchorElement): string | null {\n        if (!el || !el.getAttribute) return null;\n        let transitionAttr = el.getAttribute(\n            getConfig(this.config, \"transitionAttr\", false)\n        );\n\n        if (typeof transitionAttr === \"string\") return transitionAttr;\n        return null;\n    }\n\n    /** Checks to see if the anchor is valid */\n    public validLink(\n        el: HTMLAnchorElement,\n        event: LinkEvent | KeyboardEvent,\n        href: string\n    ): boolean {\n        let pushStateSupport = !window.history.pushState;\n        let exists = !el || !href;\n        let eventMutate =\n            (event as KeyboardEvent).metaKey ||\n            (event as KeyboardEvent).ctrlKey ||\n            (event as KeyboardEvent).shiftKey ||\n            (event as KeyboardEvent).altKey;\n        let newTab =\n            el.hasAttribute(\"target\") &&\n            (el as HTMLAnchorElement).target === \"_blank\";\n        let crossOrigin =\n            (el as HTMLAnchorElement).protocol !== location.protocol ||\n            (el as HTMLAnchorElement).hostname !== location.hostname;\n        let download = typeof el.getAttribute(\"download\") === \"string\";\n        let preventSelf = el.matches(getConfig(this.config, \"preventSelfAttr\"));\n        let preventAll = Boolean(\n            el.closest(getConfig(this.config, \"preventAllAttr\"))\n        );\n        let sameURL = getHashedPath(newURL()) === getHashedPath(newURL(href));\n        return !(\n            exists ||\n            pushStateSupport ||\n            eventMutate ||\n            newTab ||\n            crossOrigin ||\n            download ||\n            preventSelf ||\n            preventAll ||\n            sameURL\n        );\n    }\n\n    /** Returns the href of an Anchor element */\n    public getHref(el: HTMLAnchorElement): string | null {\n        if (\n            el &&\n            el.tagName &&\n            el.tagName.toLowerCase() === \"a\" &&\n            typeof el.href === \"string\"\n        )\n            return el.href;\n        return null;\n    }\n\n    /** Check if event target is a valid anchor with an href, if so, return the anchor */\n    public getLink(event: LinkEvent): HTMLAnchorElement {\n        let el = event.target as HTMLAnchorElement;\n        let href: string = this.getHref(el);\n\n        while (el && !href) {\n            el = (el as HTMLElement).parentNode as HTMLAnchorElement;\n            href = this.getHref(el);\n        }\n\n        // Check for a valid link\n        if (!el || !this.validLink(el, event, href)) return;\n        return el;\n    }\n\n    /** When an element is clicked, get valid anchor element, go for a transition */\n    public onClick(event: LinkEvent) {\n        let el = this.getLink(event);\n        if (!el) return;\n\n        if (this.isTransitioning && this.stopOnTransitioning) {\n            event.preventDefault();\n            event.stopPropagation();\n            return;\n        }\n\n        let href = this.getHref(el);\n        this.emitter.emit(\"ANCHOR_CLICK CLICK\", event);\n        this.go({ href, trigger: el, event });\n    }\n\n    /** Returns the direction of the State change as a String, either the Back button or the Forward button */\n    public getDirection(value: number): Trigger {\n        if (Math.abs(value) > 1) {\n            // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\n            return value > 0 ? \"forward\" : \"back\";\n        } else {\n            if (value === 0) {\n                return \"popstate\";\n            } else {\n                // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\n                return value > 0 ? \"back\" : \"forward\";\n            }\n        }\n    }\n\n    /** Force a page to go to a certain URL */\n    public force(href: string): void {\n        window.location.assign(href);\n    }\n\n    /**\n     * If transition is running force load page.\n     * Stop if currentURL is the same as new url.\n     * On state change, change the current state history, to reflect the direction of said state change\n     * Load page and page transition.\n     */\n    public go({\n        href,\n        trigger = \"HistoryManager\",\n        event,\n    }: {\n        href: string;\n        trigger?: Trigger;\n        event?: StateEvent;\n    }): Promise<void> {\n        // If transition is already running and the go method is called again, force load page\n        if (this.isTransitioning && this.stopOnTransitioning ||\n            !(this.manager.has(\"TransitionManager\") &&\n                this.manager.has(\"HistoryManager\") &&\n                this.manager.has(\"PageManager\"))) {\n            this.force(href);\n            return;\n        }\n\n        const history = this.manager.get(\"HistoryManager\") as IHistoryManager;\n        let scroll = newCoords(0, 0);\n        let currentState = history.current;\n        let currentURL = currentState.url;\n        if (equal(currentURL, href)) {\n            return;\n        }\n\n        let transitionName: string;\n        if (event && (event as PopStateEvent).state) {\n            this.emitter.emit(\"POPSTATE\", event);\n\n            // If popstate, get back/forward direction.\n            let { state }: { state: IHistoryItem } = event as PopStateEvent;\n            let { index } = state;\n            let currentIndex = currentState.index;\n            let difference = currentIndex - index;\n\n            history.replace(state.states);\n            history.pointer = index;\n\n            let _state = history.get(index);\n            transitionName = _state.transition;\n            scroll = _state.data.scroll;\n\n            trigger = this.getDirection(difference);\n            console.log(trigger == \"forward\" && history)\n\n            // Based on the direction of the state change either remove or add a state\n            this.emitter.emit(trigger === \"back\" ? `POPSTATE_BACK` : `POPSTATE_FORWARD`, event);\n        } else {\n            // Add new state\n            transitionName = this.getTransitionName(trigger as HTMLAnchorElement);\n\n            scroll = newCoords();\n            let state = newState({\n                url: href,\n                transition: transitionName,\n                data: { scroll },\n            });\n\n            !this.stickyScroll && (scroll = newCoords(0, 0));\n\n            history.add(state);\n            this.emitter.emit(\"HISTORY_NEW_ITEM\", event);\n        }\n\n        if (event) {\n            event.stopPropagation();\n            event.preventDefault();\n        }\n\n        this.emitter.emit(\"GO\", event);\n        return this.load({\n            oldHref: currentURL,\n            href,\n            trigger,\n            transitionName,\n            scroll,\n        });\n    }\n\n    /** Load the new Page as well as a Transition; starts the Transition */\n    public async load({\n        oldHref,\n        href,\n        trigger,\n        transitionName = \"default\",\n        scroll = { x: 0, y: 0 },\n    }: {\n        oldHref: string;\n        href: string;\n        trigger: Trigger;\n        transitionName?: string;\n        scroll: { x: number; y: number };\n    }): Promise<any> {\n        try {\n            const pages = this.manager.get(\"PageManager\") as IPageManager;\n            let newPage: IPage, oldPage: IPage;\n            this.emitter.emit(\"NAVIGATION_START\", {\n                oldHref,\n                href,\n                trigger,\n                transitionName,\n            });\n\n            // Load & Build both the old and new pages\n            try {\n                this.transitionStart();\n                oldPage = await pages.load(oldHref);\n                !(oldPage.dom instanceof Element) && oldPage.build();\n\n                this.emitter.emit(\"PAGE_LOADING\", { href, oldPage, trigger });\n                newPage = await pages.load(href);\n                await newPage.build();\n                this.emitter.emit(\"PAGE_LOAD_COMPLETE\", {\n                    newPage,\n                    oldPage,\n                    trigger,\n                });\n            } catch (err) {\n                console.warn(`[PJAX] Page load error: ${err}`);\n            }\n\n            // Transition Between Pages\n            try {\n                const TransitionManager = this.manager.get(\"TransitionManager\") as ITransitionManager;\n                this.emitter.emit(\"TRANSITION_START\", transitionName);\n\n                let transition = await TransitionManager.animate(TransitionManager.has(transitionName) ? transitionName : \"default\", {\n                    oldPage,\n                    newPage,\n                    trigger,\n                    scroll,\n                    ignoreHashAction: this.ignoreHashAction\n                });\n\n                if (!transition.scrollable) {\n                    if (!this.ignoreHashAction && !/back|popstate|forward/.test(trigger as string)) scroll = hashAction(scroll);\n                    window.scroll(scroll.x, scroll.y);\n                }\n\n                this.emitter.emit(\"TRANSITION_END\", { transition });\n            } catch (err) {\n                console.warn(`[PJAX] Transition error: ${err}`);\n            }\n\n            // Navigation is over\n            this.emitter.emit(\"NAVIGATION_END\", {\n                oldPage,\n                newPage,\n                trigger,\n                transitionName,\n            });\n        } catch (err) {\n            if (this.forceOnError) this.force(href);\n            else console.warn(err);\n        } finally {\n            this.transitionStop(); // Sets isTransitioning to false\n        }\n    }\n\n    /** Check to see if the URL is to be ignored, uses either RegExp of Strings to check */\n    public ignoredURL({ pathname }: URL): boolean {\n        return (\n            this.ignoreURLs.length &&\n            this.ignoreURLs.some((url) => {\n                return typeof url === \"string\"\n                    ? url === pathname\n                    : (url as RegExp).exec(pathname) !== null;\n            })\n        );\n    }\n\n    /** When you hover over an anchor, prefetch the event target's href */\n    public onHover(event: LinkEvent): Promise<void> {\n        let el = this.getLink(event);\n        if (!el || !this.manager.has(\"PageManager\")) return;\n\n        const pages = this.manager.get(\"PageManager\") as IPageManager;\n        let url = newURL(this.getHref(el));\n        let urlString: string = url.pathname;\n\n        // If Url is ignored or already in cache, don't do any think\n        if (this.ignoredURL(url) || pages.has(urlString)) return;\n        this.emitter.emit(\"ANCHOR_HOVER HOVER\", event);\n\n        try {\n            pages.load(url);\n        } catch (err) {\n            console.warn(\"[PJAX] prefetch error,\", err);\n        }\n    }\n\n    /** When History state changes, get url from State, go for a Transition. */\n    public onStateChange(event: PopStateEvent): void {\n        this.go({ href: window.location.href, trigger: \"popstate\", event });\n    }\n\n    /** Initialize DOM Events */\n    public initEvents() {\n        if (this.prefetchIgnore !== true) {\n            document.addEventListener(\"mouseover\", this.onHover);\n            document.addEventListener(\"touchstart\", this.onHover);\n        }\n\n        document.addEventListener(\"click\", this.onClick);\n        window.addEventListener(\"popstate\", this.onStateChange);\n    }\n\n    /** Stop DOM Events */\n    public stopEvents() {\n        if (this.prefetchIgnore !== true) {\n            document.removeEventListener(\"mouseover\", this.onHover);\n            document.removeEventListener(\"touchstart\", this.onHover);\n        }\n\n        document.removeEventListener(\"click\", this.onClick);\n        window.removeEventListener(\"popstate\", this.onStateChange);\n    }\n}\n", "import { Service } from \"./service\";\nimport { Manager } from \"./manager\";\nimport { newURL, getHashedPath } from \"./url\";\nimport { IHistoryManager } from \"./history\";\n\nexport type RouteMethod = (...args: any) => any;\nexport type RouteStyle = string | RegExp | boolean;\nexport interface IRouteToFrom {\n    to: RouteStyle,\n    from: RouteStyle\n}\nexport type RoutePath = IRouteToFrom | RouteStyle;\nexport interface IRoute {\n    path: RoutePath,\n    method: RouteMethod\n}\n\n/** Controls what happens when certain url paths match a set of criteria */\nexport class Router extends Service {\n    /** List of routes */\n    protected routes: Manager<IRouteToFrom, RouteMethod>;\n    constructor(routes: IRoute[] = []) {\n        super();\n        this.routes = new Manager();\n        for (let route of routes) {\n            this.add(route);\n        }\n    }\n\n    /** Add a new route to watch for */\n    public add({ path, method }: IRoute): Router {\n        let key = this.parse(path);\n        this.routes.set(key, method);\n        return this;\n    }\n\n    /** Convert strings into path match functions */\n    public parsePath(path: RouteStyle): RegExp | boolean {\n        if (typeof path === \"string\") return new RegExp(path, \"i\");\n        else if (path instanceof RegExp || typeof path === \"boolean\")\n            return path;\n        throw \"[Router] only regular expressions, strings and booleans are accepted as paths.\";\n    }\n\n    /** Determines if a strings counts has a path */\n    public isPath(input: RouteStyle): boolean {\n        return (\n            typeof input === \"string\" ||\n            input instanceof RegExp ||\n            typeof input === \"boolean\"\n        );\n    }\n\n    /** Parse the multiple different formats for paths, into a { from, to } object */\n    public parse(input: RoutePath): IRouteToFrom {\n        let route = input as IRouteToFrom;\n        let toFromPath: IRouteToFrom = {\n            from: /(.*)/g,\n            to: /(.*)/g,\n        };\n\n        if (this.isPath(input as RouteStyle))\n            toFromPath = {\n                from: true,\n                to: input as RouteStyle,\n            };\n        else if (this.isPath(route.from) && this.isPath(route.to as RouteStyle))\n            toFromPath = route;\n        else\n            throw \"[Router] path is neither a string, regular expression, or a { from, to } object.\";\n\n        let { from, to } = toFromPath;\n        return {\n            from: this.parsePath(from),\n            to: this.parsePath(to),\n        };\n    }\n\n    /** Test if route paths are true, if so run their methods */\n    public route() {\n        if (this.manager.has(\"HistoryManager\")) {\n            let history = this.manager.get(\"HistoryManager\") as IHistoryManager;\n            let from: string = getHashedPath(newURL((history.length > 1 ? history.previous : history.current).url));\n            let to: string = getHashedPath(newURL());\n\n            this.routes.forEach((method: RouteMethod, path: IRouteToFrom) => {\n                let fromRegExp = path.from as RegExp | boolean;\n                let toRegExp = path.to as RegExp | boolean;\n\n                if (\n                    typeof fromRegExp === \"boolean\" &&\n                    typeof toRegExp === \"boolean\"\n                ) {\n                    throw `[Router] path ({ from: ${fromRegExp}, to: ${toRegExp} }) is not valid, remember paths can only be strings, regular expressions, or a boolean; however, both the from and to paths cannot be both booleans.`;\n                }\n\n                let fromParam: RegExpExecArray | RegExp | boolean = fromRegExp;\n                let toParam: RegExpExecArray | RegExp | boolean = toRegExp;\n\n                if (fromRegExp instanceof RegExp && fromRegExp.test(from))\n                    fromParam = fromRegExp.exec(from);\n                if (toRegExp instanceof RegExp && toRegExp.test(to))\n                    toParam = toRegExp.exec(to);\n\n                if (\n                    (Array.isArray(toParam) && Array.isArray(fromParam)) ||\n                    (Array.isArray(toParam) &&\n                        typeof fromParam == \"boolean\" &&\n                        fromParam) ||\n                    (Array.isArray(fromParam) &&\n                        typeof toParam == \"boolean\" &&\n                        toParam)\n                )\n                    method({ from: fromParam, to: toParam, path: { from, to } });\n            });\n        } else {\n            console.warn(\"[Route] HistoryManager is missing.\");\n        }\n    }\n\n    /** Add listeners for PJAX Events */\n    public initEvents() {\n        this.emitter.on(\"READY\", this.route, this);\n        this.emitter.on(\"CONTENT_REPLACED\", this.route, this);\n    }\n\n    /** Remove listeners for PJAX Events */\n    public stopEvents() {\n        this.emitter.off(\"READY\", this.route, this);\n        this.emitter.off(\"CONTENT_REPLACED\", this.route, this);\n    }\n}\n", "import { EventEmitter, EventInput, ListenerCallback } from \"@okikio/emitter\";\nimport { Manager } from \"@okikio/manager\";\n\n// DOM\nexport type AnimationTarget = string | Node | NodeList | HTMLCollection | HTMLElement[] | AnimationTarget[];\nexport const getElements = (selector: string | Node): Node[] => {\n    return typeof selector === \"string\" ? Array.from(document.querySelectorAll(selector as string)) : [selector];\n};\n\nconst flatten = (arr: AnimationTarget[]) => [].concat(...arr);\nexport const getTargets = (targets: AnimationTarget): Node[] => {\n    if (Array.isArray(targets)) {\n        return flatten((targets as AnimationTarget[]).map(getTargets));\n    }\n    if (typeof targets == \"string\" || targets instanceof Node)\n        return getElements(targets);\n    if (targets instanceof NodeList || targets instanceof HTMLCollection)\n        return Array.from(targets);\n    return [];\n};\n\n// VALUES\nexport type closureArgs = [number, number, HTMLElement];\nexport type closure = ((index?: number, total?: number, element?: HTMLElement) => (genericTypes[] | void)) | any;\nexport const computeValue = (value: closure, args: closureArgs, context: Animate) => {\n    if (typeof value === \"function\") {\n        return value.apply(context, args);\n    } else { return value; }\n};\n\nexport const mapObject = (obj: object, args: closureArgs, options: Animate): any => {\n    let key: string, value: any, result = {};\n    let keys = Object.keys(obj);\n    for (let i = 0, len = keys.length; i < len; i++) {\n        key = keys[i];\n        value = obj[key];\n        result[key] = computeValue(value, args, options);\n    }\n\n    return result;\n};\n\n/** From: [https://easings.net] */\nexport const easings = {\n    \"in\": \"ease-in\",\n    \"out\": \"ease-out\",\n    \"in-out\": \"ease-in-out\",\n\n    // Sine\n    \"in-sine\": \"cubic-bezier(0.47, 0, 0.745, 0.715)\",\n    \"out-sine\": \"cubic-bezier(0.39, 0.575, 0.565, 1)\",\n    \"in-out-sine\": \"cubic-bezier(0.445, 0.05, 0.55, 0.95)\",\n\n    // Quad\n    \"in-quad\": \"cubic-bezier(0.55, 0.085, 0.68, 0.53)\",\n    \"out-quad\": \"cubic-bezier(0.25, 0.46, 0.45, 0.94)\",\n    \"in-out-quad\": \"cubic-bezier(0.455, 0.03, 0.515, 0.955)\",\n\n    // Cubic\n    \"in-cubic\": \"cubic-bezier(0.55, 0.055, 0.675, 0.19)\",\n    \"out-cubic\": \"cubic-bezier(0.215, 0.61, 0.355, 1)\",\n    \"in-out-cubic\": \"cubic-bezier(0.645, 0.045, 0.355, 1)\",\n\n    // Quart\n    \"in-quart\": \"cubic-bezier(0.895, 0.03, 0.685, 0.22)\",\n    \"out-quart\": \"cubic-bezier(0.165, 0.84, 0.44, 1)\",\n    \"in-out-quart\": \"cubic-bezier(0.77, 0, 0.175, 1)\",\n\n    // Quint\n    \"in-quint\": \"cubic-bezier(0.755, 0.05, 0.855, 0.06)\",\n    \"out-quint\": \"cubic-bezier(0.23, 1, 0.32, 1)\",\n    \"in-out-quint\": \"cubic-bezier(0.86, 0, 0.07, 1)\",\n\n    // Expo\n    \"in-expo\": \"cubic-bezier(0.95, 0.05, 0.795, 0.035)\",\n    \"out-expo\": \"cubic-bezier(0.19, 1, 0.22, 1)\",\n    \"in-out-expo\": \"cubic-bezier(1, 0, 0, 1)\",\n\n    // Circ\n    \"in-circ\": \"cubic-bezier(0.6, 0.04, 0.98, 0.335)\",\n    \"out-circ\": \"cubic-bezier(0.075, 0.82, 0.165, 1)\",\n    \"in-out-circ\": \"cubic-bezier(0.785, 0.135, 0.15, 0.86)\",\n\n    // Back\n    \"in-back\": \"cubic-bezier(0.6, -0.28, 0.735, 0.045)\",\n    \"out-back\": \"cubic-bezier(0.175, 0.885, 0.32, 1.275)\",\n    \"in-out-back\": \"cubic-bezier(0.68, -0.55, 0.265, 1.55)\"\n};\n\nexport const getEase = (ease: string) => {\n    return /^(in|out)/.test(ease) ? easings[ease] : ease;\n};\n\nexport type genericTypes = genericTypes[] | boolean | object | string | number | closure | null | undefined;\nexport interface AnimationOptions {\n    target?: AnimationTarget,\n\n    speed?: number,\n    autoplay?: boolean,\n    options?: AnimationOptions,\n    delay?: number | closure,\n    easing?: string | closure,\n    endDelay?: number | closure,\n    duration?: number | closure,\n    keyframes?: Keyframe[] | object[] | closure,\n    loop?: number | boolean | closure, // iterations: number,\n    onfinish?: (element?: HTMLElement, index?: number, total?: number, animation?: Animation) => any,\n    fillMode?: \"none\" | \"forwards\" | \"backwards\" | \"both\" | \"auto\" | closure,\n    direction?: \"normal\" | \"reverse\" | \"alternate\" | \"alternate-reverse\" | closure,\n    extend?: EffectTiming,\n    [property: string]: genericTypes;\n};\n\nexport const DefaultAnimationOptions: AnimationOptions = {\n    keyframes: [],\n\n    loop: 1, // iterations: number,\n    delay: 0,\n    speed: 1,\n    endDelay: 0,\n    easing: \"ease\",\n    autoplay: true,\n    duration: 1000,\n    fillMode: \"auto\",\n    direction: \"normal\",\n    extend: {}\n};\n\nexport type AnimationEvents = \"update\" | \"play\" | \"pause\" | \"start\" | \"begin\" | \"complete\" | \"finish\" | \"error\" | \"stop\";\n\n/** You can check it out here: https://codepen.io/okikio/pen/qBbdGaW?editors=0011 */\nexport class Animate {\n    /**\n     * Stores the options for the current animation\n     */\n    public options: AnimationOptions = {};\n\n    /**\n     * The Array of Elements to Animate\n     */\n    public targets: Node[] = [];\n\n    /**\n     * The properties to animate\n     */\n    public properties: object = {};\n\n    /**\n     * A Manager of Animations\n     */\n    public animations: Manager<HTMLElement, Animation> = new Manager();\n\n    /**\n     * The total duration of all Animation's\n     */\n    public totalDuration: number = 0;\n\n    /**\n     * The smallest delay out of all Animation's\n     */\n    public minDelay: number = 0;\n\n    /**\n     * The options for individual animations\n     */\n    public computedOptions: Manager<Animation, AnimationOptions> = new Manager();\n\n    /**\n     * The Element the main animation uses\n     */\n    public mainElement: HTMLElement;\n\n    /**\n     * Stores an animation that runs on the total duration of the all other Animations, and as such it's the main Animation\n     */\n    public mainAnimation: Animation;\n\n    /**\n     * Stores request frame calls\n     */\n    public animationFrame: number;\n\n    /**\n     * An event emitter\n     */\n    public emitter: EventEmitter = new EventEmitter();\n\n    /**\n     * Returns a promise that is fulfilled when the mainAnimation is finished\n     */\n    public promise: Promise<AnimationOptions>;\n    constructor(options: AnimationOptions = {}) {\n        try {\n            let { options: animation, ...rest } = options;\n            let oldOptions = animation instanceof Animate ? animation.getOptions() : (Array.isArray(animation) ? animation?.[0]?.getOptions() : animation);\n            this.options = Object.assign({}, DefaultAnimationOptions, oldOptions, rest);\n            this.loop = this.loop.bind(this);\n\n            let {\n                loop,\n                delay,\n                speed,\n                easing,\n                endDelay,\n                duration,\n                direction,\n                fillMode,\n                onfinish,\n                target,\n                keyframes,\n                autoplay,\n                extend,\n                ...properties\n            } = this.options;\n\n            this.mainElement = document.createElement(\"div\");\n            this.targets = getTargets(target);\n            this.properties = properties;\n\n            let delays = [];\n            let len = this.targets.length;\n            let animationKeyframe: Keyframe[] | PropertyIndexedKeyframes;\n            for (let i = 0; i < len; i++) {\n                let target = this.targets[i] as HTMLElement;\n                let animationOptions: AnimationOptions = {\n                    easing: typeof easing == \"string\" ? getEase(easing) : easing,\n                    iterations: loop === true ? Infinity : (loop as number),\n                    direction,\n                    endDelay,\n                    duration,\n                    delay,\n                    fill: fillMode,\n                    ...extend\n                };\n\n                // Accept keyframes as a keyframes Object, or a method,\n                // if there are no animations in the keyframes array,\n                // uses css properties from the options object\n                let arrKeyframes = computeValue((keyframes as Keyframe[]), [i, len, target], this);\n                animationKeyframe = arrKeyframes.length ? arrKeyframes :\n                    (this.properties as PropertyIndexedKeyframes);\n\n                // Allows the use of functions as the values, for both the keyframes and the animation object\n                // It adds the capability of advanced stagger animation, similar to the anime js stagger functions\n                animationOptions = mapObject(animationOptions, [i, len, target], this);\n                if (!(arrKeyframes.length > 0))\n                    animationKeyframe = mapObject(animationKeyframe, [i, len, target], this);\n\n                // Set the Animate classes duration to be the Animation with the largest totalDuration\n                let tempDurations = animationOptions.delay +\n                    (animationOptions.duration * animationOptions.iterations) +\n                    animationOptions.endDelay;\n                if (this.totalDuration < tempDurations) this.totalDuration = tempDurations;\n\n                // Add animation to the Animations Set\n                let animation = target.animate(animationKeyframe, animationOptions as KeyframeAnimationOptions);\n\n                // Support for on finish\n                animation.onfinish = () => {\n                    typeof onfinish == \"function\" && onfinish.call(this, target, i, len, animation);\n                    this.emit(\"finish\", target, i, len, animation);\n                };\n\n                // The calculated options for each individual option\n                this.computedOptions.set(animation, animationOptions);\n                this.animations.set(target, animation);\n                delays.push(animationOptions.delay);\n            }\n\n            this.mainAnimation = this.mainElement.animate([\n                { opacity: \"0\" },\n                { opacity: \"1\" }\n            ], {\n                // Why waste performance on an animation no one can see?\n                duration: this.totalDuration,\n                easing: \"linear\"\n            });\n\n            this.minDelay = Math.min(...delays);\n            this.setSpeed(speed);\n            if (autoplay) this.play();\n            else this.pause();\n\n            this.promise = this.newPromise();\n            this.mainAnimation.onfinish = () => {\n                this.emit(\"complete\", this);\n                this.stopLoop();\n            };\n        } catch (err) {\n            this.emit(\"error\", err);\n        }\n    }\n\n    /**\n     * Returns a new Promise that is resolve when this.finish is called\n     */\n    public newPromise(): Promise<AnimationOptions> {\n        return new Promise((resolve, reject) => {\n            /*\n                Note that the `this` keyword is in an Array when it is resolved,\n                this is due to Promises not wanting to resolve references,\n                so, you can't resolve `this` directly, so, I chose to resolve `this` in an\n                Array\n            */\n            this.on(\"complete\", () => resolve([this]));\n            this.on(\"error\", err => reject(err));\n        });\n    }\n\n    /**\n     * Fulfills the this.promise Promise\n     */\n    public then(\n        onFulfilled?: (value?: any) => any,\n        onRejected?: (reason?: any) => any\n    ): Animate {\n        onFulfilled = onFulfilled?.bind(this);\n        onRejected = onRejected?.bind(this);\n        this.promise.then(onFulfilled, onRejected);\n        return this;\n    }\n\n    /**\n     * Catches error that occur in the this.promise Promise\n     */\n    public catch(onRejected: (reason?: any) => any): Animate {\n        onRejected = onRejected?.bind(this);\n        this.promise.catch(onRejected);\n        return this;\n    }\n\n    /**\n     * If you don't care if the this.promise Promise has either been rejected or resolved\n     */\n    public finally(onFinally: () => any): Animate {\n        onFinally = onFinally?.bind(this);\n        this.promise.finally(onFinally);\n        return this;\n    }\n\n    /**\n     * Represents an Animation Frame Loop\n     */\n    public loop(): void {\n        this.stopLoop();\n        this.emit(\"update\", this.getProgress(), this);\n        this.animationFrame = window.requestAnimationFrame(this.loop);\n    }\n\n    /**\n     * Cancels animation frame\n     */\n    public stopLoop() {\n        window.cancelAnimationFrame(this.animationFrame);\n    }\n\n    /**\n     * Calls a method that affects all animations including the mainAnimation; the method only allows the animation parameter\n    */\n    public all(method: (animation?: Animation, target?: HTMLElement) => void) {\n        method(this.mainAnimation, this.mainElement);\n        this.animations.forEach(method);\n        return this;\n    }\n\n    /**\n     * Register the begin event\n     */\n    protected beginEvent() {\n        if (this.getProgress() == 0) {\n            let timer: number | void = window.setTimeout(() => {\n                this.emit(\"begin\", this);\n                timer = window.clearTimeout(timer as number);\n            }, this.minDelay);\n        }\n    }\n\n    /**\n     * Play Animation\n     */\n    public play(): Animate {\n        let playstate = this.getPlayState();\n        this.beginEvent();\n        this.all(anim => anim.play());\n        this.emit(\"play\", playstate, this);\n        this.loop();\n        return this;\n    }\n\n    /**\n     * Pause Animation\n     */\n    public pause(): Animate {\n        let playstate = this.getPlayState();\n        this.all(anim => anim.pause());\n        this.emit(\"pause\", playstate, this);\n        this.stopLoop();\n        this.animationFrame = undefined;\n        return this;\n    }\n\n    /**\n     * Reset all Animations\n     */\n    public reset() {\n        this.setProgress(0);\n        this.beginEvent();\n\n        if (this.options.autoplay) this.play();\n        else this.pause();\n        return this;\n    }\n\n    /**\n     * Cancels all Animations\n     */\n    public cancel() {\n        this.all(anim => anim.cancel());\n        this.stopLoop();\n        return this;\n    }\n\n    /**\n     * Force complete all Animations\n     */\n    public finish() {\n        this.all(anim => anim.finish());\n        this.stopLoop();\n        return this;\n    }\n\n    /**\n     * Cancels & Clears all Animations\n     */\n    public stop() {\n        this.cancel();\n        this.animations.clear();\n        while (this.targets.length) this.targets.pop();\n        this.mainElement = undefined;\n        this.emit(\"stop\");\n    }\n\n    /**\n     * Returns an Array of targets\n     */\n    public getTargets(): Node[] {\n        return this.targets;\n    }\n\n    /**\n     * Get a specific Animation from an Animate instance\n     */\n    public getAnimation(element: HTMLElement): Animation {\n        return this.animations.get(element);\n    }\n\n    /**\n     * Returns the timings of an Animation, given a target\n     * E.g. { duration, endDelay, delay, iterations, iterationStart, direction, easing, fill, etc... }\n     */\n    public getTiming(target: HTMLElement | Animation): AnimationOptions & EffectTiming {\n        let animation = target instanceof Animation ? target : this.getAnimation(target);\n        let keyframeOptions = this.computedOptions.get(animation) ?? {};\n        let timings = animation.effect?.getTiming() ?? {};\n        let options = this.getOptions();\n\n        return { ...DefaultAnimationOptions, ...options, ...timings, ...keyframeOptions };\n    }\n\n    /**\n     * Returns the total duration of Animation\n     */\n    public getTotalDuration(): number {\n        return this.totalDuration;\n    }\n\n    /**\n     * Returns the current time of the Main Animation\n     */\n    public getCurrentTime(): number {\n        return this.mainAnimation.currentTime;\n    }\n\n    /**\n     * Returns the Animation progress as a fraction of the current time / duration * 100\n     */\n    public getProgress() {\n        return (this.getCurrentTime() / this.totalDuration) * 100;\n    }\n\n    /**\n     * Return the playback speed of the animation\n     */\n    public getSpeed(): number {\n        return this.mainAnimation.playbackRate;\n    }\n\n    /**\n     * Returns the current playing state\n     */\n    public getPlayState(): \"idle\" | \"running\" | \"paused\" | \"finished\" {\n        return this.mainAnimation.playState;\n    }\n\n    /**\n     * Get the options of an Animate instance\n     */\n    public getOptions(): AnimationOptions {\n        return this.options;\n    }\n\n    /**\n     * Set the current time of the Main Animation\n     */\n    public setCurrentTime(time: number): Animate {\n        this.all(anim => { anim.currentTime = time; });\n        this.emit(\"update\", this.getProgress());\n        return this;\n    }\n\n    /**\n     * Set the Animation progress as a value from 0 to 100\n     */\n    public setProgress(percent: number): Animate {\n        let time = (percent / 100) * this.totalDuration;\n        this.setCurrentTime(time);\n        return this;\n    }\n\n    /**\n     * Set the playback speed of an Animation\n     */\n    public setSpeed(speed: number = 1): Animate {\n        this.all(anim => { anim.playbackRate = speed; });\n        return this;\n    }\n\n    /**\n     * Adds a listener for a given event\n     */\n    public on(events: AnimationEvents | EventInput, callback?: ListenerCallback, scope?: object): Animate {\n        this.emitter.on(events, callback, scope ?? this);\n        return this;\n    }\n\n    /**\n     * Removes a listener from an event\n     */\n    public off(events: AnimationEvents | EventInput, callback?: ListenerCallback, scope?: object): Animate {\n        this.emitter.off(events, callback, scope ?? this);\n        return this;\n    }\n\n    /**\n     * Call all listeners within an event\n     */\n    public emit(events: AnimationEvents | string | any[], ...args: any): Animate {\n        this.emitter.emit(events, ...args);\n        return this;\n    }\n\n\n    /** Returns the Animate options, as JSON  */\n    public toJSON(): AnimationOptions {\n        return this.getOptions();\n    }\n\n    /**\n     * The Symbol.toStringTag well-known symbol is a string valued property that is used\n     * in the creation of the default string description of an object.\n     * It is accessed internally by the Object.prototype.toString() method.\n     */\n    get [Symbol.toStringTag]() {\n        return `Animate`;\n    }\n}\n\n/** Creates a new Animate instance */\nexport const animate = (options: AnimationOptions = {}): Animate => {\n    return new Animate(options);\n};\n\nexport class Timeline extends Animate {\n    /**\n     * A Manager of Animations\n     */\n    public animations: Manager<HTMLElement, Animation> = new Manager();\n    constructor(options: AnimationOptions = {}) {\n        super();\n        try {\n            let { options: animation, ...rest } = options;\n            let oldOptions = animation instanceof Animate ? animation.getOptions() : (Array.isArray(animation) ? animation?.[0]?.getOptions() : animation);\n            this.options = Object.assign({}, DefaultAnimationOptions, oldOptions, rest);\n            this.loop = this.loop.bind(this);\n\n            let {\n                loop,\n                delay,\n                speed,\n                easing,\n                endDelay,\n                duration,\n                direction,\n                fillMode,\n                onfinish,\n                target,\n                keyframes,\n                autoplay,\n                extend,\n                ...properties\n            } = this.options;\n\n            this.mainElement = document.createElement(\"div\");\n            this.targets = getTargets(target);\n            this.properties = properties;\n\n            let delays = [];\n            let len = this.targets.length;\n            let animationKeyframe: Keyframe[] | PropertyIndexedKeyframes;\n            for (let i = 0; i < len; i++) {\n                let target = this.targets[i] as HTMLElement;\n                let animationOptions: AnimationOptions = {\n                    easing: typeof easing == \"string\" ? getEase(easing) : easing,\n                    iterations: loop === true ? Infinity : (loop as number),\n                    direction,\n                    endDelay,\n                    duration,\n                    delay,\n                    fill: fillMode,\n                    ...extend\n                };\n\n                // Accept keyframes as a keyframes Object, or a method,\n                // if there are no animations in the keyframes array,\n                // uses css properties from the options object\n                let arrKeyframes = computeValue((keyframes as Keyframe[]), [i, len, target], this);\n                animationKeyframe = arrKeyframes.length ? arrKeyframes :\n                    (this.properties as PropertyIndexedKeyframes);\n\n                // Allows the use of functions as the values, for both the keyframes and the animation object\n                // It adds the capability of advanced stagger animation, similar to the anime js stagger functions\n                animationOptions = mapObject(animationOptions, [i, len, target], this);\n                if (!(arrKeyframes.length > 0))\n                    animationKeyframe = mapObject(animationKeyframe, [i, len, target], this);\n\n                // Set the Animate classes duration to be the Animation with the largest totalDuration\n                let tempDurations = animationOptions.delay +\n                    (animationOptions.duration * animationOptions.iterations) +\n                    animationOptions.endDelay;\n                if (this.totalDuration < tempDurations) this.totalDuration = tempDurations;\n\n                // Add animation to the Animations Set\n                let animation = target.animate(animationKeyframe, animationOptions as KeyframeAnimationOptions);\n\n                // Support for on finish\n                animation.onfinish = () => {\n                    typeof onfinish == \"function\" && onfinish.call(this, target, i, len, animation);\n                    this.emit(\"finish\", target, i, len, animation);\n                };\n\n                // The calculated options for each individual option\n                this.computedOptions.set(animation, animationOptions);\n                this.animations.set(target, animation);\n                delays.push(animationOptions.delay);\n            }\n\n            this.mainAnimation = this.mainElement.animate([\n                { opacity: \"0\" },\n                { opacity: \"1\" }\n            ], {\n                // Why waste performance on an animation no one can see?\n                duration: this.totalDuration,\n                easing: \"linear\"\n            });\n\n            this.minDelay = Math.min(...delays);\n            this.setSpeed(speed);\n            if (autoplay) this.play();\n            else this.pause();\n\n            this.promise = this.newPromise();\n            this.mainAnimation.onfinish = () => {\n                this.emit(\"complete\", this);\n                this.stopLoop();\n            };\n        } catch (err) {\n            this.emit(\"error\", err);\n        }\n    }\n    public add(options: AnimationOptions) {\n        return this;\n    }\n}\n\nexport default animate;", "export const toArr = (input: any): any[] => Array.from(input);\nexport default toArr;", "import { Service, animate } from \"../../../packages/native/src/api\";\nimport toArr from \"../toArr\";\n\nexport class IntroAnimation extends Service {\n    public elements: Array<Element>;\n    public rootElement: HTMLElement;\n\n    public init() {\n        super.init();\n\n        // Elements\n        this.elements = toArr(document.querySelectorAll('.intro-animation'));\n    }\n\n    public newPage() {\n        this.init();\n        this.prepareToShow();\n    }\n\n    public initEvents() {\n        this.emitter.on(\"CONTENT_REPLACED\", this.newPage, this);\n        this.emitter.on(\"BEFORE_TRANSITION_IN\", this.show, this);\n    }\n\n    public stopEvents() {\n        this.emitter.off(\"CONTENT_REPLACED\", this.newPage, this);\n        this.emitter.off(\"BEFORE_TRANSITION_IN\", this.show, this);\n    }\n\n    public stop() {\n        requestAnimationFrame(() => {\n            for (let el of this.elements) {\n                (el as HTMLElement).style.opacity = '1';\n            }\n        });\n\n        super.stop();\n    }\n\n    public prepareToShow() {\n        requestAnimationFrame(() => {\n            for (let el of this.elements) {\n                (el as HTMLElement).style.opacity = '0';\n            }\n        });\n    }\n\n    public async show() {\n        let [anim] = await animate({\n            target: (this.elements as HTMLElement[]),\n            opacity: [0, 1],\n            // @ts-ignore\n            delay(i: number) {\n                return 300 * (i + 1);\n            },\n            onfinish(el: { style: { transform: string; opacity: string; }; }) {\n                requestAnimationFrame(() => {\n                    el.style.opacity = \"1\";\n                });\n            },\n            easing: \"ease\",\n            duration: 850\n        });\n        anim.stop();\n        return anim;\n    }\n}\n", "import { ITransition, ITransitionData, animate } from \"../../../packages/native/src/api\";\n\n//== Transition\nexport const Fade: ITransition = {\n    name: \"default\",\n    duration: 500,\n    scrollable: true,\n\n    out({ from }: ITransitionData) {\n        let { duration } = this;\n        let fromWrapper = from.wrapper;\n        return animate({\n            target: fromWrapper,\n            opacity: [1, 0],\n            duration,\n        }).on(\"finish\", function () {\n            window.scroll(0, 0);\n            this.stop();\n        });\n    },\n\n    in({ to, scroll }: ITransitionData) {\n        let { duration } = this;\n        let toWrapper = to.wrapper;\n\n        window.scroll(scroll.x, scroll.y);\n        return animate({\n            target: toWrapper,\n            opacity: [0, 1],\n            duration\n        }).then(function () {\n            this.stop();\n        });\n    }\n};\n", "import { ITransition, ITransitionData, animate } from \"../../../packages/native/src/api\";\nimport toArr from \"../toArr\";\n\n//== Transitions\nexport const BigTransition: ITransition = {\n    name: \"big\",\n    delay: 200,\n    durationPerAnimation: 700,\n    scrollable: true,\n\n    init() {\n        this.mainElement = document.getElementById('big-transition');\n        this.logoElement = this.mainElement.querySelector('#logo');\n        this.horizontalElements = toArr(this.mainElement.querySelectorAll('#big-transition-horizontal div'));\n        this.maxLength = this.horizontalElements.length;\n    },\n\n    out({ from, scroll }: ITransitionData) {\n        let { durationPerAnimation: duration, delay } = this;\n        let fromWrapper = from.wrapper;\n\n        let wrapperStyle = Object.assign({}, fromWrapper.style);\n        return new Promise<void>(async resolve => {\n            this.mainElement.style.opacity = \"1\";\n            this.mainElement.style.visibility = \"visible\";\n            let anim1 = animate({\n                target: fromWrapper,\n                opacity: [1, 0],\n                duration,\n                onfinish(el: { style: { opacity: string; }; }) {\n                    el.style.opacity = '0';\n                }\n            });\n\n            anim1.then(function () { this.stop(); });\n\n            let [anim2] = await animate({\n                target: this.horizontalElements,\n                keyframes: [\n                    { transform: \"scaleX(0)\" },\n                    { transform: \"scaleX(1)\" },\n                ],\n                // @ts-ignore\n                delay(i: number) {\n                    return delay * (i + 1);\n                },\n                onfinish(el: { style: { transform: string; }; }) {\n                    el.style.transform = `scaleX(1)`;\n                },\n                easing: \"out-cubic\",\n                duration: 500\n            });\n\n            fromWrapper.style.opacity = '1';\n            Object.assign(fromWrapper.style, wrapperStyle);\n            this.logoElement.style.visibility = \"visible\";\n\n            let loaderDuration = 500;\n            let [anim3] = await animate({\n                target: this.logoElement,\n                opacity: [0, 1],\n                duration: loaderDuration,\n                onfinish(el: { style: { opacity: string; }; }) {\n                    el.style.opacity = `1`;\n                },\n            });\n\n            let [anim4] = await animate({\n                options: anim3,\n                opacity: [1, 0],\n                onfinish(el: { style: { opacity: string; }; }) {\n                    el.style.opacity = `0`;\n                },\n                delay: 1500\n            });\n            this.logoElement.style.visibility = \"hidden\";\n            // anim2.stop() // -> anim2.stop() Breaks the Animation\n            anim3.stop();\n            anim4.stop();\n            resolve();\n        });\n    },\n\n    in({ to, scroll }: ITransitionData) {\n        let { durationPerAnimation: duration, delay } = this;\n        let toWrapper = to.wrapper;\n\n        window.scroll(scroll.x, scroll.y);\n        return new Promise<void>(async resolve => {\n            let anim1 = animate({\n                target: toWrapper,\n                opacity: [0, 1],\n                duration\n            }).then(() => {\n                anim1.stop();\n            });\n\n            let [anim2] = await animate({\n                target: this.horizontalElements,\n                keyframes: [\n                    { transform: \"scaleX(1)\" },\n                    { transform: \"scaleX(0)\" },\n                ],\n                // @ts-ignore\n                delay(i: number) {\n                    return delay * (i + 1);\n                },\n                onfinish(el: { style: { transform: string; }; }) {\n                    el.style.transform = `scaleX(0)`;\n                },\n                easing: \"out-cubic\",\n                duration: 500\n            });\n\n            this.mainElement.style.opacity = \"0\";\n            this.mainElement.style.visibility = \"hidden\";\n            anim2.stop();\n            resolve();\n        });\n    }\n}\n", "import { ITransition, ITransitionData, animate } from \"../../../packages/native/src/api\";\n\n//== Transitions\nexport const Slide: ITransition = {\n    name: \"slide\",\n    duration: 500,\n    direction: \"right\",\n    scrollable: true,\n\n    init(data: ITransition) {\n        let trigger = (data.trigger as HTMLElement);\n        if (trigger instanceof Node && trigger.hasAttribute(\"data-direction\")) {\n            this.direction = trigger.getAttribute(\"data-direction\");\n        } else {\n            this.direction = \"right\";\n        }\n    },\n\n    out({ from }: ITransitionData) {\n        let { duration, direction } = this;\n        let fromWrapper = from.wrapper;\n\n        let anim = animate({\n            target: fromWrapper,\n            keyframes: [\n                { transform: \"translateX(0%)\", opacity: 1 },\n                { transform: `translateX(${direction === \"left\" ? \"-\" : \"\"}25%)`, opacity: 0 },\n            ],\n            duration,\n            easing: \"in-quint\"\n        });\n\n        return anim.on(\"begin\", () => {\n            document.body.classList.add(\"no-overflow-x\");\n        }).then(function () {\n            this.stop();\n        });\n    },\n\n    in({ to, scroll }: ITransitionData) {\n        let { duration } = this;\n        let toWrapper = to.wrapper;\n\n        window.scroll(scroll.x, scroll.y);\n        let anim = animate({\n            target: toWrapper,\n            keyframes: [\n                { transform: `translateX(${this.direction === \"right\" ? \"-\" : \"\"}25%)`, opacity: 0 },\n                { transform: \"translateX(0%)\", opacity: 1 },\n            ],\n            duration,\n            easing: \"out-quint\"\n        })\n\n        return anim.then(function () {\n            document.body.classList.remove(\"no-overflow-x\");\n            this.stop();\n        });\n    }\n};\n\nexport const SlideLeft: ITransition = {\n    ...Slide,\n\n    name: \"slide-left\",\n    direction: \"left\",\n    init(data: ITransition) { }\n};\n\nexport const SlideRight: ITransition = {\n    ...Slide,\n\n    name: \"slide-right\",\n    direction: \"right\",\n    init(data: ITransition) { }\n};\n", "import { Service, animate } from \"../../../packages/native/src/api\";\nimport { toArr } from \"../toArr\";\n\nexport class Navbar extends Service {\n    public navbar: HTMLElement;\n    public elements: HTMLElement[];\n    public menu: HTMLElement;\n    public collapseSection: HTMLElement;\n    public navbarList: HTMLElement;\n    public toggleStatus: boolean;\n\n    public init() {\n        // Elements\n        this.navbar = document.querySelector(\".navbar\") as HTMLElement;\n        this.collapseSection = this.navbar.querySelector(\".navbar-collapse.mobile\") as HTMLElement;\n        this.navbarList = this.navbar.querySelector(\".navbar-list\") as HTMLElement;\n        this.elements = toArr(this.navbar.querySelectorAll(\".navbar-list a\"));\n        this.menu = this.navbar.querySelector(\".navbar-toggle\") as HTMLElement;\n        this.toggleStatus = false;\n\n        this.fixTabindex();\n        this.toggleClick = this.toggleClick.bind(this);\n    }\n\n    public activateLink() {\n        let { href } = window.location;\n\n        for (let el of this.elements) {\n            let itemHref =\n                el.getAttribute(\"data-path\") ||\n                (el as HTMLAnchorElement).href;\n            if (!itemHref || itemHref.length < 1) return;\n\n            let URLmatch = new RegExp(itemHref).test(href);\n            let isActive = el.classList.contains(\"active\");\n            if (!(URLmatch && isActive)) {\n                el.classList.toggle(\"active\", URLmatch);\n            }\n        }\n\n        if (this.toggleStatus) {\n            this.toggleClick();\n        }\n    }\n\n    public fixTabindex() {\n        for (let el of this.elements) {\n            el.setAttribute(\"tabindex\", `${this.toggleStatus ? 0 : -1}`);\n        }\n    }\n\n    public toggleClick() {\n        this.collapseSection.style?.setProperty?.(\"--height\", `${this.navbarList.clientHeight}px`);\n        this.toggleStatus = !this.toggleStatus;\n        this.collapseSection.classList.toggle(\"collapse\", !this.toggleStatus);\n        this.collapseSection.classList.toggle(\"show\", this.toggleStatus);\n        this.fixTabindex();\n    }\n\n    public scroll() {\n        this.navbar.classList.toggle(\"shadow\", window.scrollY >= 5);\n    }\n\n    public initEvents() {\n        this.menu.addEventListener(\"click\", this.toggleClick);\n        this.emitter.on(\"scroll\", this.scroll, this);\n        this.emitter.on(\"READY\", this.activateLink, this);\n        this.emitter.on(\"GO\", this.activateLink, this);\n    }\n\n    public stopEvents() {\n        this.navbar.removeEventListener(\"click\", this.toggleClick);\n        this.emitter.off(\"scroll\", this.scroll, this);\n        this.emitter.off(\"READY\", this.activateLink, this);\n        this.emitter.off(\"GO\", this.activateLink, this);\n    }\n\n    public uninstall() {\n        while (this.elements.length) this.elements.pop();\n        this.elements = undefined;\n        this.menu = undefined;\n        this.navbar = undefined;\n    }\n}", "import { PJAX, App, TransitionManager, Router, HistoryManager, PageManager, animate, Animate } from \"@okikio/native\";\nimport { IntroAnimation } from \"./services/IntroAnimation\";\n\nimport { Fade } from \"./transitions/Fade\";\nimport { BigTransition } from \"./transitions/BigTransition\";\nimport { Slide, SlideLeft, SlideRight } from \"./transitions/Slide\";\n\nimport { toArr } from \"./toArr\";\nimport { Navbar } from \"./services/Navbar\";\n\nlet router: Router, pjax: PJAX;\nconst app: App = new App();\napp\n    .add(new IntroAnimation())\n    .set(\"HistoryManager\", new HistoryManager())\n    .set(\"PageManager\", new PageManager())\n    .set(\"TransitionManager\", new TransitionManager([\n        [\"default\", Fade],\n        [\"BigTransition\", BigTransition],\n        [\"Slide\", Slide],\n        [\"SlideLeft\", SlideLeft],\n        [\"SlideRight\", SlideRight]\n    ]))\n    .add(new Navbar())\n    .set(\"router\", router = new Router())\n    .add(pjax = new PJAX());\n\ntry {\n    router = app.get(\"router\") as Router;\n\n    // This isn't nessceary, but it changes the nav link in focus depending on the page\n    let navLink: HTMLElement[] = toArr(document.querySelectorAll(\".navbar .nav-link\"));\n    for (let item of navLink) {\n        let navItem = (item as HTMLAnchorElement);\n        router.add({\n            path: navItem.getAttribute(\"data-path\") || navItem.pathname,\n            method() {\n                let isActive = navItem.classList.contains(\"active\");\n                if (!isActive) navItem.classList.add(\"active\");\n                for (let nav of navLink) {\n                    if (nav !== navItem)\n                        nav.classList.remove(\"active\");\n                }\n            }\n        });\n    }\n\n    router.add({\n        path: /(index|\\/$)(\\.html)?/,\n        method() { }\n    });\n\n    // app.on(\"AFTER_SPLASHSCREEN_HIDE\", () => {\n    //     anim?.play();\n    // });\n\n    app.boot();\n} catch (err) {\n    console.warn(\"[App] boot failed,\", err);\n}\n"],
  "mappings": "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",
  "names": []
}
